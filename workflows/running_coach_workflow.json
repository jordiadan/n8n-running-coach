{
  "name": "Running Coach",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1600,
        448
      ],
      "id": "8181fc0a-148a-4556-9619-997e448253f7",
      "name": "When clicking â€˜Execute workflowâ€™"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -704,
        448
      ],
      "id": "bbab3a2d-65f6-4afd-bc79-d5792a915a4a",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  const a = item.json;\n  return {\n    json: {\n      id:              a.id,\n      athleteId:       a.icu_athlete_id,\n      date:            new Date(a.start_date),         // ISO 8601\n      type:            a.type,\n      duration:        a.elapsed_time,       // seconds\n      distance:        a.distance,           // meters (or null)\n      calories:        a.calories,\n      trimp:           a.trimp,\n      ctl:             a.icu_ctl,\n      atl:             a.icu_atl,\n      rampRate:        a.rampRate ?? (a.icu_ctl - a.icu_atl),\n      avgHeartRate:    a.average_heartrate,\n      maxHeartRate:    a.max_heartrate,\n      interval_summary: a.interval_summary,  // e.g. [\"1x...\",\"3x...\"]\n      sportInfo:       a.sportInfo           // you can leave the array or map to just types\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1152,
        352
      ],
      "id": "3f360e1c-10e3-49a8-b4a3-73e4b48479f3",
      "name": "Shape Activities"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  const w = item.json;\n  return {\n    json: {\n      id:         w.id,                            // e.g. \"2025-07-10\"\n      athleteId:  w.icu_athlete_id,                // your athlete key\n      date:       new Date(w.updated),                       // ISO timestamp of the record\n      ctl:        w.ctl,                           // chronic training load\n      atl:        w.atl,                           // acute training load\n      rampRate:   w.rampRate ?? (w.ctl - w.atl),   // change in load\n      ctlLoad:    w.ctlLoad,                       // daily CTL â€œloadâ€\n      atlLoad:    w.atlLoad,                       // daily ATL â€œloadâ€\n      restingHR:  w.restingHR,                     // recovery HR\n      hrv:        w.hrv,                           // HRV\n      sleepScore: w.sleepScore,                    // sleep quality\n      steps:      w.steps,                         // daily step count\n      weight:     w.weight                         // body weight (if available)\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1152,
        544
      ],
      "id": "2cc3212b-59ec-4b12-bb69-be867071d7ab",
      "name": "Shape Wellness"
    },
    {
      "parameters": {
        "url": "https://intervals.icu/api/v1/athlete/i372001/wellness",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "oldest",
              "value": "={{ $now.minus({ days: 7 }).toISODate() }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.INTERVALS_AUTH_HEADER || $vars.INTERVALS_AUTH_HEADER }}"
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          },
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        544
      ],
      "id": "43f25252-a6d2-4350-9005-faef42df185c",
      "name": "GET Wellness"
    },
    {
      "parameters": {
        "url": "https://intervals.icu/api/v1/athlete/i372001/activities",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "oldest",
              "value": "={{ $now.minus({ days: 7 }).toISO({ includeOffset: false }) }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.INTERVALS_AUTH_HEADER || $vars.INTERVALS_AUTH_HEADER }}"
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          },
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        352
      ],
      "id": "14d91aca-0f01-43a4-be95-8852730b31fe",
      "name": "GET Activities"
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "activities",
        "fields": "id, athleteId, date, type, duration, distance, calories, trimp, ctl, atl, rampRate, avgHeartRate, maxHeartRate, interval_summary, sportInfo",
        "upsert": true,
        "options": {
          "dateFields": "date"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -928,
        352
      ],
      "id": "3598eb29-2010-4428-b678-eaa40eeb6806",
      "name": "Activities DB",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "wellness",
        "fields": "id, athleteId, date, ctl, atl, rampRate, ctlLoad, atlLoad, restingHR, hrv, sleepScore, steps, weight",
        "upsert": true,
        "options": {
          "dateFields": "date"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -928,
        544
      ],
      "id": "ad492890-49d5-4580-9278-7272c4a00be6",
      "name": "Wellness DB",
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Function node: Compute weekly_metrics for the CURRENT week (Mondayâ€“Sunday)\n// Input: one item whose JSON has { activities: [...], wellness: [...] }\n\nconst { activities: acts, wellness: well } = items[0].json;\n\n// 1ï¸âƒ£ Compute current week boundaries (Monday 00:00 to Sunday 23:59:59)\nconst today = new Date();\nconst day = today.getDay();               // 0=Sun, 1=Mon, â€¦ 6=Sat\nconst diffToMonday = (day + 6) % 7;\nconst monday = new Date(today);\nmonday.setDate(today.getDate() - diffToMonday);\nmonday.setHours(0,0,0,0);\nconst sunday = new Date(monday);\nsunday.setDate(monday.getDate() + 6);\nsunday.setHours(23,59,59,999);\n\n// 2ï¸âƒ£ Helper: average over non-null\nconst avg = arr => arr.length\n  ? arr.reduce((sum, v) => sum + v, 0) / arr.length\n  : 0;\n\n// 3ï¸âƒ£ Filter this weekâ€™s activities\nconst inWeek = a => {\n  const d = new Date(a.start_date);\n  return d >= monday && d <= sunday;\n};\nconst weekActs = acts.filter(inWeek);\n\n// 4ï¸âƒ£ Run, ride & strength metrics\nconst runActs      = weekActs.filter(a => a.type === 'Run');\nconst rideActs     = weekActs.filter(a => /Ride/.test(a.type));\nconst strengthActs = weekActs.filter(a => a.type === 'WeightTraining');\n\nconst runCount     = runActs.length;\nconst runDistance  = runActs.reduce((s,a) => s + (a.distance||0), 0);\nconst runTime      = runActs.reduce((s,a) => s + (a.elapsed_time||0), 0);\n\nconst rideCount    = rideActs.length;\nconst rideDistance = rideActs.reduce((s,a) => s + (a.distance||0), 0);\nconst rideTime     = rideActs.reduce((s,a) => s + (a.elapsed_time||0), 0);\nconst rideTrimp    = rideActs.reduce((s,a) => s + (a.trimp||0), 0);\n\nconst strengthCount = strengthActs.length;\nconst strengthTrimp = strengthActs.reduce((s,a) => s + (a.trimp||0), 0);\n\n// 5ï¸âƒ£ Sessionâ€type counts by keyword in activity name\nconst vo2Sessions   = runActs.filter(a => /vo2/i.test(a.name)).length;\nconst tempoSessions = runActs.filter(a => /tempo|threshold|umbral/i.test(a.name)).length;\nconst longRuns      = runActs.filter(a => /long/i.test(a.name)).length;\n\n// 6ï¸âƒ£ Wellness this week (filter by id = YYYY-MM-DD)\nconst wellWeek = well.filter(w => {\n  const d = new Date(w.id);\n  return d >= monday && d <= sunday;\n});\n\nconst ctlMean        = avg(wellWeek.map(w=>w.ctl||0));\nconst atlMean        = avg(wellWeek.map(w=>w.atl||0));\nconst rampRateMean   = avg(wellWeek.map(w=>w.rampRate||0));\nconst restHrMean     = avg(wellWeek.map(w=>w.restingHR||0));\nconst stepsMean      = avg(wellWeek.map(w=>w.steps||0));\nconst sleepScoreMean = avg(wellWeek.map(w=>w.sleepScore||0));\nconst hrvMean        = avg(wellWeek.map(w=>w.hrv||0));\n\n// 7ï¸âƒ£ Identify athleteId (from any activity)\nconst athleteId = acts.length\n  ? acts[0].icu_athlete_id\n  : null;\n\n// 8ï¸âƒ£ Build weekly_metrics record\nconst weekStart = monday.toISOString().slice(0,10);\nconst weekEnd   = sunday.toISOString().slice(0,10);\nconst now       = new Date().toISOString();\n\nreturn [{\n  json: {\n    athleteId,\n    weekStart,\n    weekEnd,\n\n    runCount,\n    runDistance,\n    runTime,\n\n    rideCount,\n    rideDistance,\n    rideTime,\n    rideTrimp,\n\n    vo2Sessions,\n    tempoSessions,\n    longRuns,\n\n    strengthCount,\n    strengthTrimp,\n\n    ctlMean,\n    atlMean,\n    rampRateMean,\n\n    restHrMean,\n    stepsMean,\n    sleepScoreMean,\n    hrvMean,\n\n    createdAt: now,\n    updatedAt: now\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        96
      ],
      "id": "7196222d-0aea-4faa-8189-fb0bbb8d9379",
      "name": "Shape Weekly Metrics"
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "weekly_metrics",
        "updateKey": "weekStart",
        "fields": "athleteId, weekStart, weekEnd, runCount, runDistance, runTime, rideCount, rideDistance, rideTime, rideTrimp, vo2Sessions, tempoSessions, longRuns, strengthCount, strengthTrimp, ctlMean, atlMean, rampRateMean, restHrMean, stepsMean, sleepScoreMean, hrvMean, createdAt, updatedAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt, updatedAt"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ],
      "id": "8e7ba141-3fdf-4a40-a2d2-50d1705d6aff",
      "name": "Weekly Metrics DB",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "collection": "weekly_metrics",
        "options": {
          "sort": "{ \"weekStart\": -1 }"
        },
        "query": "={\n  \"weekStart\": {\n    \"$lt\": \"{{ $json.weekStart }}\"\n  }\n}\n"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        0,
        192
      ],
      "id": "2f2bc56d-2b5f-46ca-adf1-ad302a398f4e",
      "name": "Read Previous Weeks",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        224,
        96
      ],
      "id": "46575de3-0c9d-4381-ba47-c93f9625b9cd",
      "name": "Merge Current & History"
    },
    {
      "parameters": {
        "jsCode": "// El primer Ã­tem es el current\nconst current = items[0].json;\n\n// Los siguientes Ã­tems son tu histÃ³rico\nconst pastWeeks = items.slice(1).map(i => i.json);\n\nreturn [{\n  json: {\n    current,       // todas las mÃ©tricas y el prompt de esta semana\n    history: pastWeeks  // tu histÃ³rico ya preparado\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        96
      ],
      "id": "e9f1806a-cb9c-4797-9969-ab99ad3442eb",
      "name": "Map Current + History"
    },
    {
      "parameters": {
        "jsCode": "// in a Function node (Run Once for All Items)\n\nconst activities = $items(\"GET Activities\").map(item => item.json);\nconst wellness   = $items(\"GET Wellness\"  ).map(item => item.json);\n\nreturn [\n  {\n    json: {\n      activities,\n      wellness\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -480,
        448
      ],
      "id": "b677badd-1fbf-4f1d-a40d-1648c59871fa",
      "name": "Map Activities + Wellness"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        640,
        448
      ],
      "id": "c90609f0-5298-4df0-9c53-22d304b3a8c1",
      "name": "Merge Request Data"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Prompt Builder para generar el JSON limpio que le enviaremos a OpenAI\n * Incluye semana, fechas y solicita al modelo los campos necesarios.\n */\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” CONFIGURACIÃ“N â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n\n// Fecha de inicio de tu plan (puedes ajustarla)\nconst programStartDate = new Date('2025-07-19');\n\n// Fecha de la competiciÃ³n\nconst raceDate = new Date('2026-02-15');\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” CÃLCULOS DE FECHAS â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n\nconst today = new Date();\nconst msPerWeek = 7 * 24 * 60 * 60 * 1000;\nconst weeksSinceStart = Math.floor((today - programStartDate) / msPerWeek) + 1;\nconst weeksToRace = Math.ceil((raceDate - today) / msPerWeek);\nconst totalPlanWeeks = weeksSinceStart + weeksToRace;\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” DETERMINACIÃ“N DE FASE â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n\nlet phaseName, phaseNote;\nif (weeksSinceStart <= Math.floor(totalPlanWeeks * 0.3)) {\n  phaseName = 'Base';\n  phaseNote = 'Rodajes suaves y fuerza general.';\n} else if (weeksSinceStart <= Math.floor(totalPlanWeeks * 0.7)) {\n  phaseName = 'Desarrollo';\n  phaseNote = 'IntervÃ¡licos, tempo runs y fuerza especÃ­fica.';\n} else if (weeksToRace > 2) {\n  phaseName = 'EspecÃ­fica';\n  phaseNote = 'Ritmo objetivo, simulaciones de competiciÃ³n.';\n} else {\n  phaseName = 'Taper';\n  phaseNote = 'ReducciÃ³n de carga manteniendo chispa.';\n}\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” DESCOMPOSICIÃ“N DE DATOS â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n\nlet current = {};\nlet rawHistory = [];\nlet sourceActivities = [];\nlet sourceWellness = [];\nlet sourceHeartRateSync = {};\nlet sourceRunId = null;\n\nfor (const item of items) {\n  const payload = item && item.json && typeof item.json === 'object' ? item.json : {};\n\n  if (Object.keys(current).length === 0 && payload.current && typeof payload.current === 'object') {\n    current = payload.current;\n  }\n\n  if ((!Array.isArray(rawHistory) || rawHistory.length === 0) && Array.isArray(payload.history)) {\n    rawHistory = payload.history;\n  }\n\n  if (Array.isArray(payload.activities) && payload.activities.length >= sourceActivities.length) {\n    sourceActivities = payload.activities;\n  }\n\n  if (Array.isArray(payload.wellness) && payload.wellness.length >= sourceWellness.length) {\n    sourceWellness = payload.wellness;\n  }\n\n  if (Object.keys(sourceHeartRateSync).length === 0 && payload.heartRateSync && typeof payload.heartRateSync === 'object') {\n    sourceHeartRateSync = payload.heartRateSync;\n  }\n\n  if (!sourceRunId && typeof payload.runId === 'string' && payload.runId.trim()) {\n    sourceRunId = payload.runId.trim();\n  }\n}\n\nconst history = Array.isArray(rawHistory)\n  ? rawHistory\n      .sort((a, b) => b.weekStart.localeCompare(a.weekStart))\n      .slice(0, 4)\n  : [];\n\nconst activities = sourceActivities;\nconst wellness = sourceWellness;\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” EXTRACCIÃ“N DE ZONAS DE FC â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n\nconst DEFAULT_FCMAX = 202;\nconst toNum = (value) => {\n  if (value === null || value === undefined || value === '') return null;\n  const parsed = Number(value);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst recordedMaxHR = Math.max(\n  ...activities.map(a => a.max_heartrate || 0).filter(hr => hr > 0)\n);\n\nconst heartRateSync = sourceHeartRateSync && typeof sourceHeartRateSync === 'object'\n  ? sourceHeartRateSync\n  : {};\nconst hrMax = toNum(heartRateSync.hrMax);\nconst hrRest = toNum(heartRateSync.hrRest);\nconst lthr = toNum(heartRateSync.lthr);\nconst zoneMethod = typeof heartRateSync.zoneMethod === 'string' ? heartRateSync.zoneMethod : null;\nconst computedZones = heartRateSync.computedZones && typeof heartRateSync.computedZones === 'object'\n  ? heartRateSync.computedZones\n  : null;\nconst zonesUpdated = Boolean(heartRateSync.zonesUpdated);\nconst zoneUpdateNotice = typeof heartRateSync.zoneUpdateNotice === 'string' ? heartRateSync.zoneUpdateNotice : null;\nconst hrSyncLog = heartRateSync.hrSyncLog && typeof heartRateSync.hrSyncLog === 'object'\n  ? heartRateSync.hrSyncLog\n  : null;\n\nconst fcMax = hrMax ?? (recordedMaxHR >= 190 ? recordedMaxHR : DEFAULT_FCMAX);\nconst zoneSummary = computedZones\n  ? ['z1', 'z2', 'z3', 'z4', 'z5']\n      .map((key) => {\n        const zone = computedZones[key];\n        if (!zone || zone.min == null || zone.max == null) return null;\n        return `${key.toUpperCase()} ${zone.min}-${zone.max}`;\n      })\n      .filter(Boolean)\n      .join(', ')\n  : null;\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” HELPERS â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n\nconst avg = arr => arr.length ? arr.reduce((sum, v) => sum + v, 0) / arr.length : 0;\nconst fmt = x   => x != null ? x.toFixed(1) : 'â€”';\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” MÃ‰TRICAS SEMANA ACTUAL â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n\nconst { weekStart, weekEnd } = current;\nconst ctlActs    = avg( activities.map(a => a.icu_ctl      || 0) );\nconst atlActs    = avg( activities.map(a => a.icu_atl      || 0) );\nconst rampActs   = avg( activities.map(a => a.icu_rampRate || 0) );\nconst totalTrimp = activities.reduce((s,a) => s + (a.trimp || 0), 0);\n\nconst restVals = [...activities, ...wellness]\n  .map(o => o.restingHR).filter(v => v != null);\nconst stepVals = [...activities, ...wellness]\n  .map(o => o.steps).filter(v => v != null);\n\nconst restHR   = avg(restVals);\nconst steps    = avg(stepVals);\nconst hrvWel   = avg( wellness.map(w => w.hrv        || 0) );\nconst sleepWel = avg( wellness.map(w => w.sleepScore || 0) );\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” CONSTRUCCIÃ“N DEL PROMPT (FORZAR JSON PURA) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n\nconst prompt = `\n// PROMPT_BEGIN\nEres mi coach experto en medio maratÃ³n (mÃ©todo noruego, hÃ­brido fuerza+carrera).\n\nContexto:\n- Mitja MaratÃ³ Barcelona (15â€‘02â€‘2026), objetivo 1h45m (~4:59/km).\n- Empezamos el plan el ${programStartDate.toISOString().slice(0,10)}, esta es la semana **${weeksSinceStart}** de un plan de **${totalPlanWeeks}** semanas.\n- Quedan **${weeksToRace}** semanas â†’ Fase **${phaseName}**: ${phaseNote}\n\nResumen ${weekStart} â†’ ${weekEnd}:\nâ€¢ CTL avg: ${fmt(ctlActs)}, ATL avg: ${fmt(atlActs)}, RampRate avg: ${fmt(rampActs)}\nâ€¢ TRIMP total: ${fmt(totalTrimp)}\nâ€¢ FC reposo medio: ${fmt(restHR)}â€¯bpm, Pasos/dÃ­a medio: ${fmt(steps)}\nâ€¢ HRV avg: ${fmt(hrvWel)}, SleepScore avg: ${fmt(sleepWel)}\n\nHistorial (4 semanas anteriores):\n${history.map(h =>\n  `- Semana ${h.weekStart}: ${fmt(h.runDistance/1000)}â€¯km Â· ATLâ€¯${fmt(h.atlMean)} Â· RampRateâ€¯${fmt(h.rampRateMean)} Â· RHRâ€¯${fmt(h.restHrMean)}`\n).join('\\n')}\n\n\nPor favor genera mi plan PARA LA PRÃ“XIMA SEMANA siguiendo el mÃ©todo noruego:\n- Indica fase del plan y el objetivo de la semana.\n- **Gimnasio**: Mar, Jue y SÃ¡b (orden: Pecho y brazos, Espalda y hombros, Piernas).\n- **Running** segÃºn carga (CTL, ATL, TRIMP, HRV/SueÃ±o):\n  1. SesiÃ³n VOâ‚‚â€¯mÃ¡x  \n  2. SesiÃ³n tempo/umbral  \n  3. Tirada larga aerÃ³bica  \n  4. Easy/recovery  \n\n\n**IMPORTANTE**:  \n- Gimnasio a las 12â€“13h, calcula recuperaciÃ³n y planifica alrededor.  \n- Usa **zonas de FC Garmin (Z1â€“Z5)** con mÃ©todo ${zoneMethod || '%HRR'} y FCmÃ¡x=${fcMax}â€¯bpm; indica % y rango de bpm.  \n- FC reposo de referencia: ${hrRest != null ? `${hrRest} bpm` : 'no disponible'}.\n- LTHR de referencia: ${lthr != null ? `${lthr} bpm` : 'no disponible'}.\n- Zonas objetivo: ${zoneSummary || 'calcular con %HRR (Karvonen) cuando falten zonas precomputadas'}.\n\n\n\nSALIDA (OBLIGATORIA):\n\n- Devuelve exclusivamente un JSON vÃ¡lido y minificado en UNA sola lÃ­nea (sin texto extra, sin bloques de cÃ³digo, sin comentarios).\n- Sustituye en todos los textos: &â†’&amp;, <â†’&lt;, >â†’&gt;.\n- La respuesta empieza con { y termina con }.\n- Presupuesto total estricto: â‰¤ 2600 caracteres.\n\nLÃ­mites obligatorios por campo (no exceder):\n- activityPlan.nextWeek.phase: 1-32 caracteres\n- activityPlan.nextWeek.objective: 1-120 caracteres\n- activityPlan.days[].activity: 1-24 caracteres\n- activityPlan.days[].distance_time: 1-24 caracteres\n- activityPlan.days[].intensity: 1-32 caracteres\n- activityPlan.days[].goal: 1-72 caracteres\n- activityPlan.days[].note: 0-80 caracteres (opcional)\n- justification: array de 2 a 3 items\n- justification[]: 1-110 caracteres por item\n\nEstructura EXACTA con 7 objetos en days (uno por cada dÃ­a de la semana). Si te quedas sin espacio, reformula mÃ¡s corto sin omitir campos obligatorios.\n\n\\`\\`\\`json\n{\n  \"schema_version\": \"1.0\",\n  \"activityPlan\": {\n    \"nextWeek\": {\n      \"phase\": string,\n      \"objective\": string,\n      \"weekStart\": string,   // e.g. \"2025-07-14\"\n      \"weekEnd\":   string    // e.g. \"2025-07-20\"\n    },\n    \"days\": [\n      {\n        \"day\": string,         // Nombre en espaÃ±ol, ej. \"Lunes\"\n        \"date\": string,        // Fecha concreta, ej. \"2025-07-14\"\n        \"activity\": string,\n        \"distance_time\": string,\n        \"intensity\": string,\n        \"goal\": string,\n        \"note\": string\n      }\n      // â€¦un objeto por cada dÃ­a de la semana\n    ]\n  },\n  \"justification\": [ string, â€¦ ]\n}\n\\`\\`\\`\n// PROMPT_END\n`.trim();\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” RETORNO â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n\nconst runId = sourceRunId || `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst PROMPT_VERSION = \"2026-02-19\";\n// Bump PROMPT_VERSION whenever the prompt template changes.\nconst modelId = \"gpt-5\";\nconst createdAt = new Date().toISOString();\n\nreturn [{\n  json: {\n    runId,\n    promptVersion: PROMPT_VERSION,\n    modelId,\n    createdAt,\n    prompt,\n    metrics: {\n      programStartDate: programStartDate.toISOString().slice(0,10),\n      weeksSinceStart,\n      totalPlanWeeks,\n      weeksToRace,\n      phaseName,\n      weekStart,\n      weekEnd,\n      ctlActs,\n      atlActs,\n      rampActs,\n      totalTrimp,\n      restHR,\n      steps,\n      hrvWel,\n      sleepWel,\n      fcMax,\n      hrMax,\n      hrRest,\n      lthr,\n      zoneMethod,\n      zonesUpdated\n    },\n    heartRate: {\n      hrMax,\n      hrRest,\n      lthr,\n      zoneMethod,\n      computedZones,\n      zonesUpdated,\n      zoneUpdateNotice,\n      hrSyncLog,\n    },\n    history,\n    activities,\n    wellness\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        448
      ],
      "id": "76c7ae56-2f54-4c18-9fef-774b12705f5b",
      "name": "Prompt Builder"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.prompt }}",
              "role": "system"
            },
            {
              "content": "={{\n  `Datos de la ÃšLTIMA SEMANA:\\n` +\n  `MÃ©tricas: ${JSON.stringify($json.metrics, null, 2)}\\n\\n` +\n  `Historial (semanas anteriores): ${JSON.stringify($json.history, null, 2)}`\n}}"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        1088,
        448
      ],
      "id": "34773ad2-7d76-4f29-a297-bc1c86ddabf6",
      "name": "Message a model",
      "alwaysOutputData": false,
      "credentials": {
        "openAiApi": {
          "id": "olyatB4PnLtBz9VL",
          "name": "OpenAi account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.htmlMessage }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1712,
        448
      ],
      "id": "f044dc1e-c6df-4372-8334-1dee1dc7a75f",
      "name": "Send a text message",
      "webhookId": "2300ed5a-c28d-45ed-93fc-3b3df686f46d",
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const TEMPLATE_VERSION = 'telegram-v2.2';\n\nconst DEFAULT_CHAT_ID = '730354404';\n\nconst isObject = (value) => value !== null && typeof value === 'object' && !Array.isArray(value);\n\nconst parseContent = (input) => {\n  if (typeof input !== 'string') {\n    return input;\n  }\n  try {\n    return JSON.parse(input);\n  } catch {\n    return null;\n  }\n};\n\nconst payloads = items\n  .map((item) => (item && item.json ? item.json : {}))\n  .filter((payload) => payload && Object.keys(payload).length > 0);\n\nconst getNodeItemsSafe = (nodeName) => {\n  try {\n    const nodeItems = $items(nodeName);\n    return Array.isArray(nodeItems) ? nodeItems : [];\n  } catch {\n    return [];\n  }\n};\n\nconst fallbackNodeNames = [\n  'Build Run Event (success)',\n  'Validate WeeklyPlan (attempt 0)',\n];\n\nconst fallbackNodeCounts = {};\nconst fallbackPayloads = [];\nfor (const nodeName of fallbackNodeNames) {\n  const nodeItems = getNodeItemsSafe(nodeName);\n  fallbackNodeCounts[nodeName] = nodeItems.length;\n  for (const nodeItem of nodeItems) {\n    const payload = nodeItem && nodeItem.json ? nodeItem.json : {};\n    if (payload && Object.keys(payload).length > 0) {\n      fallbackPayloads.push(payload);\n    }\n  }\n}\n\nconst allPayloads = [...payloads, ...fallbackPayloads];\n\nconst parsePlanCandidate = (payload) => {\n  const raw = Array.isArray(payload.choices)\n    ? payload.choices[0] && payload.choices[0].message\n      ? payload.choices[0].message.content\n      : null\n    : payload;\n  const parsed = parseContent(raw);\n  return isObject(parsed) ? parsed : null;\n};\n\nconst parsedCandidates = allPayloads\n  .map((payload) => parsePlanCandidate(payload))\n  .filter((payload) => payload !== null);\n\nconst content = parsedCandidates.find((payload) => isObject(payload.activityPlan)) || null;\nif (!content) {\n  const inboundKeys = payloads\n    .slice(0, 3)\n    .map((payload) => Object.keys(payload).slice(0, 8));\n  throw new Error(\n    `Missing or invalid activityPlan in response. inbound_payloads=${payloads.length}; fallback_counts=${JSON.stringify(fallbackNodeCounts)}; inbound_keys=${JSON.stringify(inboundKeys)}`,\n  );\n}\n\nconst supplementalPayload = {};\n\nconst plan = content.activityPlan;\nconst nextWeek = isObject(plan.nextWeek) ? plan.nextWeek : {};\nconst days = Array.isArray(plan.days) ? plan.days : [];\nconst justifications = Array.isArray(content.justification) ? content.justification : [];\n\nconst getVar = (key) => {\n  if (typeof $vars !== 'undefined' && $vars[key] != null) {\n    return String($vars[key]);\n  }\n  if (typeof process !== 'undefined' && process.env && process.env[key] != null) {\n    return String(process.env[key]);\n  }\n  return '';\n};\n\nconst isTruthy = (value) => ['1', 'true', 'yes', 'on'].includes(String(value).toLowerCase());\n\nconst previewEnabled = isTruthy(getVar('RC_TELEGRAM_PREVIEW_MODE'));\nconst previewChatRaw = getVar('RC_TELEGRAM_PREVIEW_CHAT_ID').trim();\nif (previewEnabled && !previewChatRaw) {\n  throw new Error('RC_TELEGRAM_PREVIEW_CHAT_ID is required when RC_TELEGRAM_PREVIEW_MODE is enabled.');\n}\nconst targetChatId = previewEnabled ? previewChatRaw : DEFAULT_CHAT_ID;\n\nconst runContextItems = $items('Prompt Builder');\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst metrics = isObject(runContext.metrics) ? runContext.metrics : {};\nconst history = Array.isArray(runContext.history) ? runContext.history : [];\n\nconst heartRate = isObject(runContext.heartRate) ? runContext.heartRate : {};\nconst hrSyncLog = isObject(heartRate.hrSyncLog) ? heartRate.hrSyncLog : {};\nconst zonesUpdated = Boolean(heartRate.zonesUpdated);\nconst toHrString = (value) => (value === null || value === undefined || value === '' ? '-' : String(Math.round(Number(value))));\nconst zoneUpdateNotice = zonesUpdated\n  ? (typeof heartRate.zoneUpdateNotice === 'string' && heartRate.zoneUpdateNotice.trim()\n      ? heartRate.zoneUpdateNotice.trim()\n      : `ğŸ› ï¸ Zonas actualizadas: Max ${toHrString(hrSyncLog.hrMax_old)}â†’${toHrString(hrSyncLog.hrMax_new)} Â· Reposo ${toHrString(hrSyncLog.hrRest_old)}â†’${toHrString(hrSyncLog.hrRest_new)} Â· Umbral ${toHrString(hrSyncLog.lthr_old)}â†’${toHrString(hrSyncLog.lthr_new)}`)\n  : null;\n\n\nconst valueOr = (value, fallback = '--') => {\n  if (value === null || value === undefined) return fallback;\n  const text = String(value).trim();\n  return text || fallback;\n};\n\nconst esc = (value) => String(value)\n  .replace(/&/g, '&amp;')\n  .replace(/</g, '&lt;')\n  .replace(/>/g, '&gt;')\n  .replace(/\"/g, '&quot;')\n  .replace(/'/g, '&#39;');\n\nconst num = (value) => {\n  if (value === null || value === undefined || value === '') return null;\n  const parsed = Number(value);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst mean = (values) => {\n  const valid = values.map(num).filter((value) => value !== null);\n  if (!valid.length) return null;\n  return valid.reduce((sum, value) => sum + value, 0) / valid.length;\n};\n\nconst fmt = (value, suffix = '') => (value === null ? '--' : `${value.toFixed(1)}${suffix}`);\nconst pct = (value) => (value === null ? '--' : `${(value * 100).toFixed(0)}%`);\n\nconst intOrZero = (value) => {\n  const parsed = Number.parseInt(value, 10);\n  return Number.isFinite(parsed) ? parsed : 0;\n};\n\nconst normalizeDay = (value) => String(value || '')\n  .toLowerCase()\n  .replace(/[Ã¡Ã Ã¤]/g, 'a')\n  .replace(/[Ã©Ã¨Ã«]/g, 'e')\n  .replace(/[Ã­Ã¬Ã¯]/g, 'i')\n  .replace(/[Ã³Ã²Ã¶]/g, 'o')\n  .replace(/[ÃºÃ¹Ã¼]/g, 'u')\n  .replace(/Ã±/g, 'n');\n\nconst dayOrder = {\n  lunes: 0,\n  monday: 0,\n  martes: 1,\n  tuesday: 1,\n  miercoles: 2,\n  wednesday: 2,\n  jueves: 3,\n  thursday: 3,\n  viernes: 4,\n  friday: 4,\n  sabado: 5,\n  saturday: 5,\n  domingo: 6,\n  sunday: 6,\n};\n\nconst sortedDays = [...days].sort((a, b) => {\n  const aOrder = dayOrder[normalizeDay(a.day)];\n  const bOrder = dayOrder[normalizeDay(b.day)];\n  const safeA = aOrder === undefined ? 99 : aOrder;\n  const safeB = bOrder === undefined ? 99 : bOrder;\n  if (safeA !== safeB) return safeA - safeB;\n  return String(a.date || '').localeCompare(String(b.date || ''));\n});\n\nconst ctlNow = num(metrics.ctlActs);\nconst atlNow = num(metrics.atlActs);\nconst rampNow = num(metrics.rampActs);\nconst trimpNow = num(metrics.totalTrimp);\nconst restNow = num(metrics.restHR);\nconst hrvNow = num(metrics.hrvWel);\nconst sleepNow = num(metrics.sleepWel);\nconst stepsNow = num(metrics.steps);\n\nconst lastWeekSummaryLines = [];\nif (ctlNow !== null || atlNow !== null || rampNow !== null) {\n  lastWeekSummaryLines.push(`Carga (CTL/ATL/Ramp): ${fmt(ctlNow)} / ${fmt(atlNow)} / ${fmt(rampNow)}`);\n}\nif (trimpNow !== null) {\n  lastWeekSummaryLines.push(`TRIMP semanal: ${fmt(trimpNow)}`);\n}\nif (restNow !== null || hrvNow !== null || sleepNow !== null) {\n  lastWeekSummaryLines.push(`RecuperaciÃ³n: FC reposo ${fmt(restNow)} bpm, HRV ${fmt(hrvNow)}, SueÃ±o ${fmt(sleepNow)}`);\n}\nif (stepsNow !== null) {\n  lastWeekSummaryLines.push(`Pasos medios/dÃ­a: ${fmt(stepsNow)}`);\n}\nconst hasLastWeekSummaryData = lastWeekSummaryLines.length > 0;\nif (!hasLastWeekSummaryData) {\n  lastWeekSummaryLines.push('Sin mÃ©tricas recientes.');\n}\n\n\nconst weekStart = valueOr(nextWeek.weekStart);\nconst weekEnd = valueOr(nextWeek.weekEnd);\nconst phase = valueOr(nextWeek.phase);\nconst objective = valueOr(nextWeek.objective);\n\nconst thisWeekGoalLines = [\n  `Semana: ${weekStart} -> ${weekEnd}`,\n  `Fase: ${phase}`,\n  `Objetivo: ${objective}`,\n];\nif (justifications.length) {\n  const rationale = justifications\n    .slice(0, 3)\n    .map((item) => valueOr(item))\n    .join(' | ');\n  thisWeekGoalLines.push(`JustificaciÃ³n breve: ${rationale}`);\n}\nconst hasThisWeekGoalData = [nextWeek.weekStart, nextWeek.weekEnd, nextWeek.phase, nextWeek.objective].some(Boolean);\n\nconst dailyPlanLines = sortedDays.map((day) => {\n  const dayName = valueOr(day.day, 'DÃ­a');\n  const date = valueOr(day.date);\n  const activity = valueOr(day.activity);\n  const distanceTime = valueOr(day.distance_time);\n  const intensity = valueOr(day.intensity);\n  const goal = valueOr(day.goal);\n  const note = day.note ? ` | Nota: ${valueOr(day.note, '')}` : '';\n  return `${dayName} (${date}) Â· ${activity} | ${distanceTime} | ${intensity} | ${goal}${note}`;\n});\nif (!dailyPlanLines.length) {\n  dailyPlanLines.push('Sin detalle diario disponible.');\n}\nconst hasCompleteDailyPlan = sortedDays.length === 7;\n\nconst combinedText = (day) => `${valueOr(day.activity, '')} ${valueOr(day.intensity, '')} ${valueOr(day.goal, '')} ${valueOr(day.note, '')}`.toLowerCase();\nconst hardPattern = /(\\bz4\\b|\\bz5\\b|vo2|tempo|threshold|umbral|interval)/;\nconst longPattern = /(\\blong\\b|tirada|larga)/;\n\nconst keySessionDay = sortedDays.find((day) => hardPattern.test(combinedText(day)))\n  || sortedDays.find((day) => longPattern.test(combinedText(day)))\n  || sortedDays[0]\n  || null;\n\nconst keySessionLines = [];\nif (keySessionDay) {\n  keySessionLines.push(\n    `${valueOr(keySessionDay.day, 'DÃ­a')} (${valueOr(keySessionDay.date)}) Â· ${valueOr(keySessionDay.activity)} | ${valueOr(keySessionDay.distance_time)} | ${valueOr(keySessionDay.intensity)} | ${valueOr(keySessionDay.goal)}`,\n  );\n  if (keySessionDay.note) {\n    keySessionLines.push(`Nota: ${valueOr(keySessionDay.note, '')}`);\n  }\n} else {\n  keySessionLines.push('Sin sesiÃ³n clave identificada.');\n}\nconst hasKeySessionData = Boolean(keySessionDay);\n\nconst baselineHrv = mean(history.map((entry) => entry.hrvMean));\nconst baselineRest = mean(history.map((entry) => entry.restHrMean));\nconst baselineRamp = mean(history.map((entry) => entry.rampRateMean));\n\nconst rationaleCandidates = [];\nconst addRationale = (text, metricKeys) => {\n  rationaleCandidates.push({ text, metricKeys });\n};\n\nif (ctlNow !== null && atlNow !== null && rampNow !== null) {\n  addRationale(\n    `Balance de carga: CTL ${fmt(ctlNow)}, ATL ${fmt(atlNow)}, ramp ${fmt(rampNow)}.`,\n    ['ctlActs', 'atlActs', 'rampActs'],\n  );\n}\nif (trimpNow !== null) {\n  addRationale(\n    `Volumen semanal: TRIMP total ${fmt(trimpNow)}.`,\n    ['totalTrimp'],\n  );\n}\nif (restNow !== null && hrvNow !== null && sleepNow !== null) {\n  addRationale(\n    `Perfil de recuperaciÃ³n: FC reposo ${fmt(restNow)} bpm, HRV ${fmt(hrvNow)}, SueÃ±o ${fmt(sleepNow)}.`,\n    ['restHR', 'hrvWel', 'sleepWel'],\n  );\n}\nif (hrvNow !== null && baselineHrv !== null && restNow !== null && baselineRest !== null) {\n  addRationale(\n    `Tendencia vs base: HRV ${fmt(hrvNow)} vs ${fmt(baselineHrv)}, FC reposo ${fmt(restNow)} vs ${fmt(baselineRest)} bpm.`,\n    ['hrvWel', 'histHrv', 'restHR', 'histRestHR'],\n  );\n}\nif (stepsNow !== null) {\n  addRationale(\n    `Soporte de actividad: pasos medios ${fmt(stepsNow)}.`,\n    ['steps'],\n  );\n}\nif (rampNow !== null && baselineRamp !== null) {\n  addRationale(\n    `GestiÃ³n de ramp: actual ${fmt(rampNow)} vs base ${fmt(baselineRamp)}.`,\n    ['rampActs', 'histRamp'],\n  );\n}\n\nlet whyPlanHallucinationFailures = 0;\nconst whyThisPlan = [];\nconst whyMetricGroups = [];\nfor (const candidate of rationaleCandidates) {\n  const invalid = candidate.metricKeys.some((key) => key == null || key === '');\n  if (invalid) {\n    whyPlanHallucinationFailures += 1;\n    continue;\n  }\n  whyThisPlan.push(candidate.text);\n  whyMetricGroups.push(candidate.metricKeys);\n}\n\nif (whyThisPlan.length < 2) {\n  const fallback = [\n    ['ctlActs', ctlNow, 'CTL'],\n    ['atlActs', atlNow, 'ATL'],\n    ['rampActs', rampNow, 'ramp rate'],\n    ['totalTrimp', trimpNow, 'TRIMP'],\n    ['restHR', restNow, 'resting HR'],\n    ['hrvWel', hrvNow, 'HRV'],\n    ['sleepWel', sleepNow, 'sleep score'],\n    ['steps', stepsNow, 'steps'],\n  ];\n  for (const [key, value, label] of fallback) {\n    if (whyThisPlan.length >= 2) break;\n    if (value === null) continue;\n    const alreadyUsed = whyMetricGroups.some((group) => group.includes(key));\n    if (alreadyUsed) continue;\n    whyThisPlan.push(`SeÃ±al clave: ${label} = ${fmt(value)}.`);\n    whyMetricGroups.push([key]);\n  }\n}\n\nif (whyThisPlan.length < 2) {\n  whyThisPlan.push('MÃ©tricas insuficientes para justificar el plan con mÃ¡s detalle.');\n  whyMetricGroups.push([]);\n}\n\nconst whyThisPlanFinal = whyThisPlan.slice(0, 4);\nconst whyMetricGroupsFinal = whyMetricGroups.slice(0, 4);\nconst whyPlanMetricKeys = Array.from(new Set(whyMetricGroupsFinal.flat()));\n\n\n\nconst riskFlags = [];\nif (hrvNow !== null && baselineHrv !== null && hrvNow < baselineHrv * 0.9) {\n  riskFlags.push({\n    trigger: 'wellnessLow',\n    message: `HRV ${fmt(hrvNow)} vs base ${fmt(baselineHrv)} (>=10% por debajo).`,\n    action: 'Prioriza recuperaciÃ³n y mantÃ©n intensidad baja en la prÃ³xima sesiÃ³n.',\n  });\n}\nif (restNow !== null && baselineRest !== null && restNow > baselineRest + 3) {\n  riskFlags.push({\n    trigger: 'restHrHigh',\n    message: `FC reposo ${fmt(restNow)} bpm vs base ${fmt(baselineRest)} (+3 bpm).`,\n    action: 'Reduce intensidad y monitoriza fatiga matinal durante 48h.',\n  });\n}\nif (rampNow !== null && (rampNow > 5 || (baselineRamp !== null && rampNow > baselineRamp + 1.5))) {\n  riskFlags.push({\n    trigger: 'rampHigh',\n    message: `Ramp alto (${fmt(rampNow)}).`,\n    action: 'Evita aÃ±adir volumen extra esta semana.',\n  });\n}\nif (sleepNow !== null && sleepNow < 70) {\n  riskFlags.push({\n    trigger: 'wellnessLow',\n    message: `SueÃ±o bajo (${fmt(sleepNow)}).`,\n    action: 'Prioriza trabajo aerÃ³bico suave hasta estabilizar el sueÃ±o.',\n  });\n}\nif (ctlNow !== null && atlNow !== null && atlNow - ctlNow > 10) {\n  riskFlags.push({\n    trigger: 'atlOverload',\n    message: `ATL (${fmt(atlNow)}) claramente por encima de CTL (${fmt(ctlNow)}).`,\n    action: 'AÃ±ade recuperaciÃ³n entre esfuerzos de calidad.',\n  });\n}\n\nconst riskWarningTriggers = Array.from(new Set(riskFlags.map((flag) => flag.trigger)));\nconst riskWarningTriggerCounts = {\n  wellnessLow: riskFlags.some((flag) => flag.trigger === 'wellnessLow') ? 1 : 0,\n  rampHigh: riskFlags.some((flag) => flag.trigger === 'rampHigh') ? 1 : 0,\n  painReported: riskFlags.some((flag) => flag.trigger === 'painReported') ? 1 : 0,\n  restHrHigh: riskFlags.some((flag) => flag.trigger === 'restHrHigh') ? 1 : 0,\n  atlOverload: riskFlags.some((flag) => flag.trigger === 'atlOverload') ? 1 : 0,\n};\nconst riskWarningTriggerCount = riskWarningTriggers.length;\n\nconst hasWarningData = riskFlags.length > 0;\nconst warningLines = hasWarningData\n  ? riskFlags.map((flag) => `${flag.message} AcciÃ³n: ${flag.action}`)\n  : ['Sin alertas relevantes con las seÃ±ales actuales.'];\n\nconst sectionCompleteness = {\n  lastWeekSummary: hasLastWeekSummaryData,\n  thisWeekGoal: hasThisWeekGoalData,\n  dailyPlan: hasCompleteDailyPlan,\n  keySession: hasKeySessionData,\n  warnings: hasWarningData,\n};\nconst sectionMissingCount = Object.values(sectionCompleteness).filter((value) => !value).length;\n\nconst sections = [\n  { title: 'Last-week summary', lines: lastWeekSummaryLines },\n  { title: 'This-week goal', lines: thisWeekGoalLines },\n  { title: 'Why this plan', lines: whyThisPlanFinal },\n  { title: 'Daily plan', lines: dailyPlanLines },\n  { title: 'Key session', lines: keySessionLines },\n  { title: 'Warnings', lines: warningLines },\n];\n\nconst keySessionSummary = hasKeySessionData ? keySessionLines[0] : 'Sin sesiÃ³n clave.';\nconst warningSummary = hasWarningData ? warningLines[0] : 'Sin alertas relevantes.';\nconst keySessionDayLabel = keySessionDay ? valueOr(keySessionDay.day, 'la sesiÃ³n clave') : 'la sesiÃ³n clave';\nconst adjustmentRule = riskFlags.length > 0\n  ? `Regla: si se repite la alerta, ${riskFlags[0].action}`\n  : `Regla: si hoy notas fatiga alta, convierte ${keySessionDayLabel} en trabajo suave Z1-Z2 y prioriza recuperaciÃ³n.`;\n\nconst htmlParts = [];\nhtmlParts.push(`ğŸƒâ€â™‚ï¸ <b>Plan semanal</b> ${esc(weekStart)} -> ${esc(weekEnd)}`);\nif (zoneUpdateNotice) {\n  htmlParts.push(esc(zoneUpdateNotice));\n}\nhtmlParts.push('');\nhtmlParts.push('<b>TL;DR</b>');\nhtmlParts.push(`- Objetivo: ${esc(objective)}`);\nhtmlParts.push(`- Estado: SueÃ±o ${esc(fmt(sleepNow))} Â· HRV ${esc(fmt(hrvNow))} Â· FC reposo ${esc(fmt(restNow, ' bpm'))}`);\nhtmlParts.push(`- SesiÃ³n clave: ${esc(keySessionSummary)}`);\nhtmlParts.push(`- Alerta: ${esc(warningSummary)}`);\nhtmlParts.push(`- ${esc(adjustmentRule)}`);\nhtmlParts.push('');\n\nif (previewEnabled) {\n  htmlParts.push('ğŸ§ª <b>Preview mode</b>');\n  htmlParts.push(`- Mensajes enviados al chat preview ${esc(targetChatId)}.`);\n  htmlParts.push('');\n}\n\nfor (const section of sections) {\n  htmlParts.push(`<b>${esc(section.title)}</b>`);\n  for (const line of section.lines) {\n    htmlParts.push(`- ${esc(line)}`);\n  }\n  htmlParts.push('');\n}\n\nconst debugEnabled = isTruthy(getVar('RC_TELEGRAM_DEBUG_FOOTER'));\n\nif (debugEnabled) {\n  const runId = (content.runEvent && content.runEvent.runId)\n    || content.runId\n    || content.__runId\n    || runContext.runId\n    || '-';\n  const attempt = content.__attempt ?? (content.runEvent && content.runEvent.attempt) ?? '-';\n  const promptVersion = content.promptVersion || content.__promptVersion || runContext.promptVersion || '-';\n  const modelId = content.modelId || content.__modelId || runContext.modelId || '-';\n  htmlParts.push('<pre>'\n    + `run_id: ${esc(runId)}\\n`\n    + `attempt: ${esc(attempt)}\\n`\n    + `prompt_version: ${esc(promptVersion)}\\n`\n    + `model: ${esc(modelId)}\\n`\n    + `template_version: ${esc(TEMPLATE_VERSION)}\\n`\n    + `sections_missing: ${esc(sectionMissingCount)}\\n`\n    + `preview_mode: ${esc(previewEnabled)}\\n`\n    + `chat_id: ${esc(targetChatId)}`\n    + '</pre>');\n}\n\nconst TELEGRAM_MESSAGE_BUDGET = 3900;\nconst htmlMessage = htmlParts.join('\\n').trim();\nconst htmlMessageLength = Array.from(htmlMessage).length;\nif (htmlMessageLength > TELEGRAM_MESSAGE_BUDGET) {\n  throw new Error(`telegram_message_too_long: ${htmlMessageLength} > ${TELEGRAM_MESSAGE_BUDGET}`);\n}\n\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\nconst baseRunEvent = isObject(content.runEvent)\n  ? content.runEvent\n  : {\n      runId: `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`,\n      status: 'success',\n      attempt: content.__attempt ?? null,\n      weekStart: nextWeek.weekStart || null,\n      weekEnd: nextWeek.weekEnd || null,\n      errorCount: errors.length,\n      errors,\n      createdAt: new Date().toISOString(),\n    };\n\nconst runEvent = Object.assign({}, baseRunEvent, {\n  telegramTemplateVersion: TEMPLATE_VERSION,\n  sectionCompleteness,\n  sectionMissingCount,\n  whyThisPlan: whyThisPlanFinal,\n  whyPlanMetricKeys,\n  whyPlanHallucinationFailures,\n  previewMode: previewEnabled,\n  previewChatId: targetChatId,\n  riskWarningTriggerCount,\n  riskWarningTriggers,\n  riskWarningTriggerCounts,\n  telegramMessageBudget: TELEGRAM_MESSAGE_BUDGET,\n  telegramMessageLength: htmlMessageLength,\n});\n\nreturn [{\n  json: Object.assign({}, content, runEvent, {\n    runEvent,\n    telegramTemplateVersion: TEMPLATE_VERSION,\n    sectionCompleteness,\n    sectionMissingCount,\n    whyThisPlan: whyThisPlanFinal,\n    whyPlanMetricKeys,\n    whyPlanHallucinationFailures,\n    previewMode: previewEnabled,\n    previewChatId: targetChatId,\n    riskWarningTriggerCount,\n    riskWarningTriggers,\n    riskWarningTriggerCounts,\n    telegramMessageBudget: TELEGRAM_MESSAGE_BUDGET,\n    telegramMessageLength: htmlMessageLength,\n    chatId: targetChatId,\n    htmlMessage,\n  }),\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        448
      ],
      "id": "ac201b6e-375f-48f5-9b1a-656f3987aa2c",
      "name": "Build Telegram Message"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 0 21 * * 0"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1600,
        640
      ],
      "id": "a666d5c6-fc73-4016-9518-04b879e1022b",
      "name": "Schedule Trigger"
    },
    {
      "id": "9522f055-e183-4aaa-b75e-803aecae3754",
      "name": "Validate WeeklyPlan (attempt 0)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        448
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 0;\n\nconst raw = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nlet parsed = raw;\nlet parseError = null;\n\nif (typeof raw === 'string') {\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    parseError = err && err.message ? err.message : String(err);\n    parsed = null;\n  }\n}\n\nconst errors = [];\n\nif (parseError) {\n  errors.push(`invalid_json: ${parseError}`);\n}\n\nconst isObject = value => value && typeof value === 'object' && !Array.isArray(value);\nconst plan = isObject(parsed) ? parsed : {};\n\nconst dateRe = /^\\d{4}-\\d{2}-\\d{2}$/;\nconst dayRe = /^(Lunes|Martes|Miercoles|Mi\\u00e9rcoles|Jueves|Viernes|Sabado|S\\u00e1bado|Domingo)$/;\nconst intensityRe = /^(?:-|--|\\u2014|.*\\b(Z[1-5]|interval|Interval|VO2|Tempo|tempo|Umbral|umbral|Threshold|threshold|Easy|easy|Recovery|recovery)\\b.*)$/;\n\nconst reqString = (obj, key, path) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string' || !value.trim()) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  return true;\n};\n\nconst MAX_LENGTHS = {\n  phase: 32,\n  objective: 120,\n  activity: 24,\n  distance_time: 24,\n  intensity: 32,\n  goal: 72,\n  note: 80,\n  justification: 110,\n};\n\nconst reqMaxLen = (obj, key, path, maxLen) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string') {\n    errors.push(`${path}.${key} must be string`);\n    return false;\n  }\n  const trimmed = value.trim();\n  if (!trimmed) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  if (trimmed.length > maxLen) {\n    errors.push(`${path}.${key} too long (${trimmed.length} > ${maxLen})`);\n    return false;\n  }\n  return true;\n};\n\nif (plan.schema_version !== '1.0') {\n  errors.push('schema_version must be \"1.0\"');\n}\n\nif (!isObject(plan.activityPlan)) {\n  errors.push('activityPlan must be object');\n}\n\nconst nextWeek = plan.activityPlan && plan.activityPlan.nextWeek;\nif (!isObject(nextWeek)) {\n  errors.push('activityPlan.nextWeek must be object');\n} else {\n  if (reqString(nextWeek, 'phase', 'activityPlan.nextWeek')) {\n    reqMaxLen(nextWeek, 'phase', 'activityPlan.nextWeek', MAX_LENGTHS.phase);\n  }\n  if (reqString(nextWeek, 'objective', 'activityPlan.nextWeek')) {\n    reqMaxLen(nextWeek, 'objective', 'activityPlan.nextWeek', MAX_LENGTHS.objective);\n  }\n  if (!reqString(nextWeek, 'weekStart', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekStart)) {\n    errors.push('activityPlan.nextWeek.weekStart must be YYYY-MM-DD');\n  }\n  if (!reqString(nextWeek, 'weekEnd', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekEnd)) {\n    errors.push('activityPlan.nextWeek.weekEnd must be YYYY-MM-DD');\n  }\n}\n\nconst days = plan.activityPlan && plan.activityPlan.days;\nif (!Array.isArray(days)) {\n  errors.push('activityPlan.days must be array');\n} else if (days.length !== 7) {\n  errors.push('activityPlan.days must have length 7');\n} else {\n  days.forEach((day, idx) => {\n    const path = `activityPlan.days[${idx}]`;\n    if (!isObject(day)) {\n      errors.push(`${path} must be object`);\n      return;\n    }\n    if (!reqString(day, 'day', path) || !dayRe.test(day.day)) {\n      errors.push(`${path}.day must be a valid weekday`);\n    }\n    if (!reqString(day, 'date', path) || !dateRe.test(day.date)) {\n      errors.push(`${path}.date must be YYYY-MM-DD`);\n    }\n    if (reqString(day, 'activity', path)) {\n      reqMaxLen(day, 'activity', path, MAX_LENGTHS.activity);\n    }\n    if (reqString(day, 'distance_time', path)) {\n      reqMaxLen(day, 'distance_time', path, MAX_LENGTHS.distance_time);\n    }\n    if (!reqString(day, 'intensity', path) || !intensityRe.test(day.intensity)) {\n      errors.push(`${path}.intensity must include a zone/label or be '-'/'--'/'â€”'`);\n    } else {\n      reqMaxLen(day, 'intensity', path, MAX_LENGTHS.intensity);\n    }\n    if (reqString(day, 'goal', path)) {\n      reqMaxLen(day, 'goal', path, MAX_LENGTHS.goal);\n    }\n\n    if (day.note != null && String(day.note).trim() !== '') {\n      if (typeof day.note !== 'string') {\n        errors.push(`${path}.note must be string`);\n      } else if (day.note.trim().length > MAX_LENGTHS.note) {\n        errors.push(`${path}.note too long (${day.note.trim().length} > ${MAX_LENGTHS.note})`);\n      }\n    }\n  });\n}\n\n\nconst justification = plan.justification;\nif (!Array.isArray(justification)) {\n  errors.push('justification must be array');\n} else {\n  if (justification.length < 2 || justification.length > 3) {\n    errors.push(`justification must have 2 to 3 items (got ${justification.length})`);\n  }\n  justification.forEach((item, idx) => {\n    const path = `justification[${idx}]`;\n    if (typeof item !== 'string' || !item.trim()) {\n      errors.push(`${path} must be non-empty string`);\n      return;\n    }\n    if (item.trim().length > MAX_LENGTHS.justification) {\n      errors.push(`${path} too long (${item.trim().length} > ${MAX_LENGTHS.justification})`);\n    }\n  });\n}\n\n\n// Guardrails (hard rules)\nif (Array.isArray(days) && days.length === 7) {\n  const normalizeDay = (value) => (value || '')\n    .toLowerCase()\n    .replace(/[Ã¡Ã Ã¤]/g, 'a')\n    .replace(/[Ã©Ã¨Ã«]/g, 'e')\n    .replace(/[Ã­Ã¬Ã¯]/g, 'i')\n    .replace(/[Ã³Ã²Ã¶]/g, 'o')\n    .replace(/[ÃºÃ¹Ã¼]/g, 'u')\n    .replace(/Ã±/g, 'n');\n  const activityText = (day) => `${day.activity || ''} ${day.goal || ''} ${day.note || ''}`.toLowerCase();\n  const intensityText = (day) => (day.intensity || '').toLowerCase();\n  const containsToken = (text, tokens) => tokens.some((token) => text.includes(token));\n\n  const hardTokens = ['z4', 'z5', 'vo2', 'interval', 'umbral', 'tempo', 'threshold'];\n  const easyTokens = ['z1', 'z2', 'easy', 'recovery', 'recuper', 'suave'];\n  const restTokens = ['descanso', 'rest', 'off'];\n  const longTokens = ['tirada', 'larga', 'long'];\n  const gymTokens = ['gimnasio', 'gym', 'fuerza', 'strength'];\n\n  const isHard = (day) => containsToken(intensityText(day), hardTokens) || containsToken(activityText(day), hardTokens);\n  const isEasy = (day) => containsToken(intensityText(day), easyTokens) || containsToken(activityText(day), easyTokens);\n  const isRest = (day) => containsToken(activityText(day), restTokens) || ['-', '--', 'â€”', 'â€“'].includes((day.intensity || '').trim());\n  const normalizedDays = days.map((day) => normalizeDay(day.day));\n  const uniqueDays = new Set(normalizedDays);\n  if (uniqueDays.size !== 7) {\n    errors.push('guardrail: days must cover all weekdays exactly once');\n  }\n  const requiredDays = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'];\n  requiredDays.forEach((name) => {\n    if (!uniqueDays.has(name)) {\n      errors.push(`guardrail: missing weekday ${name}`);\n    }\n  });\n\n  const isLong = (day) => containsToken(activityText(day), longTokens);\n\n  const hardCount = days.filter(isHard).length;\n  if (hardCount > 2) {\n    errors.push(`guardrail: too many hard sessions (${hardCount} > 2)`);\n  }\n\n  for (let i = 1; i < days.length; i += 1) {\n    if (isHard(days[i]) && isHard(days[i - 1])) {\n      errors.push(`guardrail: back-to-back hard sessions (days ${i} and ${i + 1})`);\n    }\n  }\n\n  const hasRecovery = days.some((day) => isRest(day) || isEasy(day));\n  if (!hasRecovery) {\n    errors.push('guardrail: must include at least one rest or recovery day');\n  }\n\n  const longCount = days.filter(isLong).length;\n  if (longCount > 1) {\n    errors.push('guardrail: only one long run per week');\n  }\n\n  days.forEach((day, idx) => {\n    if (isLong(day) && isHard(day)) {\n      errors.push(`guardrail: long run cannot be hard intensity (day ${idx + 1})`);\n    }\n  });\n\n  const gymDays = ['martes', 'jueves', 'sabado'];\n  gymDays.forEach((name) => {\n    const day = days.find((d) => normalizeDay(d.day) === name);\n    if (day && !containsToken(activityText(day), gymTokens)) {\n      errors.push(`guardrail: ${name} should include gym/strength`);\n    }\n  });\n}\nconst valid = errors.length == 0;\n\nconst output = isObject(plan) ? JSON.parse(JSON.stringify(plan)) : {};\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\n\noutput.__valid = valid;\noutput.__errors = errors;\noutput.__attempt = attempt;\noutput.__raw = typeof raw === 'string' ? raw : JSON.stringify(raw);\nif (runContext.runId) output.__runId = runContext.runId;\nif (runContext.promptVersion) output.__promptVersion = runContext.promptVersion;\nif (runContext.modelId) output.__modelId = runContext.modelId;\n\nreturn [{ json: output }];\n"
      }
    },
    {
      "id": "7a2b301d-fd6d-4ee5-b110-49a4e452043a",
      "name": "Is WeeklyPlan valid? (attempt 0)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1360,
        448
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.__valid }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "60ab564c-0d54-46ac-857f-17eaa539b4bc",
      "name": "Fallback Trigger",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2760,
        980
      ],
      "parameters": {
        "jsCode": "throw new Error('Fallback required after max repair attempts.');"
      }
    },
    {
      "id": "1a5427aa-0afa-409b-bbda-2c0808182bbf",
      "name": "Build Run Event (success)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1268,
        328
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst plan = content.activityPlan || {};\nconst nextWeek = plan.nextWeek || {};\n\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst runId = runContext.runId || content.runId || `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\n\nconst heartRate = runContext.heartRate && typeof runContext.heartRate === 'object'\n  ? runContext.heartRate\n  : {};\nconst hrSyncLog = heartRate.hrSyncLog && typeof heartRate.hrSyncLog === 'object'\n  ? Object.assign({ run_id: runId }, heartRate.hrSyncLog)\n  : null;\nif (hrSyncLog && !Object.prototype.hasOwnProperty.call(hrSyncLog, 'zonesUpdated')) {\n  hrSyncLog.zonesUpdated = Boolean(heartRate.zonesUpdated);\n}\n\nconst createdAt = new Date().toISOString();\nconst startedAtRaw = runContext.createdAt || content.createdAt || createdAt;\nconst startedAtTs = new Date(startedAtRaw).getTime();\nconst runDurationMs = Number.isFinite(startedAtTs)\n  ? Math.max(Date.now() - startedAtTs, 0)\n  : 0;\n\nconst structuredLogRequiredFields = ['run_id', 'node_name', 'duration_ms', 'status', 'error_type'];\n\nconst buildLog = (nodeName, status, errorType = null, durationMs = runDurationMs) => ({\n  run_id: runId,\n  runId,\n  node_name: String(nodeName),\n  duration_ms: Math.max(Number(durationMs) || 0, 0),\n  status: String(status),\n  error_type: errorType == null ? null : String(errorType),\n  timestamp: new Date().toISOString(),\n});\n\nconst structuredLogs = [\n  buildLog('Prompt Builder', 'success', null, Math.round(runDurationMs * 0.2)),\n  buildLog('HR Zones Sync', 'success', null, Math.round(runDurationMs * 0.1)),\n  buildLog('Message a model', 'success', null, Math.round(runDurationMs * 0.25)),\n  buildLog('Validate WeeklyPlan', 'success', null, Math.round(runDurationMs * 0.25)),\n  buildLog('Build Telegram Message', 'success', null, Math.round(runDurationMs * 0.2)),\n];\n\nconst hasAllRequiredFields = (entry) => structuredLogRequiredFields.every((field) => Object.prototype.hasOwnProperty.call(entry, field));\nconst validStructuredLogCount = structuredLogs.filter((entry) => hasAllRequiredFields(entry)).length;\nconst structuredLogCoverageRate = structuredLogs.length\n  ? validStructuredLogCount / structuredLogs.length\n  : 0;\n\nconst rawAttempt = Number(content.__attempt);\nconst retryCount = Number.isFinite(rawAttempt) ? Math.max(Math.trunc(rawAttempt), 0) : 0;\n\nconst validationNodeNames = [\n  'Validate WeeklyPlan (attempt 0)',\n];\nconst startsWithInvalidJson = (value) => String(value || '').toLowerCase().startsWith('invalid_json');\nconst validationAttempts = validationNodeNames\n  .flatMap((nodeName) => {\n    try {\n      const nodeItems = $items(nodeName);\n      return Array.isArray(nodeItems) ? nodeItems : [];\n    } catch {\n      return [];\n    }\n  })\n  .map((item) => (item && item.json && typeof item.json === 'object' ? item.json : null))\n  .filter((payload) => payload && (!runId || !payload.__runId || String(payload.__runId) === String(runId)));\n\nconst validationAttemptCount = validationAttempts.length > 0\n  ? validationAttempts.length\n  : (retryCount + 1);\nconst invalidJsonCount = validationAttempts.length > 0\n  ? validationAttempts.filter((payload) => Array.isArray(payload.__errors) && payload.__errors.some(startsWithInvalidJson)).length\n  : errors.filter(startsWithInvalidJson).length;\nconst invalidJsonRate = validationAttemptCount > 0 ? invalidJsonCount / validationAttemptCount : 0;\n\nconst coreMetrics = {\n  successRate: 1,\n  retryCount,\n  validationAttemptCount,\n  invalidJsonCount,\n  invalidJsonRate,\n  latencyMs: runDurationMs,\n  status: 'success',\n};\n\nconst coreMetricThresholds = {\n  minSuccessRate: 0.95,\n  maxRetries: 0,\n  maxInvalidJsonRate: 0.05,\n  maxLatencyMs: 120000,\n};\n\nconst coreMetricBreaches = [];\nif (coreMetrics.successRate < coreMetricThresholds.minSuccessRate) {\n  coreMetricBreaches.push('successRate');\n}\nif (coreMetrics.retryCount > coreMetricThresholds.maxRetries) {\n  coreMetricBreaches.push('retries');\n}\nif (coreMetrics.invalidJsonRate > coreMetricThresholds.maxInvalidJsonRate) {\n  coreMetricBreaches.push('invalid_json_rate');\n}\nif (coreMetrics.latencyMs > coreMetricThresholds.maxLatencyMs) {\n  coreMetricBreaches.push('latency');\n}\n\nconst coreMetricsReport = {\n  reportVersion: '1.0',\n  generatedAt: createdAt,\n  runId,\n  metrics: coreMetrics,\n  thresholds: coreMetricThresholds,\n  breaches: coreMetricBreaches,\n};\n\nconst runEvent = {\n  runId,\n  status: 'success',\n  attempt: content.__attempt ?? null,\n  weekStart: nextWeek.weekStart || null,\n  weekEnd: nextWeek.weekEnd || null,\n  errorCount: errors.length,\n  errors,\n  runDurationMs,\n  structuredLogs,\n  structuredLogRequiredFields,\n  structuredLogCount: structuredLogs.length,\n  structuredLogCoverageRate,\n  structured_log_coverage_rate: structuredLogCoverageRate,\n  coreMetrics,\n  coreMetricThresholds,\n  coreMetricBreaches,\n  coreMetricsReport,\n  heartRateSync: hrSyncLog,\n  createdAt,\n};\n\nreturn [{\n  json: Object.assign({}, content, runEvent, { runEvent })\n}];"
      }
    },
    {
      "id": "76a0bc8d-962a-4fb4-adbd-f5968b5b83eb",
      "name": "Run Events DB (success)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1588,
        328
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_events",
        "updateKey": "runId",
        "fields": "runId, status, attempt, weekStart, weekEnd, errorCount, errors, telegramTemplateVersion, sectionCompleteness, sectionMissingCount, whyThisPlan, whyPlanMetricKeys, whyPlanHallucinationFailures, previewMode, previewChatId, riskWarningTriggerCount, riskWarningTriggers, riskWarningTriggerCounts, createdAt, runDurationMs, structuredLogs, structuredLogRequiredFields, structuredLogCount, structuredLogCoverageRate, structured_log_coverage_rate, coreMetrics, coreMetricThresholds, coreMetricBreaches, coreMetricsReport, heartRateSync",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "92307575-ea91-4bac-b23a-1860c54c24c9",
      "name": "Build Failure Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        980
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst plan = content.activityPlan || {};\nconst nextWeek = plan.nextWeek || {};\n\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst runId = runContext.runId || content.runId || `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst errors = Array.isArray(content.__errors) ? content.__errors : ['validation failed'];\n\nconst createdAt = new Date().toISOString();\nconst startedAtRaw = runContext.createdAt || content.createdAt || createdAt;\nconst startedAtTs = new Date(startedAtRaw).getTime();\nconst runDurationMs = Number.isFinite(startedAtTs)\n  ? Math.max(Date.now() - startedAtTs, 0)\n  : 0;\n\nconst normalizeErrorType = (value) => {\n  const text = String(value || '').trim();\n  if (!text) return 'unknown';\n  const firstSegment = text.split(':')[0].trim();\n  if (!firstSegment) return 'unknown';\n  return firstSegment.toLowerCase().replace(/[^a-z0-9_]+/g, '_').replace(/^_+|_+$/g, '') || 'unknown';\n};\n\nconst primaryErrorType = normalizeErrorType(errors[0]);\nconst structuredLogRequiredFields = ['run_id', 'node_name', 'duration_ms', 'status', 'error_type'];\n\nconst buildLog = (nodeName, status, errorType = primaryErrorType, durationMs = runDurationMs) => ({\n  run_id: runId,\n  runId,\n  node_name: String(nodeName),\n  duration_ms: Math.max(Number(durationMs) || 0, 0),\n  status: String(status),\n  error_type: errorType == null ? null : String(errorType),\n  timestamp: new Date().toISOString(),\n});\n\nconst structuredLogs = [\n  buildLog('Validate WeeklyPlan', 'failure', primaryErrorType, Math.round(runDurationMs * 0.5)),\n  buildLog('Build Failure Event', 'failure', primaryErrorType, Math.round(runDurationMs * 0.5)),\n];\n\nconst hasAllRequiredFields = (entry) => structuredLogRequiredFields.every((field) => Object.prototype.hasOwnProperty.call(entry, field));\nconst validStructuredLogCount = structuredLogs.filter((entry) => hasAllRequiredFields(entry)).length;\nconst structuredLogCoverageRate = structuredLogs.length\n  ? validStructuredLogCount / structuredLogs.length\n  : 0;\n\nconst rawAttempt = Number(content.__attempt);\nconst retryCount = Number.isFinite(rawAttempt) ? Math.max(Math.trunc(rawAttempt), 0) : 0;\n\nconst validationNodeNames = [\n  'Validate WeeklyPlan (attempt 0)',\n];\nconst startsWithInvalidJson = (value) => String(value || '').toLowerCase().startsWith('invalid_json');\nconst validationAttempts = validationNodeNames\n  .flatMap((nodeName) => {\n    try {\n      const nodeItems = $items(nodeName);\n      return Array.isArray(nodeItems) ? nodeItems : [];\n    } catch {\n      return [];\n    }\n  })\n  .map((item) => (item && item.json && typeof item.json === 'object' ? item.json : null))\n  .filter((payload) => payload && (!runId || !payload.__runId || String(payload.__runId) === String(runId)));\n\nconst validationAttemptCount = validationAttempts.length > 0\n  ? validationAttempts.length\n  : (retryCount + 1);\nconst invalidJsonCount = validationAttempts.length > 0\n  ? validationAttempts.filter((payload) => Array.isArray(payload.__errors) && payload.__errors.some(startsWithInvalidJson)).length\n  : errors.filter(startsWithInvalidJson).length;\nconst invalidJsonRate = validationAttemptCount > 0 ? invalidJsonCount / validationAttemptCount : 0;\n\nconst coreMetrics = {\n  successRate: 0,\n  retryCount,\n  validationAttemptCount,\n  invalidJsonCount,\n  invalidJsonRate,\n  latencyMs: runDurationMs,\n  status: 'failure',\n};\n\nconst coreMetricThresholds = {\n  minSuccessRate: 0.95,\n  maxRetries: 0,\n  maxInvalidJsonRate: 0.05,\n  maxLatencyMs: 120000,\n};\n\nconst coreMetricBreaches = [];\nif (coreMetrics.successRate < coreMetricThresholds.minSuccessRate) {\n  coreMetricBreaches.push('successRate');\n}\nif (coreMetrics.retryCount > coreMetricThresholds.maxRetries) {\n  coreMetricBreaches.push('retries');\n}\nif (coreMetrics.invalidJsonRate > coreMetricThresholds.maxInvalidJsonRate) {\n  coreMetricBreaches.push('invalid_json_rate');\n}\nif (coreMetrics.latencyMs > coreMetricThresholds.maxLatencyMs) {\n  coreMetricBreaches.push('latency');\n}\n\nconst coreMetricsReport = {\n  reportVersion: '1.0',\n  generatedAt: createdAt,\n  runId,\n  metrics: coreMetrics,\n  thresholds: coreMetricThresholds,\n  breaches: coreMetricBreaches,\n};\n\nconst runEvent = {\n  runId,\n  status: 'failure',\n  attempt: content.__attempt ?? null,\n  weekStart: nextWeek.weekStart || null,\n  weekEnd: nextWeek.weekEnd || null,\n  errorCount: errors.length,\n  errors,\n  runDurationMs,\n  structuredLogs,\n  structuredLogRequiredFields,\n  structuredLogCount: structuredLogs.length,\n  structuredLogCoverageRate,\n  structured_log_coverage_rate: structuredLogCoverageRate,\n  coreMetrics,\n  coreMetricThresholds,\n  coreMetricBreaches,\n  coreMetricsReport,\n  createdAt,\n};\n\nconst alertMessage = [\n  'âš ï¸ Running Coach workflow failed',\n  `Run: ${runId}`,\n  `Errors (${errors.length}):`,\n  ...errors.map(err => `- ${err}`)\n].join('\\n');\n\nreturn [{\n  json: Object.assign({}, content, runEvent, { runEvent, alertMessage })\n}];"
      }
    },
    {
      "id": "57d9052d-75a5-468d-a5f8-e61dbd8f7f91",
      "name": "Run Events DB (failure)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        2480,
        980
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_events",
        "updateKey": "runId",
        "fields": "runId, status, attempt, weekStart, weekEnd, errorCount, errors, createdAt, runDurationMs, structuredLogs, structuredLogRequiredFields, structuredLogCount, structuredLogCoverageRate, structured_log_coverage_rate, coreMetrics, coreMetricThresholds, coreMetricBreaches, coreMetricsReport",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "e0eb79f9-5da4-43bb-a51f-230f787624fd",
      "name": "Send Failure Alert",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        2720,
        980
      ],
      "parameters": {
        "chatId": "730354404",
        "text": "={{ $json.alertMessage }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "webhookId": "ae55f720-070b-42e2-b07e-f202cb99ced4",
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "id": "2d8f2e3c-1c6b-4b11-8b6f-6d6a1fcb55a2",
      "name": "Plan Snapshots DB",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1388,
        328
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "plan_snapshots",
        "updateKey": "runId",
        "fields": "runId, attempt, weekStart, weekEnd, schema_version, activityPlan, justification, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "948d6cd7-5470-4427-8cce-914769862399",
      "name": "Run Artifacts DB (inputs)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1088,
        640
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_artifacts",
        "updateKey": "runId",
        "fields": "runId, promptVersion, modelId, prompt, metrics, history, activities, wellness, createdAt, heartRate",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "3912d34c-0bb2-4073-b920-2a9ce7009bc1",
      "name": "Build Run Artifact (outputs)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        128
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\n\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\nconst outputValidated = content.activityPlan ? {\n  schema_version: content.schema_version,\n  activityPlan: content.activityPlan,\n  justification: content.justification\n} : null;\n\nconst structuredLogs = Array.isArray(content.structuredLogs)\n  ? content.structuredLogs\n  : [];\nconst structuredLogCoverageRate = typeof content.structuredLogCoverageRate === 'number'\n  ? content.structuredLogCoverageRate\n  : (typeof content.structured_log_coverage_rate === 'number' ? content.structured_log_coverage_rate : null);\nconst structuredLogCount = Number.isInteger(content.structuredLogCount)\n  ? content.structuredLogCount\n  : structuredLogs.length;\n\nconst fallbackAttempt = Number(content.__attempt);\nconst retryCountFallback = Number.isFinite(fallbackAttempt) ? Math.max(Math.trunc(fallbackAttempt), 0) : 0;\n\nconst validationNodeNames = [\n  'Validate WeeklyPlan (attempt 0)',\n];\nconst startsWithInvalidJson = (value) => String(value || '').toLowerCase().startsWith('invalid_json');\nconst validationAttempts = validationNodeNames\n  .flatMap((nodeName) => {\n    try {\n      const nodeItems = $items(nodeName);\n      return Array.isArray(nodeItems) ? nodeItems : [];\n    } catch {\n      return [];\n    }\n  })\n  .map((item) => (item && item.json && typeof item.json === 'object' ? item.json : null))\n  .filter((payload) => payload && (!runContext.runId || !payload.__runId || String(payload.__runId) === String(runContext.runId)));\n\nconst validationAttemptCountFallback = validationAttempts.length > 0\n  ? validationAttempts.length\n  : (retryCountFallback + 1);\nconst invalidJsonCountFallback = validationAttempts.length > 0\n  ? validationAttempts.filter((payload) => Array.isArray(payload.__errors) && payload.__errors.some(startsWithInvalidJson)).length\n  : errors.filter(startsWithInvalidJson).length;\nconst invalidJsonRateFallback = validationAttemptCountFallback > 0 ? invalidJsonCountFallback / validationAttemptCountFallback : 0;\n\nconst coreMetrics = (content.coreMetrics && typeof content.coreMetrics === 'object')\n  ? content.coreMetrics\n  : {\n      successRate: content.status === 'failure' ? 0 : 1,\n      retryCount: retryCountFallback,\n      validationAttemptCount: validationAttemptCountFallback,\n      invalidJsonCount: invalidJsonCountFallback,\n      invalidJsonRate: invalidJsonRateFallback,\n      latencyMs: Number.isFinite(content.runDurationMs) ? content.runDurationMs : null,\n      status: content.status || (content.__valid ? 'success' : 'failure'),\n    };\n\nconst coreMetricThresholds = (content.coreMetricThresholds && typeof content.coreMetricThresholds === 'object')\n  ? content.coreMetricThresholds\n  : null;\nconst coreMetricBreaches = Array.isArray(content.coreMetricBreaches)\n  ? content.coreMetricBreaches\n  : [];\nconst coreMetricsReport = (content.coreMetricsReport && typeof content.coreMetricsReport === 'object')\n  ? content.coreMetricsReport\n  : null;\n\nreturn [{\n  json: {\n    runId: runContext.runId || content.runId,\n    promptVersion: runContext.promptVersion || null,\n    modelId: runContext.modelId || null,\n    status: content.status || (content.__valid ? 'success' : 'failure'),\n    attempt: content.__attempt ?? null,\n    outputValidated,\n    outputRaw: content.__raw ?? null,\n    errors,\n    errorCount: errors.length,\n    runDurationMs: Number.isFinite(content.runDurationMs) ? content.runDurationMs : null,\n    structuredLogs,\n    structuredLogCount,\n    structuredLogCoverageRate,\n    structured_log_coverage_rate: structuredLogCoverageRate,\n    coreMetrics,\n    coreMetricThresholds,\n    coreMetricBreaches,\n    coreMetricsReport,\n    updatedAt: new Date().toISOString()\n  }\n}];"
      }
    },
    {
      "id": "9e28f9fd-c2ae-4df0-9557-1808cc338b53",
      "name": "Run Artifacts DB (outputs)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1712,
        128
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_artifacts",
        "updateKey": "runId",
        "fields": "runId, promptVersion, modelId, status, attempt, outputValidated, outputRaw, errors, errorCount, updatedAt, runDurationMs, structuredLogs, structuredLogCount, structuredLogCoverageRate, structured_log_coverage_rate, coreMetrics, coreMetricThresholds, coreMetricBreaches, coreMetricsReport",
        "upsert": true,
        "options": {
          "dateFields": "updatedAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "e2034a41-23b2-4eff-aa0c-3baad42ad4b3",
      "name": "Daily Reminder Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1600,
        940
      ],
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 * * * * *"
            }
          ]
        }
      }
    },
    {
      "id": "4d025492-9aeb-4e68-b607-8bc0f91eec5a",
      "name": "Build Reminder Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1360,
        940
      ],
      "parameters": {
        "jsCode": "const DEFAULT_CHAT_ID = '730354404';\nconst DEFAULT_REMINDER_TIME = '08:00';\nconst DEFAULT_REMINDER_TIMEZONE = 'Europe/Madrid';\n\nconst getVar = (key) => {\n  if (typeof $vars !== 'undefined' && $vars[key] != null) {\n    return String($vars[key]);\n  }\n  if (typeof $env !== 'undefined' && $env[key] != null) {\n    return String($env[key]);\n  }\n  if (typeof process !== 'undefined' && process.env && process.env[key] != null) {\n    return String(process.env[key]);\n  }\n  return '';\n};\n\nconst isTruthy = (value) => ['1', 'true', 'yes', 'on'].includes(String(value).toLowerCase());\n\nconst isValidTime = (value) => /^([01]\\d|2[0-3]):([0-5]\\d)$/.test(value);\n\nconst getLocalNow = (timeZone) => {\n  const now = new Date();\n  const formatter = new Intl.DateTimeFormat('en-CA', {\n    timeZone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: false,\n    weekday: 'long',\n  });\n\n  const parts = formatter.formatToParts(now).reduce((acc, part) => {\n    if (part.type !== 'literal') {\n      acc[part.type] = part.value;\n    }\n    return acc;\n  }, {});\n\n  return {\n    iso: now.toISOString(),\n    date: `${parts.year}-${parts.month}-${parts.day}`,\n    time: `${parts.hour}:${parts.minute}`,\n    weekday: parts.weekday || '',\n  };\n};\n\nconst previewEnabled = isTruthy(getVar('RC_TELEGRAM_PREVIEW_MODE'));\nconst previewChatRaw = getVar('RC_TELEGRAM_PREVIEW_CHAT_ID').trim();\nif (previewEnabled && !previewChatRaw) {\n  throw new Error('RC_TELEGRAM_PREVIEW_CHAT_ID is required when RC_TELEGRAM_PREVIEW_MODE is enabled.');\n}\n\nconst reminderEnabled = isTruthy(getVar('RC_REMINDER_ENABLED'));\nif (!reminderEnabled) {\n  return [];\n}\n\nconst reminderTime = (getVar('RC_REMINDER_TIME').trim() || DEFAULT_REMINDER_TIME);\nif (!isValidTime(reminderTime)) {\n  throw new Error('RC_REMINDER_TIME must use HH:MM (24-hour) format.');\n}\n\nconst reminderTimezone = getVar('RC_REMINDER_TIMEZONE').trim() || DEFAULT_REMINDER_TIMEZONE;\nlet localNow;\ntry {\n  localNow = getLocalNow(reminderTimezone);\n} catch (error) {\n  throw new Error(`Invalid reminder timezone: ${reminderTimezone}`);\n}\n\nconst forceSend = isTruthy(getVar('RC_REMINDER_FORCE_SEND'));\nif (!forceSend && localNow.time !== reminderTime) {\n  return [];\n}\n\nconst targetChatId = previewEnabled ? previewChatRaw : DEFAULT_CHAT_ID;\nconst runId = `reminder-${localNow.date}-${Math.random().toString(36).slice(2, 10)}`;\n\nreturn [{\n  json: {\n    runId,\n    status: 'reminder',\n    createdAt: localNow.iso,\n    chatId: targetChatId,\n    previewMode: previewEnabled,\n    previewChatId: targetChatId,\n    reminderEnabled,\n    reminderDate: localNow.date,\n    reminderWeekday: localNow.weekday,\n    reminderTime,\n    reminderTimezone,\n    reminderForceSend: forceSend,\n    reminderKey: `${targetChatId}:${localNow.date}`,\n    reminderOptInUsersCount: 1,\n    reminder_opt_in_users_count: 1,\n  }\n}];"
      }
    },
    {
      "id": "45ff64d9-b51c-41cc-9ade-fa060185d1c8",
      "name": "Read Latest Plan Snapshot",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -1120,
        940
      ],
      "alwaysOutputData": true,
      "parameters": {
        "collection": "plan_snapshots",
        "options": {
          "sort": "{ \"createdAt\": -1 }"
        },
        "query": "={\n  \"activityPlan\": {\n    \"$exists\": true\n  }\n}\n"
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "376db49c-8b14-46e5-883f-04e1492745f2",
      "name": "Read Reminder Sends Today",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -880,
        940
      ],
      "alwaysOutputData": true,
      "parameters": {
        "collection": "reminder_events",
        "options": {
          "sort": "{ \"createdAt\": -1 }"
        },
        "query": "={\n  \"chatId\": \"{{ $items('Build Reminder Context')[0].json.chatId }}\",\n  \"reminderDate\": \"{{ $items('Build Reminder Context')[0].json.reminderDate }}\",\n  \"deliveryStatus\": \"sent\"\n}\n"
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "9c968705-5e90-4782-abaa-c3ecc83f6e50",
      "name": "Build Reminder Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -640,
        940
      ],
      "parameters": {
        "jsCode": "const contextItems = $items('Build Reminder Context');\nif (!contextItems.length) {\n  return [];\n}\n\nconst context = contextItems[0].json || {};\n\nconst snapshotDocs = $items('Read Latest Plan Snapshot')\n  .map((item) => item.json || {})\n  .filter((doc) => doc && Object.keys(doc).length > 0);\n\nconst sentDocs = items\n  .map((item) => item.json || {})\n  .filter((doc) => doc && Object.keys(doc).length > 0);\n\nconst planSnapshot = snapshotDocs[0] || {};\nconst activityPlan = (planSnapshot.activityPlan && typeof planSnapshot.activityPlan === 'object')\n  ? planSnapshot.activityPlan\n  : {};\nconst days = Array.isArray(activityPlan.days) ? activityPlan.days : [];\n\nconst normalizeDay = (value) => {\n  const text = String(value || '').trim().toLowerCase();\n  if (!text) return '';\n  const map = {\n    monday: 'monday',\n    lunes: 'monday',\n    tuesday: 'tuesday',\n    martes: 'tuesday',\n    wednesday: 'wednesday',\n    miercoles: 'wednesday',\n    'miÃ©rcoles': 'wednesday',\n    thursday: 'thursday',\n    jueves: 'thursday',\n    friday: 'friday',\n    viernes: 'friday',\n    saturday: 'saturday',\n    sabado: 'saturday',\n    'sÃ¡bado': 'saturday',\n    sunday: 'sunday',\n    domingo: 'sunday',\n  };\n  return map[text] || text;\n};\n\nconst todayDayKey = normalizeDay(context.reminderWeekday);\nlet session = days.find((day) => String(day.date || '') === String(context.reminderDate || '')) || null;\nif (!session && todayDayKey) {\n  session = days.find((day) => normalizeDay(day.day) === todayDayKey) || null;\n}\n\nconst alreadySent = sentDocs.length > 0;\nlet shouldSend = false;\nlet deliveryStatus = 'skipped';\nlet deliveryReason = 'unknown';\n\nif (!Array.isArray(days) || days.length === 0) {\n  deliveryStatus = 'skipped_no_plan';\n  deliveryReason = 'missing_plan_days';\n} else if (!session) {\n  deliveryStatus = 'skipped_no_session';\n  deliveryReason = 'missing_daily_session';\n} else if (alreadySent) {\n  deliveryStatus = 'skipped_already_sent';\n  deliveryReason = 'already_sent_today';\n} else {\n  shouldSend = true;\n  deliveryStatus = 'pending';\n  deliveryReason = 'ready_to_send';\n}\n\nconst esc = (value) => String(value || '')\n  .replace(/&/g, '&amp;')\n  .replace(/</g, '&lt;')\n  .replace(/>/g, '&gt;');\n\nconst lines = [\n  context.previewMode ? 'ğŸ§ª <b>Preview mode</b>' : null,\n  `â° <b>Training reminder</b> (${esc(context.reminderDate)})`,\n];\n\nif (session) {\n  lines.push(`ğŸƒ <b>${esc(session.activity || 'Session')}</b>`);\n  if (session.distance_time) {\n    lines.push(`Duration: ${esc(session.distance_time)}`);\n  }\n  if (session.intensity && session.intensity !== '-') {\n    lines.push(`Intensity: ${esc(session.intensity)}`);\n  }\n  if (session.goal) {\n    lines.push(`Goal: ${esc(session.goal)}`);\n  }\n  if (session.note) {\n    lines.push(`Note: ${esc(session.note)}`);\n  }\n} else {\n  lines.push('No planned session found for today.');\n}\n\nif (!shouldSend && deliveryStatus === 'skipped_already_sent') {\n  lines.push('Reminder already sent today.');\n}\n\nreturn [{\n  json: {\n    runId: context.runId,\n    status: context.status,\n    createdAt: context.createdAt,\n    chatId: context.chatId,\n    previewMode: context.previewMode,\n    previewChatId: context.previewChatId,\n    reminderDate: context.reminderDate,\n    reminderWeekday: context.reminderWeekday,\n    reminderTime: context.reminderTime,\n    reminderTimezone: context.reminderTimezone,\n    reminderForceSend: context.reminderForceSend,\n    reminderKey: context.reminderKey,\n    reminderEnabled: context.reminderEnabled,\n    reminderOptInUsersCount: context.reminderOptInUsersCount,\n    reminder_opt_in_users_count: context.reminder_opt_in_users_count,\n    reminderSentCount: shouldSend ? 1 : 0,\n    reminder_sent_count: shouldSend ? 1 : 0,\n    shouldSend,\n    deliveryStatus,\n    deliveryReason,\n    session,\n    text: lines.filter(Boolean).join('\\n'),\n  }\n}];"
      }
    },
    {
      "id": "63401a52-028d-4dfc-84de-dc996b9ca79b",
      "name": "Should Send Reminder?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -400,
        940
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.shouldSend }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "fb5f6473-9774-49f5-96cc-1e104ec9d59e",
      "name": "Send Reminder Message",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        -160,
        820
      ],
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "id": "b409f1bb-0422-412d-a326-815ff730e116",
      "name": "Build Reminder Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        940
      ],
      "parameters": {
        "jsCode": "const baseItems = $items('Build Reminder Message');\nif (!baseItems.length) {\n  return [];\n}\n\nconst base = baseItems[0].json || {};\nconst incoming = (items[0] && items[0].json && typeof items[0].json === 'object') ? items[0].json : {};\nconst incomingHasPayload = Object.prototype.hasOwnProperty.call(incoming, 'shouldSend');\n\nlet deliveryStatus = base.deliveryStatus || 'skipped';\nlet deliveryReason = base.deliveryReason || null;\nlet reminderSentCount = base.shouldSend ? 1 : 0;\nlet telegramMessageId = null;\nlet telegramResponse = null;\n\nif (incomingHasPayload) {\n  deliveryStatus = incoming.deliveryStatus || deliveryStatus;\n  deliveryReason = incoming.deliveryReason || deliveryReason;\n  reminderSentCount = incoming.shouldSend ? 1 : 0;\n} else if (base.shouldSend) {\n  deliveryStatus = 'sent';\n  deliveryReason = 'sent';\n  reminderSentCount = 1;\n  telegramResponse = incoming;\n  if (incoming && incoming.result && incoming.result.message_id != null) {\n    telegramMessageId = incoming.result.message_id;\n  }\n}\n\nconst createdAt = new Date().toISOString();\n\nreturn [{\n  json: {\n    runId: base.runId || `reminder-${Math.random().toString(36).slice(2, 10)}`,\n    status: 'reminder',\n    chatId: base.chatId || null,\n    previewMode: Boolean(base.previewMode),\n    previewChatId: base.previewChatId || null,\n    reminderDate: base.reminderDate || null,\n    reminderWeekday: base.reminderWeekday || null,\n    reminderTime: base.reminderTime || null,\n    reminderTimezone: base.reminderTimezone || null,\n    reminderForceSend: Boolean(base.reminderForceSend),\n    reminderKey: base.reminderKey || null,\n    reminderEnabled: Boolean(base.reminderEnabled),\n    deliveryStatus,\n    deliveryReason,\n    session: base.session || null,\n    text: base.text || null,\n    telegramMessageId,\n    telegramResponse,\n    reminderSentCount,\n    reminder_sent_count: reminderSentCount,\n    reminderOptInUsersCount: base.reminderOptInUsersCount === 1 ? 1 : 0,\n    reminder_opt_in_users_count: base.reminder_opt_in_users_count === 1 ? 1 : 0,\n    createdAt,\n  }\n}];"
      }
    },
    {
      "id": "768a9b31-7943-4301-84d7-553f780e4ad5",
      "name": "Reminder Events DB",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        320,
        860
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "reminder_events",
        "updateKey": "runId",
        "fields": "runId, status, chatId, previewMode, previewChatId, reminderDate, reminderWeekday, reminderTime, reminderTimezone, reminderForceSend, reminderKey, reminderEnabled, deliveryStatus, deliveryReason, session, text, telegramMessageId, telegramResponse, reminderSentCount, reminder_sent_count, reminderOptInUsersCount, reminder_opt_in_users_count, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "955198df-67a1-48dd-a9f4-17de2f2f49b3",
      "name": "Run Events DB (reminder)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        320,
        1020
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_events",
        "updateKey": "runId",
        "fields": "runId, status, chatId, previewMode, previewChatId, reminderDate, reminderWeekday, reminderTime, reminderTimezone, reminderForceSend, reminderKey, reminderEnabled, deliveryStatus, deliveryReason, session, reminderSentCount, reminder_sent_count, reminderOptInUsersCount, reminder_opt_in_users_count, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "collection": "hr_zone_profiles",
        "options": {
          "sort": "{ \"updatedAt\": -1 }",
          "limit": 1
        },
        "query": "={\n  \"athleteId\": 372001\n}\n"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -960,
        736
      ],
      "id": "573767c5-0d9a-4430-b1be-1d8169a9b621",
      "name": "Read Last HR Profile",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "url": "https://intervals.icu/api/v1/athlete/i372001",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.INTERVALS_AUTH_HEADER || $vars.INTERVALS_AUTH_HEADER }}"
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          },
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -736,
        736
      ],
      "id": "c178495c-9a48-480d-9f5b-6c96be636bbd",
      "name": "GET HR Parameters",
      "onError": "continueRegularOutput",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const ATHLETE_ID = 372001;\nconst ZONE_BANDS = [\n  ['z1', 0.50, 0.59],\n  ['z2', 0.60, 0.69],\n  ['z3', 0.70, 0.79],\n  ['z4', 0.80, 0.89],\n  ['z5', 0.90, 1.00],\n];\n\nconst isObject = (value) => value !== null && typeof value === 'object' && !Array.isArray(value);\n\nconst toNumber = (value) => {\n  if (value === null || value === undefined || value === '') return null;\n  const parsed = Number(value);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst getNodeItemsSafe = (nodeName) => {\n  try {\n    const nodeItems = $items(nodeName);\n    return Array.isArray(nodeItems) ? nodeItems : [];\n  } catch {\n    return [];\n  }\n};\n\nconst getByPath = (obj, path) => {\n  if (!isObject(obj)) return undefined;\n  const parts = path.split('.');\n  let cursor = obj;\n  for (const part of parts) {\n    if (!isObject(cursor) || !Object.prototype.hasOwnProperty.call(cursor, part)) {\n      return undefined;\n    }\n    cursor = cursor[part];\n  }\n  return cursor;\n};\n\nconst pickNumber = (obj, paths) => {\n  for (const path of paths) {\n    const value = toNumber(getByPath(obj, path));\n    if (value !== null) return value;\n  }\n  return null;\n};\n\nconst pickString = (obj, paths) => {\n  for (const path of paths) {\n    const value = getByPath(obj, path);\n    if (typeof value === 'string' && value.trim()) {\n      return value.trim();\n    }\n  }\n  return null;\n};\n\nconst toZoneKey = (value) => {\n  const text = String(value || '').toLowerCase().trim();\n  if (!text) return null;\n  const compact = text.replace(/[^a-z0-9]/g, '');\n  if (compact === 'z1' || compact === 'zone1' || compact === 'hrz1') return 'z1';\n  if (compact === 'z2' || compact === 'zone2' || compact === 'hrz2') return 'z2';\n  if (compact === 'z3' || compact === 'zone3' || compact === 'hrz3') return 'z3';\n  if (compact === 'z4' || compact === 'zone4' || compact === 'hrz4') return 'z4';\n  if (compact === 'z5' || compact === 'zone5' || compact === 'hrz5') return 'z5';\n  return null;\n};\n\nconst normalizeZones = (raw) => {\n  if (!raw) return null;\n  const normalized = {};\n\n  if (Array.isArray(raw)) {\n    for (const zone of raw) {\n      if (!isObject(zone)) continue;\n      const key = toZoneKey(zone.zone || zone.name || zone.label || zone.id);\n      if (!key) continue;\n      const min = toNumber(zone.min ?? zone.low ?? zone.from ?? zone.start);\n      const max = toNumber(zone.max ?? zone.high ?? zone.to ?? zone.end);\n      if (min === null || max === null) continue;\n      normalized[key] = { min: Math.round(min), max: Math.round(max) };\n    }\n  }\n\n  if (isObject(raw)) {\n    for (const key of ['z1', 'z2', 'z3', 'z4', 'z5']) {\n      const zone = raw[key] || raw[key.toUpperCase()] || raw[`zone${key.slice(1)}`] || raw[`Zone${key.slice(1)}`];\n      if (!isObject(zone)) continue;\n      const min = toNumber(zone.min ?? zone.low ?? zone.from ?? zone.start);\n      const max = toNumber(zone.max ?? zone.high ?? zone.to ?? zone.end);\n      if (min === null || max === null) continue;\n      normalized[key] = { min: Math.round(min), max: Math.round(max) };\n    }\n  }\n\n  const keys = ['z1', 'z2', 'z3', 'z4', 'z5'];\n  if (!keys.every((key) => isObject(normalized[key]) && Number.isFinite(normalized[key].min) && Number.isFinite(normalized[key].max))) {\n    return null;\n  }\n\n  let lastMax = -Infinity;\n  for (const key of keys) {\n    const zone = normalized[key];\n    if (zone.min > zone.max) return null;\n    if (zone.min < lastMax) return null;\n    lastMax = zone.max;\n  }\n\n  return normalized;\n};\n\nconst computeHrrZones = (hrMax, hrRest) => {\n  const reserve = hrMax - hrRest;\n  const zones = {};\n  for (const [key, lowPct, highPct] of ZONE_BANDS) {\n    zones[key] = {\n      min: Math.round(hrRest + reserve * lowPct),\n      max: Math.round(hrRest + reserve * highPct),\n    };\n  }\n  return zones;\n};\n\nconst eq = (a, b) => (a === null && b === null) || a === b;\nconst fmt = (value) => (value === null ? '-' : String(Math.round(value)));\n\nconst incomingPayloads = items\n  .map((item) => (item && item.json && isObject(item.json) ? item.json : {}))\n  .filter((payload) => Object.keys(payload).length > 0);\n\nconst mergedPayload = {};\nfor (const payload of incomingPayloads) {\n  for (const [key, value] of Object.entries(payload)) {\n    if (Array.isArray(value)) {\n      if (!Array.isArray(mergedPayload[key]) || value.length > mergedPayload[key].length) {\n        mergedPayload[key] = value;\n      }\n      continue;\n    }\n    if (isObject(value)) {\n      if (!isObject(mergedPayload[key])) {\n        mergedPayload[key] = {};\n      }\n      for (const [subKey, subValue] of Object.entries(value)) {\n        if (!(subKey in mergedPayload[key]) || mergedPayload[key][subKey] === null || mergedPayload[key][subKey] === '') {\n          mergedPayload[key][subKey] = subValue;\n        }\n      }\n      continue;\n    }\n    if (!(key in mergedPayload) || mergedPayload[key] === null || mergedPayload[key] === '') {\n      mergedPayload[key] = value;\n    }\n  }\n}\n\nconst previousPayload = getNodeItemsSafe('Read Last HR Profile')\n  .map((item) => (item && item.json && isObject(item.json) ? item.json : {}))\n  .find((payload) => isObject(payload) && Object.keys(payload).length > 0) || {};\n\nconst previous = {\n  hrMax: toNumber(previousPayload.hrMax),\n  hrRest: toNumber(previousPayload.hrRest),\n  lthr: toNumber(previousPayload.lthr),\n  zoneMethod: typeof previousPayload.zoneMethod === 'string' ? previousPayload.zoneMethod : null,\n  computedZones: normalizeZones(previousPayload.computedZones),\n};\n\nconst sourceNodePayloads = getNodeItemsSafe('GET HR Parameters')\n  .map((item) => (item && item.json && isObject(item.json) ? item.json : {}))\n  .filter((payload) => Object.keys(payload).length > 0);\n\nconst sourcePayloads = [...sourceNodePayloads, ...incomingPayloads];\n\nconst pickNumberFromSources = (paths) => {\n  for (const payload of sourcePayloads) {\n    const value = pickNumber(payload, paths);\n    if (value !== null) return value;\n  }\n  return null;\n};\n\nconst pickStringFromSources = (paths) => {\n  for (const payload of sourcePayloads) {\n    const value = pickString(payload, paths);\n    if (value) return value;\n  }\n  return null;\n};\n\nconst pickZonesFromSources = () => {\n  const zonePaths = [\n    'computedZones',\n    'zones',\n    'heartRateZones',\n    'hrZones',\n    'settings.heartRateZones',\n    'athlete.heartRateZones',\n    'heart_rate.zones',\n  ];\n\n  for (const payload of sourcePayloads) {\n    for (const path of zonePaths) {\n      const candidate = normalizeZones(getByPath(payload, path));\n      if (candidate) return candidate;\n    }\n  }\n\n  return null;\n};\n\nconst sourceHrMax = pickNumberFromSources([\n  'hrMax',\n  'maxHr',\n  'maxHR',\n  'maxHeartRate',\n  'max_heartrate',\n  'athlete.hrMax',\n  'athlete.maxHr',\n  'profile.hrMax',\n  'profile.maxHr',\n  'settings.hrMax',\n  'settings.maxHr',\n]);\nconst sourceHrRest = pickNumberFromSources([\n  'hrRest',\n  'restHr',\n  'restingHr',\n  'restingHR',\n  'athlete.hrRest',\n  'athlete.restHr',\n  'profile.hrRest',\n  'profile.restHr',\n  'settings.hrRest',\n  'settings.restHr',\n]);\nconst sourceLthr = pickNumberFromSources([\n  'lthr',\n  'ltHr',\n  'thresholdHr',\n  'lactateThresholdHr',\n  'athlete.lthr',\n  'profile.lthr',\n  'settings.lthr',\n]);\n\nconst sourceZones = pickZonesFromSources();\nconst sourceZoneMethod = pickStringFromSources(['zoneMethod', 'zone_method', 'settings.zoneMethod']) || (sourceZones ? 'intervals' : null);\n\nconst candidateHrMax = sourceHrMax !== null ? sourceHrMax : previous.hrMax;\nconst candidateHrRest = sourceHrRest !== null ? sourceHrRest : previous.hrRest;\nconst candidateLthr = sourceLthr !== null ? sourceLthr : previous.lthr;\n\nconst hasSourceHrSignal = sourceHrMax !== null || sourceHrRest !== null || sourceLthr !== null;\nconst hasSourceZones = sourceZones !== null;\nconst shouldAttemptUpdate = hasSourceHrSignal || hasSourceZones;\n\nconst validationErrors = [];\nif (candidateHrMax !== null && candidateHrRest !== null && candidateHrRest >= candidateHrMax) {\n  validationErrors.push('invalid_hr_rest_gte_hr_max');\n}\nif (candidateHrMax !== null && candidateLthr !== null && candidateHrMax < candidateLthr) {\n  validationErrors.push('invalid_hr_max_lt_lthr');\n}\n\nconst canComputeHrr = candidateHrMax !== null\n  && candidateHrRest !== null\n  && candidateHrRest < candidateHrMax;\n\nlet nextHrMax = previous.hrMax;\nlet nextHrRest = previous.hrRest;\nlet nextLthr = previous.lthr;\nlet nextZoneMethod = previous.zoneMethod;\nlet nextComputedZones = previous.computedZones;\nlet updateApplied = false;\n\nif (validationErrors.length === 0 && shouldAttemptUpdate) {\n  if (hasSourceZones) {\n    nextHrMax = candidateHrMax;\n    nextHrRest = candidateHrRest;\n    nextLthr = candidateLthr;\n    nextZoneMethod = sourceZoneMethod || previous.zoneMethod || 'intervals';\n    nextComputedZones = sourceZones;\n    updateApplied = true;\n  } else if (sourceHrMax !== null || sourceHrRest !== null) {\n    if (canComputeHrr) {\n      nextHrMax = candidateHrMax;\n      nextHrRest = candidateHrRest;\n      nextLthr = candidateLthr;\n      nextZoneMethod = '%HRR';\n      nextComputedZones = computeHrrZones(candidateHrMax, candidateHrRest);\n      updateApplied = true;\n    }\n  } else if (sourceLthr !== null && !eq(previous.lthr, candidateLthr)) {\n    // Allow threshold-only updates without recomputing zones.\n    nextLthr = candidateLthr;\n    updateApplied = true;\n  }\n}\n\nconst hasValidProfile = Number.isFinite(nextHrMax)\n  && Number.isFinite(nextHrRest)\n  && nextHrRest < nextHrMax\n  && (nextLthr === null || (Number.isFinite(nextLthr) && nextHrMax >= nextLthr))\n  && normalizeZones(nextComputedZones) !== null;\n\nconst zonesUpdated = hasValidProfile && (\n  !eq(previous.hrMax, nextHrMax)\n  || !eq(previous.hrRest, nextHrRest)\n  || !eq(previous.lthr, nextLthr)\n);\n\nconst persistProfile = updateApplied && hasValidProfile;\nconst nowIso = new Date().toISOString();\n\nconst incomingRunId = typeof mergedPayload.runId === 'string' && mergedPayload.runId.trim()\n  ? mergedPayload.runId.trim()\n  : null;\nconst runId = incomingRunId || `${nowIso}-${Math.random().toString(36).slice(2, 8)}`;\n\nconst zoneUpdateNotice = zonesUpdated\n  ? `ğŸ› ï¸ Zonas actualizadas: Max ${fmt(previous.hrMax)}â†’${fmt(nextHrMax)} Â· Reposo ${fmt(previous.hrRest)}â†’${fmt(nextHrRest)} Â· Umbral ${fmt(previous.lthr)}â†’${fmt(nextLthr)}`\n  : null;\n\nconst hrSyncLog = {\n  run_id: runId,\n  hrMax_old: previous.hrMax,\n  hrMax_new: nextHrMax,\n  hrRest_old: previous.hrRest,\n  hrRest_new: nextHrRest,\n  lthr_old: previous.lthr,\n  lthr_new: nextLthr,\n  zonesUpdated,\n  updatedAt: nowIso,\n};\n\nconst heartRateSync = {\n  athleteId: ATHLETE_ID,\n  hrMax: nextHrMax,\n  hrRest: nextHrRest,\n  lthr: nextLthr,\n  zoneMethod: nextZoneMethod,\n  computedZones: nextComputedZones,\n  updatedAt: nowIso,\n  zonesUpdated,\n  zoneUpdateNotice,\n  persistProfile,\n  validationErrors,\n  hrSyncLog,\n};\n\nreturn [{\n  json: Object.assign({}, mergedPayload, {\n    runId,\n    heartRateSync,\n    heartRate: heartRateSync,\n    hrSyncLog,\n    athleteId: ATHLETE_ID,\n    hrMax: nextHrMax,\n    hrRest: nextHrRest,\n    lthr: nextLthr,\n    zoneMethod: nextZoneMethod,\n    computedZones: nextComputedZones,\n    updatedAt: nowIso,\n    zonesUpdated,\n    zoneUpdateNotice,\n    persistProfile,\n  }),\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        448
      ],
      "id": "8f3b291f-b4a7-40cf-8df4-9dd3499a9f90",
      "name": "Sync HR Zones"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.persistProfile }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1312,
        352
      ],
      "id": "78892172-b10b-4c80-847d-548f4f268b65",
      "name": "Should Persist HR Profile?"
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "hr_zone_profiles",
        "updateKey": "athleteId",
        "fields": "athleteId, hrMax, hrRest, lthr, zoneMethod, computedZones, updatedAt, zonesUpdated",
        "upsert": true,
        "options": {
          "dateFields": "updatedAt"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1536,
        320
      ],
      "id": "3b719c33-f610-4da8-bf1d-bd661bda183b",
      "name": "HR Profiles DB",
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        864,
        448
      ],
      "id": "b200014f-339b-45d2-8dc4-7cf10b38cbe4",
      "name": "Merge Request + HR Params"
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking â€˜Execute workflowâ€™": {
      "main": [
        [
          {
            "node": "GET Activities",
            "type": "main",
            "index": 0
          },
          {
            "node": "GET Wellness",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Last HR Profile",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Map Activities + Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Activities": {
      "main": [
        [
          {
            "node": "Activities DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Wellness": {
      "main": [
        [
          {
            "node": "Wellness DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET Wellness": {
      "main": [
        [
          {
            "node": "Shape Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET Activities": {
      "main": [
        [
          {
            "node": "Shape Activities",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Weekly Metrics": {
      "main": [
        [
          {
            "node": "Weekly Metrics DB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Previous Weeks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Previous Weeks": {
      "main": [
        [
          {
            "node": "Merge Current & History",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Current & History": {
      "main": [
        [
          {
            "node": "Map Current + History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Current + History": {
      "main": [
        [
          {
            "node": "Merge Request Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Weekly Metrics DB": {
      "main": [
        [
          {
            "node": "Merge Current & History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Activities + Wellness": {
      "main": [
        [
          {
            "node": "Shape Weekly Metrics",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Request Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Request Data": {
      "main": [
        [
          {
            "node": "Merge Request + HR Params",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prompt Builder": {
      "main": [
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          },
          {
            "node": "Run Artifacts DB (inputs)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message a model": {
      "main": [
        [
          {
            "node": "Validate WeeklyPlan (attempt 0)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Telegram Message": {
      "main": [
        [
          {
            "node": "Send a text message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Run Events DB (success)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wellness DB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Activities DB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "GET Activities",
            "type": "main",
            "index": 0
          },
          {
            "node": "GET Wellness",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Last HR Profile",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate WeeklyPlan (attempt 0)": {
      "main": [
        [
          {
            "node": "Is WeeklyPlan valid? (attempt 0)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is WeeklyPlan valid? (attempt 0)": {
      "main": [
        [
          {
            "node": "Build Run Event (success)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Failure Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Run Event (success)": {
      "main": [
        [
          {
            "node": "Plan Snapshots DB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Run Artifact (outputs)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Telegram Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Failure Event": {
      "main": [
        [
          {
            "node": "Run Events DB (failure)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Run Artifact (outputs)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Events DB (failure)": {
      "main": [
        [
          {
            "node": "Send Failure Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Failure Alert": {
      "main": [
        [
          {
            "node": "Fallback Trigger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Run Artifact (outputs)": {
      "main": [
        [
          {
            "node": "Run Artifacts DB (outputs)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Daily Reminder Trigger": {
      "main": [
        [
          {
            "node": "Build Reminder Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Reminder Context": {
      "main": [
        [
          {
            "node": "Read Latest Plan Snapshot",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Latest Plan Snapshot": {
      "main": [
        [
          {
            "node": "Read Reminder Sends Today",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Reminder Sends Today": {
      "main": [
        [
          {
            "node": "Build Reminder Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Reminder Message": {
      "main": [
        [
          {
            "node": "Should Send Reminder?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Send Reminder?": {
      "main": [
        [
          {
            "node": "Send Reminder Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Reminder Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reminder Message": {
      "main": [
        [
          {
            "node": "Build Reminder Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Reminder Event": {
      "main": [
        [
          {
            "node": "Reminder Events DB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Run Events DB (reminder)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Last HR Profile": {
      "main": [
        [
          {
            "node": "GET HR Parameters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sync HR Zones": {
      "main": [
        [
          {
            "node": "Should Persist HR Profile?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prompt Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Persist HR Profile?": {
      "main": [
        [
          {
            "node": "HR Profiles DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET HR Parameters": {
      "main": [
        [
          {
            "node": "Merge Request + HR Params",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Request + HR Params": {
      "main": [
        [
          {
            "node": "Sync HR Zones",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "a3f728cc-fe6f-45c9-bd6d-430a6e8a3f9b",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "32e042aaa93a0c2717f17fdbf6d1b765a1d2543e64737ddc9ed84499712f834c"
  },
  "id": "Q9nTNHZ5vUBf58oI",
  "tags": []
}
