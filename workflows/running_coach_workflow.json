{
  "name": "Running Coach",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1600,
        448
      ],
      "id": "8181fc0a-148a-4556-9619-997e448253f7",
      "name": "When clicking \u2018Execute workflow\u2019"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -704,
        448
      ],
      "id": "bbab3a2d-65f6-4afd-bc79-d5792a915a4a",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  const a = item.json;\n  return {\n    json: {\n      id:              a.id,\n      athleteId:       a.icu_athlete_id,\n      date:            new Date(a.start_date),         // ISO 8601\n      type:            a.type,\n      duration:        a.elapsed_time,       // seconds\n      distance:        a.distance,           // meters (or null)\n      calories:        a.calories,\n      trimp:           a.trimp,\n      ctl:             a.icu_ctl,\n      atl:             a.icu_atl,\n      rampRate:        a.rampRate ?? (a.icu_ctl - a.icu_atl),\n      avgHeartRate:    a.average_heartrate,\n      maxHeartRate:    a.max_heartrate,\n      interval_summary: a.interval_summary,  // e.g. [\"1x...\",\"3x...\"]\n      sportInfo:       a.sportInfo           // you can leave the array or map to just types\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1152,
        352
      ],
      "id": "3f360e1c-10e3-49a8-b4a3-73e4b48479f3",
      "name": "Shape Activities"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  const w = item.json;\n  return {\n    json: {\n      id:         w.id,                            // e.g. \"2025-07-10\"\n      athleteId:  w.icu_athlete_id,                // your athlete key\n      date:       new Date(w.updated),                       // ISO timestamp of the record\n      ctl:        w.ctl,                           // chronic training load\n      atl:        w.atl,                           // acute training load\n      rampRate:   w.rampRate ?? (w.ctl - w.atl),   // change in load\n      ctlLoad:    w.ctlLoad,                       // daily CTL \u201cload\u201d\n      atlLoad:    w.atlLoad,                       // daily ATL \u201cload\u201d\n      restingHR:  w.restingHR,                     // recovery HR\n      hrv:        w.hrv,                           // HRV\n      sleepScore: w.sleepScore,                    // sleep quality\n      steps:      w.steps,                         // daily step count\n      weight:     w.weight                         // body weight (if available)\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1152,
        544
      ],
      "id": "2cc3212b-59ec-4b12-bb69-be867071d7ab",
      "name": "Shape Wellness"
    },
    {
      "parameters": {
        "url": "https://intervals.icu/api/v1/athlete/i372001/wellness",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "oldest",
              "value": "={{ $now.minus({ days: 7 }).toISODate() }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Basic QVBJX0tFWTo1d2VtM2xxbXh2Mjluenl3ZXVpMzh2cTc="
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          },
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        544
      ],
      "id": "43f25252-a6d2-4350-9005-faef42df185c",
      "name": "GET Wellness"
    },
    {
      "parameters": {
        "url": "https://intervals.icu/api/v1/athlete/i372001/activities",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "oldest",
              "value": "={{ $now.minus({ days: 7 }).toISO({ includeOffset: false }) }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Basic QVBJX0tFWTo1d2VtM2xxbXh2Mjluenl3ZXVpMzh2cTc="
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          },
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        352
      ],
      "id": "14d91aca-0f01-43a4-be95-8852730b31fe",
      "name": "GET Activities"
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "activities",
        "fields": "id, athleteId, date, type, duration, distance, calories, trimp, ctl, atl, rampRate, avgHeartRate, maxHeartRate, interval_summary, sportInfo",
        "upsert": true,
        "options": {
          "dateFields": "date"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -928,
        352
      ],
      "id": "3598eb29-2010-4428-b678-eaa40eeb6806",
      "name": "Activities DB",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "wellness",
        "fields": "id, athleteId, date, ctl, atl, rampRate, ctlLoad, atlLoad, restingHR, hrv, sleepScore, steps, weight",
        "upsert": true,
        "options": {
          "dateFields": "date"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -928,
        544
      ],
      "id": "ad492890-49d5-4580-9278-7272c4a00be6",
      "name": "Wellness DB",
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Function node: Compute weekly_metrics for the CURRENT week (Monday\u2013Sunday)\n// Input: one item whose JSON has { activities: [...], wellness: [...] }\n\nconst { activities: acts, wellness: well } = items[0].json;\n\n// 1\ufe0f\u20e3 Compute current week boundaries (Monday 00:00 to Sunday 23:59:59)\nconst today = new Date();\nconst day = today.getDay();               // 0=Sun, 1=Mon, \u2026 6=Sat\nconst diffToMonday = (day + 6) % 7;\nconst monday = new Date(today);\nmonday.setDate(today.getDate() - diffToMonday);\nmonday.setHours(0,0,0,0);\nconst sunday = new Date(monday);\nsunday.setDate(monday.getDate() + 6);\nsunday.setHours(23,59,59,999);\n\n// 2\ufe0f\u20e3 Helper: average over non-null\nconst avg = arr => arr.length\n  ? arr.reduce((sum, v) => sum + v, 0) / arr.length\n  : 0;\n\n// 3\ufe0f\u20e3 Filter this week\u2019s activities\nconst inWeek = a => {\n  const d = new Date(a.start_date);\n  return d >= monday && d <= sunday;\n};\nconst weekActs = acts.filter(inWeek);\n\n// 4\ufe0f\u20e3 Run, ride & strength metrics\nconst runActs      = weekActs.filter(a => a.type === 'Run');\nconst rideActs     = weekActs.filter(a => /Ride/.test(a.type));\nconst strengthActs = weekActs.filter(a => a.type === 'WeightTraining');\n\nconst runCount     = runActs.length;\nconst runDistance  = runActs.reduce((s,a) => s + (a.distance||0), 0);\nconst runTime      = runActs.reduce((s,a) => s + (a.elapsed_time||0), 0);\n\nconst rideCount    = rideActs.length;\nconst rideDistance = rideActs.reduce((s,a) => s + (a.distance||0), 0);\nconst rideTime     = rideActs.reduce((s,a) => s + (a.elapsed_time||0), 0);\nconst rideTrimp    = rideActs.reduce((s,a) => s + (a.trimp||0), 0);\n\nconst strengthCount = strengthActs.length;\nconst strengthTrimp = strengthActs.reduce((s,a) => s + (a.trimp||0), 0);\n\n// 5\ufe0f\u20e3 Session\u2010type counts by keyword in activity name\nconst vo2Sessions   = runActs.filter(a => /vo2/i.test(a.name)).length;\nconst tempoSessions = runActs.filter(a => /tempo|threshold|umbral/i.test(a.name)).length;\nconst longRuns      = runActs.filter(a => /long/i.test(a.name)).length;\n\n// 6\ufe0f\u20e3 Wellness this week (filter by id = YYYY-MM-DD)\nconst wellWeek = well.filter(w => {\n  const d = new Date(w.id);\n  return d >= monday && d <= sunday;\n});\n\nconst ctlMean        = avg(wellWeek.map(w=>w.ctl||0));\nconst atlMean        = avg(wellWeek.map(w=>w.atl||0));\nconst rampRateMean   = avg(wellWeek.map(w=>w.rampRate||0));\nconst restHrMean     = avg(wellWeek.map(w=>w.restingHR||0));\nconst stepsMean      = avg(wellWeek.map(w=>w.steps||0));\nconst sleepScoreMean = avg(wellWeek.map(w=>w.sleepScore||0));\nconst hrvMean        = avg(wellWeek.map(w=>w.hrv||0));\n\n// 7\ufe0f\u20e3 Identify athleteId (from any activity)\nconst athleteId = acts.length\n  ? acts[0].icu_athlete_id\n  : null;\n\n// 8\ufe0f\u20e3 Build weekly_metrics record\nconst weekStart = monday.toISOString().slice(0,10);\nconst weekEnd   = sunday.toISOString().slice(0,10);\nconst now       = new Date().toISOString();\n\nreturn [{\n  json: {\n    athleteId,\n    weekStart,\n    weekEnd,\n\n    runCount,\n    runDistance,\n    runTime,\n\n    rideCount,\n    rideDistance,\n    rideTime,\n    rideTrimp,\n\n    vo2Sessions,\n    tempoSessions,\n    longRuns,\n\n    strengthCount,\n    strengthTrimp,\n\n    ctlMean,\n    atlMean,\n    rampRateMean,\n\n    restHrMean,\n    stepsMean,\n    sleepScoreMean,\n    hrvMean,\n\n    createdAt: now,\n    updatedAt: now\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        96
      ],
      "id": "7196222d-0aea-4faa-8189-fb0bbb8d9379",
      "name": "Shape Weekly Metrics"
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "weekly_metrics",
        "updateKey": "weekStart",
        "fields": "athleteId, weekStart, weekEnd, runCount, runDistance, runTime, rideCount, rideDistance, rideTime, rideTrimp, vo2Sessions, tempoSessions, longRuns, strengthCount, strengthTrimp, ctlMean, atlMean, rampRateMean, restHrMean, stepsMean, sleepScoreMean, hrvMean, createdAt, updatedAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt, updatedAt"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ],
      "id": "8e7ba141-3fdf-4a40-a2d2-50d1705d6aff",
      "name": "Weekly Metrics DB",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "collection": "weekly_metrics",
        "options": {
          "sort": "{ \"weekStart\": -1 }"
        },
        "query": "={\n  \"weekStart\": {\n    \"$lt\": \"{{ $json.weekStart }}\"\n  }\n}\n"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        0,
        192
      ],
      "id": "2f2bc56d-2b5f-46ca-adf1-ad302a398f4e",
      "name": "Read Previous Weeks",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        224,
        96
      ],
      "id": "46575de3-0c9d-4381-ba47-c93f9625b9cd",
      "name": "Merge Current & History"
    },
    {
      "parameters": {
        "jsCode": "// El primer \u00edtem es el current\nconst current = items[0].json;\n\n// Los siguientes \u00edtems son tu hist\u00f3rico\nconst pastWeeks = items.slice(1).map(i => i.json);\n\nreturn [{\n  json: {\n    current,       // todas las m\u00e9tricas y el prompt de esta semana\n    history: pastWeeks  // tu hist\u00f3rico ya preparado\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        96
      ],
      "id": "e9f1806a-cb9c-4797-9969-ab99ad3442eb",
      "name": "Map Current + History"
    },
    {
      "parameters": {
        "jsCode": "// in a Function node (Run Once for All Items)\n\nconst activities = $items(\"GET Activities\").map(item => item.json);\nconst wellness   = $items(\"GET Wellness\"  ).map(item => item.json);\n\nreturn [\n  {\n    json: {\n      activities,\n      wellness\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -480,
        448
      ],
      "id": "b677badd-1fbf-4f1d-a40d-1648c59871fa",
      "name": "Map Activities + Wellness"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        640,
        448
      ],
      "id": "c90609f0-5298-4df0-9c53-22d304b3a8c1",
      "name": "Merge Request Data"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Prompt Builder para generar el JSON limpio que le enviaremos a OpenAI\n * Incluye semana, fechas y solicita al modelo los campos necesarios.\n */\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 CONFIGURACI\u00d3N \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n// Fecha de inicio de tu plan (puedes ajustarla)\nconst programStartDate = new Date('2025-07-19');\n\n// Fecha de la competici\u00f3n\nconst raceDate = new Date('2026-02-15');\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 C\u00c1LCULOS DE FECHAS \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst today = new Date();\nconst msPerWeek = 7 * 24 * 60 * 60 * 1000;\nconst weeksSinceStart = Math.floor((today - programStartDate) / msPerWeek) + 1;\nconst weeksToRace = Math.ceil((raceDate - today) / msPerWeek);\nconst totalPlanWeeks = weeksSinceStart + weeksToRace;\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 DETERMINACI\u00d3N DE FASE \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nlet phaseName, phaseNote;\nif (weeksSinceStart <= Math.floor(totalPlanWeeks * 0.3)) {\n  phaseName = 'Base';\n  phaseNote = 'Rodajes suaves y fuerza general.';\n} else if (weeksSinceStart <= Math.floor(totalPlanWeeks * 0.7)) {\n  phaseName = 'Desarrollo';\n  phaseNote = 'Interv\u00e1licos, tempo runs y fuerza espec\u00edfica.';\n} else if (weeksToRace > 2) {\n  phaseName = 'Espec\u00edfica';\n  phaseNote = 'Ritmo objetivo, simulaciones de competici\u00f3n.';\n} else {\n  phaseName = 'Taper';\n  phaseNote = 'Reducci\u00f3n de carga manteniendo chispa.';\n}\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 DESCOMPOSICI\u00d3N DE DATOS \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst { current, history: rawHistory } = items[0].json;\nconst history = Array.isArray(rawHistory)\n  ? rawHistory\n      .sort((a, b) => b.weekStart.localeCompare(a.weekStart))\n      .slice(0, 4)\n  : [];\n\nconst { activities, wellness } = items[1].json;\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 EXTRACCI\u00d3N DE FCMAX \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst DEFAULT_FCMAX = 202;\nconst recordedMaxHR = Math.max(\n  ...activities.map(a => a.max_heartrate || 0).filter(hr => hr > 0)\n);\nconst fcMax = recordedMaxHR >= 190 ? recordedMaxHR : DEFAULT_FCMAX;\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 HELPERS \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst avg = arr => arr.length ? arr.reduce((sum, v) => sum + v, 0) / arr.length : 0;\nconst fmt = x   => x != null ? x.toFixed(1) : '\u2014';\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 M\u00c9TRICAS SEMANA ACTUAL \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst { weekStart, weekEnd } = current;\nconst ctlActs    = avg( activities.map(a => a.icu_ctl      || 0) );\nconst atlActs    = avg( activities.map(a => a.icu_atl      || 0) );\nconst rampActs   = avg( activities.map(a => a.icu_rampRate || 0) );\nconst totalTrimp = activities.reduce((s,a) => s + (a.trimp || 0), 0);\n\nconst restVals = [...activities, ...wellness]\n  .map(o => o.restingHR).filter(v => v != null);\nconst stepVals = [...activities, ...wellness]\n  .map(o => o.steps).filter(v => v != null);\n\nconst restHR   = avg(restVals);\nconst steps    = avg(stepVals);\nconst hrvWel   = avg( wellness.map(w => w.hrv        || 0) );\nconst sleepWel = avg( wellness.map(w => w.sleepScore || 0) );\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 CONSTRUCCI\u00d3N DEL PROMPT (FORZAR JSON PURA) \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst prompt = `\nEres mi coach experto en medio marat\u00f3n (m\u00e9todo noruego, h\u00edbrido fuerza+carrera).\n\nContexto:\n- Mitja Marat\u00f3 Barcelona (15\u201102\u20112026), objetivo 1h45m (~4:59/km).\n- Empezamos el plan el ${programStartDate.toISOString().slice(0,10)}, esta es la semana **${weeksSinceStart}** de un plan de **${totalPlanWeeks}** semanas.\n- Quedan **${weeksToRace}** semanas \u2192 Fase **${phaseName}**: ${phaseNote}\n\nResumen ${weekStart} \u2192 ${weekEnd}:\n\u2022 CTL avg: ${fmt(ctlActs)}, ATL avg: ${fmt(atlActs)}, RampRate avg: ${fmt(rampActs)}\n\u2022 TRIMP total: ${fmt(totalTrimp)}\n\u2022 FC reposo medio: ${fmt(restHR)}\u202fbpm, Pasos/d\u00eda medio: ${fmt(steps)}\n\u2022 HRV avg: ${fmt(hrvWel)}, SleepScore avg: ${fmt(sleepWel)}\n\nHistorial (4 semanas anteriores):\n${history.map(h =>\n  `- Semana ${h.weekStart}: ${fmt(h.runDistance/1000)}\u202fkm \u00b7 ATL\u202f${fmt(h.atlMean)} \u00b7 RampRate\u202f${fmt(h.rampRateMean)} \u00b7 RHR\u202f${fmt(h.restHrMean)}`\n).join('\\n')}\n\nPor favor genera mi plan PARA LA PR\u00d3XIMA SEMANA siguiendo el m\u00e9todo noruego:\n- Indica fase del plan y el objetivo de la semana.\n- **Gimnasio**: Mar, Jue y S\u00e1b (orden: Pecho y brazos, Espalda y hombros, Piernas).\n- **Running** seg\u00fan carga (CTL, ATL, TRIMP, HRV/Sue\u00f1o):\n  1. Sesi\u00f3n VO\u2082\u202fm\u00e1x  \n  2. Sesi\u00f3n tempo/umbral  \n  3. Tirada larga aer\u00f3bica  \n  4. Easy/recovery  \n\n**IMPORTANTE**:  \n- Gimnasio a las 12\u201313h, calcula recuperaci\u00f3n y planifica alrededor.  \n- Usa **zonas de FC Garmin (Z1\u2013Z5)** basadas en FCm\u00e1x=${fcMax}\u202fbpm; indica % y rango de bpm.  \n- Si dispones de LTHR (183\u202fbpm), \u00fasalo para definir las zonas de umbral.\n\n\n\nSALIDA (OBLIGATORIA):\n\n- Devuelve exclusivamente un JSON v\u00e1lido y minificado en UNA sola l\u00ednea (sin texto extra, sin bloques de c\u00f3digo, sin comentarios).\n- Sustituye en todos los textos: &\u2192&amp;, <\u2192&lt;, >\u2192&gt;.\n- La respuesta empieza con { y termina con }.\n- \u2264 3000 caracteres en total.\n\nEstructura EXACTA con 7 objetos en days (uno por cada d\u00eda de la semana). Si no cabe, reduce primero note y luego justification.\n\n\\`\\`\\`json\n{\n  \"schema_version\": \"1.0\",\n  \"activityPlan\": {\n    \"nextWeek\": {\n      \"phase\": string,\n      \"objective\": string,\n      \"weekStart\": string,   // e.g. \"2025-07-14\"\n      \"weekEnd\":   string    // e.g. \"2025-07-20\"\n    },\n    \"days\": [\n      {\n        \"day\": string,         // Nombre en espa\u00f1ol, ej. \"Lunes\"\n        \"date\": string,        // Fecha concreta, ej. \"2025-07-14\"\n        \"activity\": string,\n        \"distance_time\": string,\n        \"intensity\": string,\n        \"goal\": string,\n        \"note\": string\n      }\n      // \u2026un objeto por cada d\u00eda de la semana\n    ]\n  },\n  \"justification\": [ string, \u2026 ]\n}\n\\`\\`\\`\n`.trim();\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 RETORNO \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nreturn [{\n  json: {\n    prompt,\n    metrics: {\n      programStartDate: programStartDate.toISOString().slice(0,10),\n      weeksSinceStart,\n      totalPlanWeeks,\n      weeksToRace,\n      phaseName,\n      weekStart,\n      weekEnd,\n      ctlActs,\n      atlActs,\n      rampActs,\n      totalTrimp,\n      restHR,\n      steps,\n      hrvWel,\n      sleepWel,\n      fcMax\n    },\n    history,\n    activities,\n    wellness\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        448
      ],
      "id": "76c7ae56-2f54-4c18-9fef-774b12705f5b",
      "name": "Prompt Builder"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.prompt }}",
              "role": "system"
            },
            {
              "content": "={{\n  `Datos de la \u00daLTIMA SEMANA:\\n` +\n  `M\u00e9tricas: ${JSON.stringify($json.metrics, null, 2)}\\n\\n` +\n  `Historial (semanas anteriores): ${JSON.stringify($json.history, null, 2)}`\n}}"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        1088,
        448
      ],
      "id": "34773ad2-7d76-4f29-a297-bc1c86ddabf6",
      "name": "Message a model",
      "alwaysOutputData": false,
      "credentials": {
        "openAiApi": {
          "id": "olyatB4PnLtBz9VL",
          "name": "OpenAi account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "chatId": "730354404",
        "text": "={{ $json.htmlMessage }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1712,
        448
      ],
      "id": "f044dc1e-c6df-4372-8334-1dee1dc7a75f",
      "name": "Send a text message",
      "webhookId": "2300ed5a-c28d-45ed-93fc-3b3df686f46d",
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * Build Telegram Message: formats the WeeklyPlan with date range and per-day details.\n */\n\n// Extract the model content (or already-normalized plan)\nconst content = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nif (!content.activityPlan || !content.justification) {\n  throw new Error('Missing activityPlan or justification in response.');\n}\n\nconst plan = content.activityPlan;\nconst justs = content.justification;\n\nconst { weekStart, weekEnd, phase, objective } = plan.nextWeek || {};\n\n// Build HTML message\nlet html = `\ud83c\udfc3\u200d\u2642\ufe0f <b>Weekly plan: ${weekStart} \u2192 ${weekEnd}</b>\n`;\nhtml += `\ud83d\udcc2 <b>Phase:</b> ${phase}\n`;\nhtml += `\ud83c\udfaf <b>Objective:</b> ${objective}\n\n`;\n\nfor (const d of plan.days) {\n  html += `\ud83d\udcc5 <b>${d.day} (${d.date}) \u2013 ${d.activity}</b>\n`;\n  html += `\ud83d\udccf ${d.distance_time || '\u2014'}\n`;\n  html += `\ud83d\udc93 ${d.intensity || '\u2014'}\n`;\n  html += `\ud83c\udfaf ${d.goal}\n`;\n  if (d.note) html += `\ud83d\udcdd <i>${d.note}</i>\n`;\n  html += `\n`;\n}\n\nhtml += `\ud83d\udcda <b>Justification</b>\n`;\njusts.forEach((j, i) => {\n  html += `${i + 1}. ${j}\n`;\n});\n\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\nconst runEvent = content.runEvent || {\n  runId: `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`,\n  status: 'success',\n  attempt: content.__attempt ?? null,\n  weekStart: weekStart || null,\n  weekEnd: weekEnd || null,\n  errorCount: errors.length,\n  errors,\n  createdAt: new Date().toISOString()\n};\n\nreturn [{\n  json: Object.assign({}, content, runEvent, {\n    runEvent,\n    htmlMessage: html.trim()\n  })\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        448
      ],
      "id": "ac201b6e-375f-48f5-9b1a-656f3987aa2c",
      "name": "Build Telegram Message"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 0 21 * * 0"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1600,
        640
      ],
      "id": "a666d5c6-fc73-4016-9518-04b879e1022b",
      "name": "Schedule Trigger"
    },
    {
      "id": "9522f055-e183-4aaa-b75e-803aecae3754",
      "name": "Validate WeeklyPlan (attempt 0)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        448
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 0;\n\nconst raw = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nlet parsed = raw;\nlet parseError = null;\n\nif (typeof raw === 'string') {\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    parseError = err && err.message ? err.message : String(err);\n    parsed = null;\n  }\n}\n\nconst errors = [];\n\nif (parseError) {\n  errors.push(`invalid_json: ${parseError}`);\n}\n\nconst isObject = value => value && typeof value === 'object' && !Array.isArray(value);\nconst plan = isObject(parsed) ? parsed : {};\n\nconst dateRe = /^\\d{4}-\\d{2}-\\d{2}$/;\nconst dayRe = /^(Lunes|Martes|Miercoles|Mi\\u00e9rcoles|Jueves|Viernes|Sabado|S\\u00e1bado|Domingo)$/;\nconst intensityRe = /^(?:-|--|\\u2014|.*\\b(Z[1-5]|interval|Interval|VO2|Tempo|tempo|Umbral|umbral|Threshold|threshold|Easy|easy|Recovery|recovery)\\b.*)$/;\n\nconst reqString = (obj, key, path) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string' || !value.trim()) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  return true;\n};\n\nif (plan.schema_version !== '1.0') {\n  errors.push('schema_version must be \"1.0\"');\n}\n\nif (!isObject(plan.activityPlan)) {\n  errors.push('activityPlan must be object');\n}\n\nconst nextWeek = plan.activityPlan && plan.activityPlan.nextWeek;\nif (!isObject(nextWeek)) {\n  errors.push('activityPlan.nextWeek must be object');\n} else {\n  reqString(nextWeek, 'phase', 'activityPlan.nextWeek');\n  reqString(nextWeek, 'objective', 'activityPlan.nextWeek');\n  if (!reqString(nextWeek, 'weekStart', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekStart)) {\n    errors.push('activityPlan.nextWeek.weekStart must be YYYY-MM-DD');\n  }\n  if (!reqString(nextWeek, 'weekEnd', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekEnd)) {\n    errors.push('activityPlan.nextWeek.weekEnd must be YYYY-MM-DD');\n  }\n}\n\nconst days = plan.activityPlan && plan.activityPlan.days;\nif (!Array.isArray(days)) {\n  errors.push('activityPlan.days must be array');\n} else if (days.length !== 7) {\n  errors.push('activityPlan.days must have length 7');\n} else {\n  days.forEach((day, idx) => {\n    const path = `activityPlan.days[${idx}]`;\n    if (!isObject(day)) {\n      errors.push(`${path} must be object`);\n      return;\n    }\n    if (!reqString(day, 'day', path) || !dayRe.test(day.day)) {\n      errors.push(`${path}.day must be a valid weekday`);\n    }\n    if (!reqString(day, 'date', path) || !dateRe.test(day.date)) {\n      errors.push(`${path}.date must be YYYY-MM-DD`);\n    }\n    reqString(day, 'activity', path);\n    reqString(day, 'distance_time', path);\n    if (!reqString(day, 'intensity', path) || !intensityRe.test(day.intensity)) {\n      errors.push(`${path}.intensity must include a zone/label or be '-'/'--'/'\u2014'`);\n    }\n    reqString(day, 'goal', path);\n  });\n}\n\n\n// Guardrails (hard rules)\nif (Array.isArray(days) && days.length === 7) {\n  const normalizeDay = (value) => (value || '')\n    .toLowerCase()\n    .replace(/[\u00e1\u00e0\u00e4]/g, 'a')\n    .replace(/[\u00e9\u00e8\u00eb]/g, 'e')\n    .replace(/[\u00ed\u00ec\u00ef]/g, 'i')\n    .replace(/[\u00f3\u00f2\u00f6]/g, 'o')\n    .replace(/[\u00fa\u00f9\u00fc]/g, 'u')\n    .replace(/\u00f1/g, 'n');\n  const activityText = (day) => `${day.activity || ''} ${day.goal || ''} ${day.note || ''}`.toLowerCase();\n  const intensityText = (day) => (day.intensity || '').toLowerCase();\n  const containsToken = (text, tokens) => tokens.some((token) => text.includes(token));\n\n  const hardTokens = ['z4', 'z5', 'vo2', 'interval', 'umbral', 'tempo', 'threshold'];\n  const easyTokens = ['z1', 'z2', 'easy', 'recovery', 'recuper', 'suave'];\n  const restTokens = ['descanso', 'rest', 'off'];\n  const longTokens = ['tirada', 'larga', 'long'];\n  const gymTokens = ['gimnasio', 'gym', 'fuerza', 'strength'];\n\n  const isHard = (day) => containsToken(intensityText(day), hardTokens) || containsToken(activityText(day), hardTokens);\n  const isEasy = (day) => containsToken(intensityText(day), easyTokens) || containsToken(activityText(day), easyTokens);\n  const isRest = (day) => containsToken(activityText(day), restTokens) || ['-', '--', '\u2014', '\u2013'].includes((day.intensity || '').trim());\n  const normalizedDays = days.map((day) => normalizeDay(day.day));\n  const uniqueDays = new Set(normalizedDays);\n  if (uniqueDays.size !== 7) {\n    errors.push('guardrail: days must cover all weekdays exactly once');\n  }\n  const requiredDays = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'];\n  requiredDays.forEach((name) => {\n    if (!uniqueDays.has(name)) {\n      errors.push(`guardrail: missing weekday ${name}`);\n    }\n  });\n\n  const isLong = (day) => containsToken(activityText(day), longTokens);\n\n  const hardCount = days.filter(isHard).length;\n  if (hardCount > 2) {\n    errors.push(`guardrail: too many hard sessions (${hardCount} > 2)`);\n  }\n\n  for (let i = 1; i < days.length; i += 1) {\n    if (isHard(days[i]) && isHard(days[i - 1])) {\n      errors.push(`guardrail: back-to-back hard sessions (days ${i} and ${i + 1})`);\n    }\n  }\n\n  const hasRecovery = days.some((day) => isRest(day) || isEasy(day));\n  if (!hasRecovery) {\n    errors.push('guardrail: must include at least one rest or recovery day');\n  }\n\n  const longCount = days.filter(isLong).length;\n  if (longCount > 1) {\n    errors.push('guardrail: only one long run per week');\n  }\n\n  days.forEach((day, idx) => {\n    if (isLong(day) && isHard(day)) {\n      errors.push(`guardrail: long run cannot be hard intensity (day ${idx + 1})`);\n    }\n  });\n\n  const gymDays = ['martes', 'jueves', 'sabado'];\n  gymDays.forEach((name) => {\n    const day = days.find((d) => normalizeDay(d.day) === name);\n    if (day && !containsToken(activityText(day), gymTokens)) {\n      errors.push(`guardrail: ${name} should include gym/strength`);\n    }\n  });\n}\nconst valid = errors.length == 0;\n\nconst output = isObject(plan) ? JSON.parse(JSON.stringify(plan)) : {};\noutput.__valid = valid;\noutput.__errors = errors;\noutput.__attempt = attempt;\noutput.__raw = typeof raw === 'string' ? raw : JSON.stringify(raw);\n\nreturn [{ json: output }];\n"
      }
    },
    {
      "id": "7a2b301d-fd6d-4ee5-b110-49a4e452043a",
      "name": "Is WeeklyPlan valid? (attempt 0)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1360,
        448
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.__valid }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "87e5a8a5-9c48-41cc-896a-c3e01ba62563",
      "name": "Build Repair Prompt (attempt 1)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1360,
        620
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 1;\nconst raw = items[0].json.__raw || JSON.stringify(items[0].json || {});\nconst errors = items[0].json.__errors || [];\n\nconst schemaSnippet = `{\n  \"schema_version\": \"1.0\",\n  \"activityPlan\": {\n    \"nextWeek\": { \"phase\": \"...\", \"objective\": \"...\", \"weekStart\": \"YYYY-MM-DD\", \"weekEnd\": \"YYYY-MM-DD\" },\n    \"days\": [\n      { \"day\": \"Lunes\", \"date\": \"YYYY-MM-DD\", \"activity\": \"...\", \"distance_time\": \"...\", \"intensity\": \"Z1-Z5\", \"goal\": \"...\", \"note\": \"...\" }\n    ]\n  },\n  \"justification\": [\"...\"]\n}`;\n\nconst repair_prompt = `You must return ONLY a valid minified JSON object that matches this schema snippet:\\n${schemaSnippet}\\n\\nInvalid output:\\n${raw}\\n\\nValidation errors:\\n${errors.join('\\n')}`;\n\nreturn [{ json: { repair_prompt, __attempt: attempt, __errors: errors, __raw: raw } }];\n"
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a JSON repair bot. Return only valid minified JSON."
            },
            {
              "role": "user",
              "content": "={{ $json.repair_prompt }}"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        1560,
        620
      ],
      "id": "4c22d709-ea45-42bf-89dd-4142310c7f61",
      "name": "Repair Plan 1",
      "alwaysOutputData": false,
      "credentials": {
        "openAiApi": {
          "id": "olyatB4PnLtBz9VL",
          "name": "OpenAi account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "62498923-3e4e-4a4d-ae27-72860fdf147d",
      "name": "Validate WeeklyPlan (attempt 1)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        620
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 1;\n\nconst raw = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nlet parsed = raw;\nlet parseError = null;\n\nif (typeof raw === 'string') {\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    parseError = err && err.message ? err.message : String(err);\n    parsed = null;\n  }\n}\n\nconst errors = [];\n\nif (parseError) {\n  errors.push(`invalid_json: ${parseError}`);\n}\n\nconst isObject = value => value && typeof value === 'object' && !Array.isArray(value);\nconst plan = isObject(parsed) ? parsed : {};\n\nconst dateRe = /^\\d{4}-\\d{2}-\\d{2}$/;\nconst dayRe = /^(Lunes|Martes|Miercoles|Mi\\u00e9rcoles|Jueves|Viernes|Sabado|S\\u00e1bado|Domingo)$/;\nconst intensityRe = /^(?:-|--|\\u2014|.*\\b(Z[1-5]|interval|Interval|VO2|Tempo|tempo|Umbral|umbral|Threshold|threshold|Easy|easy|Recovery|recovery)\\b.*)$/;\n\nconst reqString = (obj, key, path) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string' || !value.trim()) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  return true;\n};\n\nif (plan.schema_version !== '1.0') {\n  errors.push('schema_version must be \"1.0\"');\n}\n\nif (!isObject(plan.activityPlan)) {\n  errors.push('activityPlan must be object');\n}\n\nconst nextWeek = plan.activityPlan && plan.activityPlan.nextWeek;\nif (!isObject(nextWeek)) {\n  errors.push('activityPlan.nextWeek must be object');\n} else {\n  reqString(nextWeek, 'phase', 'activityPlan.nextWeek');\n  reqString(nextWeek, 'objective', 'activityPlan.nextWeek');\n  if (!reqString(nextWeek, 'weekStart', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekStart)) {\n    errors.push('activityPlan.nextWeek.weekStart must be YYYY-MM-DD');\n  }\n  if (!reqString(nextWeek, 'weekEnd', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekEnd)) {\n    errors.push('activityPlan.nextWeek.weekEnd must be YYYY-MM-DD');\n  }\n}\n\nconst days = plan.activityPlan && plan.activityPlan.days;\nif (!Array.isArray(days)) {\n  errors.push('activityPlan.days must be array');\n} else if (days.length !== 7) {\n  errors.push('activityPlan.days must have length 7');\n} else {\n  days.forEach((day, idx) => {\n    const path = `activityPlan.days[${idx}]`;\n    if (!isObject(day)) {\n      errors.push(`${path} must be object`);\n      return;\n    }\n    if (!reqString(day, 'day', path) || !dayRe.test(day.day)) {\n      errors.push(`${path}.day must be a valid weekday`);\n    }\n    if (!reqString(day, 'date', path) || !dateRe.test(day.date)) {\n      errors.push(`${path}.date must be YYYY-MM-DD`);\n    }\n    reqString(day, 'activity', path);\n    reqString(day, 'distance_time', path);\n    if (!reqString(day, 'intensity', path) || !intensityRe.test(day.intensity)) {\n      errors.push(`${path}.intensity must include a zone/label or be '-'/'--'/'\u2014'`);\n    }\n    reqString(day, 'goal', path);\n  });\n}\n\n\n// Guardrails (hard rules)\nif (Array.isArray(days) && days.length === 7) {\n  const normalizeDay = (value) => (value || '')\n    .toLowerCase()\n    .replace(/[\u00e1\u00e0\u00e4]/g, 'a')\n    .replace(/[\u00e9\u00e8\u00eb]/g, 'e')\n    .replace(/[\u00ed\u00ec\u00ef]/g, 'i')\n    .replace(/[\u00f3\u00f2\u00f6]/g, 'o')\n    .replace(/[\u00fa\u00f9\u00fc]/g, 'u')\n    .replace(/\u00f1/g, 'n');\n  const activityText = (day) => `${day.activity || ''} ${day.goal || ''} ${day.note || ''}`.toLowerCase();\n  const intensityText = (day) => (day.intensity || '').toLowerCase();\n  const containsToken = (text, tokens) => tokens.some((token) => text.includes(token));\n\n  const hardTokens = ['z4', 'z5', 'vo2', 'interval', 'umbral', 'tempo', 'threshold'];\n  const easyTokens = ['z1', 'z2', 'easy', 'recovery', 'recuper', 'suave'];\n  const restTokens = ['descanso', 'rest', 'off'];\n  const longTokens = ['tirada', 'larga', 'long'];\n  const gymTokens = ['gimnasio', 'gym', 'fuerza', 'strength'];\n\n  const isHard = (day) => containsToken(intensityText(day), hardTokens) || containsToken(activityText(day), hardTokens);\n  const isEasy = (day) => containsToken(intensityText(day), easyTokens) || containsToken(activityText(day), easyTokens);\n  const isRest = (day) => containsToken(activityText(day), restTokens) || ['-', '--', '\u2014', '\u2013'].includes((day.intensity || '').trim());\n  const normalizedDays = days.map((day) => normalizeDay(day.day));\n  const uniqueDays = new Set(normalizedDays);\n  if (uniqueDays.size !== 7) {\n    errors.push('guardrail: days must cover all weekdays exactly once');\n  }\n  const requiredDays = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'];\n  requiredDays.forEach((name) => {\n    if (!uniqueDays.has(name)) {\n      errors.push(`guardrail: missing weekday ${name}`);\n    }\n  });\n\n  const isLong = (day) => containsToken(activityText(day), longTokens);\n\n  const hardCount = days.filter(isHard).length;\n  if (hardCount > 2) {\n    errors.push(`guardrail: too many hard sessions (${hardCount} > 2)`);\n  }\n\n  for (let i = 1; i < days.length; i += 1) {\n    if (isHard(days[i]) && isHard(days[i - 1])) {\n      errors.push(`guardrail: back-to-back hard sessions (days ${i} and ${i + 1})`);\n    }\n  }\n\n  const hasRecovery = days.some((day) => isRest(day) || isEasy(day));\n  if (!hasRecovery) {\n    errors.push('guardrail: must include at least one rest or recovery day');\n  }\n\n  const longCount = days.filter(isLong).length;\n  if (longCount > 1) {\n    errors.push('guardrail: only one long run per week');\n  }\n\n  days.forEach((day, idx) => {\n    if (isLong(day) && isHard(day)) {\n      errors.push(`guardrail: long run cannot be hard intensity (day ${idx + 1})`);\n    }\n  });\n\n  const gymDays = ['martes', 'jueves', 'sabado'];\n  gymDays.forEach((name) => {\n    const day = days.find((d) => normalizeDay(d.day) === name);\n    if (day && !containsToken(activityText(day), gymTokens)) {\n      errors.push(`guardrail: ${name} should include gym/strength`);\n    }\n  });\n}\nconst valid = errors.length == 0;\n\nconst output = isObject(plan) ? JSON.parse(JSON.stringify(plan)) : {};\noutput.__valid = valid;\noutput.__errors = errors;\noutput.__attempt = attempt;\noutput.__raw = typeof raw === 'string' ? raw : JSON.stringify(raw);\n\nreturn [{ json: output }];\n"
      }
    },
    {
      "id": "fa78a02f-56e7-4eb7-9abe-13ee6d7391b0",
      "name": "Is WeeklyPlan valid? (attempt 1)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1960,
        620
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.__valid }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "82fbdd65-c54a-431a-b4af-7a0dec970aba",
      "name": "Build Repair Prompt (attempt 2)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1960,
        800
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 2;\nconst raw = items[0].json.__raw || JSON.stringify(items[0].json || {});\nconst errors = items[0].json.__errors || [];\n\nconst schemaSnippet = `{\n  \"schema_version\": \"1.0\",\n  \"activityPlan\": {\n    \"nextWeek\": { \"phase\": \"...\", \"objective\": \"...\", \"weekStart\": \"YYYY-MM-DD\", \"weekEnd\": \"YYYY-MM-DD\" },\n    \"days\": [\n      { \"day\": \"Lunes\", \"date\": \"YYYY-MM-DD\", \"activity\": \"...\", \"distance_time\": \"...\", \"intensity\": \"Z1-Z5\", \"goal\": \"...\", \"note\": \"...\" }\n    ]\n  },\n  \"justification\": [\"...\"]\n}`;\n\nconst repair_prompt = `You must return ONLY a valid minified JSON object that matches this schema snippet:\\n${schemaSnippet}\\n\\nInvalid output:\\n${raw}\\n\\nValidation errors:\\n${errors.join('\\n')}`;\n\nreturn [{ json: { repair_prompt, __attempt: attempt, __errors: errors, __raw: raw } }];\n"
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a JSON repair bot. Return only valid minified JSON."
            },
            {
              "role": "user",
              "content": "={{ $json.repair_prompt }}"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        2160,
        800
      ],
      "id": "6001c0c9-0433-4398-b371-ef28ba5f7a0d",
      "name": "Repair Plan 2",
      "alwaysOutputData": false,
      "credentials": {
        "openAiApi": {
          "id": "olyatB4PnLtBz9VL",
          "name": "OpenAi account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "fb318502-d4da-4197-8708-51e0946a6a5b",
      "name": "Validate WeeklyPlan (attempt 2)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2360,
        800
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 2;\n\nconst raw = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nlet parsed = raw;\nlet parseError = null;\n\nif (typeof raw === 'string') {\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    parseError = err && err.message ? err.message : String(err);\n    parsed = null;\n  }\n}\n\nconst errors = [];\n\nif (parseError) {\n  errors.push(`invalid_json: ${parseError}`);\n}\n\nconst isObject = value => value && typeof value === 'object' && !Array.isArray(value);\nconst plan = isObject(parsed) ? parsed : {};\n\nconst dateRe = /^\\d{4}-\\d{2}-\\d{2}$/;\nconst dayRe = /^(Lunes|Martes|Miercoles|Mi\\u00e9rcoles|Jueves|Viernes|Sabado|S\\u00e1bado|Domingo)$/;\nconst intensityRe = /^(?:-|--|\\u2014|.*\\b(Z[1-5]|interval|Interval|VO2|Tempo|tempo|Umbral|umbral|Threshold|threshold|Easy|easy|Recovery|recovery)\\b.*)$/;\n\nconst reqString = (obj, key, path) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string' || !value.trim()) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  return true;\n};\n\nif (plan.schema_version !== '1.0') {\n  errors.push('schema_version must be \"1.0\"');\n}\n\nif (!isObject(plan.activityPlan)) {\n  errors.push('activityPlan must be object');\n}\n\nconst nextWeek = plan.activityPlan && plan.activityPlan.nextWeek;\nif (!isObject(nextWeek)) {\n  errors.push('activityPlan.nextWeek must be object');\n} else {\n  reqString(nextWeek, 'phase', 'activityPlan.nextWeek');\n  reqString(nextWeek, 'objective', 'activityPlan.nextWeek');\n  if (!reqString(nextWeek, 'weekStart', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekStart)) {\n    errors.push('activityPlan.nextWeek.weekStart must be YYYY-MM-DD');\n  }\n  if (!reqString(nextWeek, 'weekEnd', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekEnd)) {\n    errors.push('activityPlan.nextWeek.weekEnd must be YYYY-MM-DD');\n  }\n}\n\nconst days = plan.activityPlan && plan.activityPlan.days;\nif (!Array.isArray(days)) {\n  errors.push('activityPlan.days must be array');\n} else if (days.length !== 7) {\n  errors.push('activityPlan.days must have length 7');\n} else {\n  days.forEach((day, idx) => {\n    const path = `activityPlan.days[${idx}]`;\n    if (!isObject(day)) {\n      errors.push(`${path} must be object`);\n      return;\n    }\n    if (!reqString(day, 'day', path) || !dayRe.test(day.day)) {\n      errors.push(`${path}.day must be a valid weekday`);\n    }\n    if (!reqString(day, 'date', path) || !dateRe.test(day.date)) {\n      errors.push(`${path}.date must be YYYY-MM-DD`);\n    }\n    reqString(day, 'activity', path);\n    reqString(day, 'distance_time', path);\n    if (!reqString(day, 'intensity', path) || !intensityRe.test(day.intensity)) {\n      errors.push(`${path}.intensity must include a zone/label or be '-'/'--'/'\u2014'`);\n    }\n    reqString(day, 'goal', path);\n  });\n}\n\n\n// Guardrails (hard rules)\nif (Array.isArray(days) && days.length === 7) {\n  const normalizeDay = (value) => (value || '')\n    .toLowerCase()\n    .replace(/[\u00e1\u00e0\u00e4]/g, 'a')\n    .replace(/[\u00e9\u00e8\u00eb]/g, 'e')\n    .replace(/[\u00ed\u00ec\u00ef]/g, 'i')\n    .replace(/[\u00f3\u00f2\u00f6]/g, 'o')\n    .replace(/[\u00fa\u00f9\u00fc]/g, 'u')\n    .replace(/\u00f1/g, 'n');\n  const activityText = (day) => `${day.activity || ''} ${day.goal || ''} ${day.note || ''}`.toLowerCase();\n  const intensityText = (day) => (day.intensity || '').toLowerCase();\n  const containsToken = (text, tokens) => tokens.some((token) => text.includes(token));\n\n  const hardTokens = ['z4', 'z5', 'vo2', 'interval', 'umbral', 'tempo', 'threshold'];\n  const easyTokens = ['z1', 'z2', 'easy', 'recovery', 'recuper', 'suave'];\n  const restTokens = ['descanso', 'rest', 'off'];\n  const longTokens = ['tirada', 'larga', 'long'];\n  const gymTokens = ['gimnasio', 'gym', 'fuerza', 'strength'];\n\n  const isHard = (day) => containsToken(intensityText(day), hardTokens) || containsToken(activityText(day), hardTokens);\n  const isEasy = (day) => containsToken(intensityText(day), easyTokens) || containsToken(activityText(day), easyTokens);\n  const isRest = (day) => containsToken(activityText(day), restTokens) || ['-', '--', '\u2014', '\u2013'].includes((day.intensity || '').trim());\n  const normalizedDays = days.map((day) => normalizeDay(day.day));\n  const uniqueDays = new Set(normalizedDays);\n  if (uniqueDays.size !== 7) {\n    errors.push('guardrail: days must cover all weekdays exactly once');\n  }\n  const requiredDays = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'];\n  requiredDays.forEach((name) => {\n    if (!uniqueDays.has(name)) {\n      errors.push(`guardrail: missing weekday ${name}`);\n    }\n  });\n\n  const isLong = (day) => containsToken(activityText(day), longTokens);\n\n  const hardCount = days.filter(isHard).length;\n  if (hardCount > 2) {\n    errors.push(`guardrail: too many hard sessions (${hardCount} > 2)`);\n  }\n\n  for (let i = 1; i < days.length; i += 1) {\n    if (isHard(days[i]) && isHard(days[i - 1])) {\n      errors.push(`guardrail: back-to-back hard sessions (days ${i} and ${i + 1})`);\n    }\n  }\n\n  const hasRecovery = days.some((day) => isRest(day) || isEasy(day));\n  if (!hasRecovery) {\n    errors.push('guardrail: must include at least one rest or recovery day');\n  }\n\n  const longCount = days.filter(isLong).length;\n  if (longCount > 1) {\n    errors.push('guardrail: only one long run per week');\n  }\n\n  days.forEach((day, idx) => {\n    if (isLong(day) && isHard(day)) {\n      errors.push(`guardrail: long run cannot be hard intensity (day ${idx + 1})`);\n    }\n  });\n\n  const gymDays = ['martes', 'jueves', 'sabado'];\n  gymDays.forEach((name) => {\n    const day = days.find((d) => normalizeDay(d.day) === name);\n    if (day && !containsToken(activityText(day), gymTokens)) {\n      errors.push(`guardrail: ${name} should include gym/strength`);\n    }\n  });\n}\nconst valid = errors.length == 0;\n\nconst output = isObject(plan) ? JSON.parse(JSON.stringify(plan)) : {};\noutput.__valid = valid;\noutput.__errors = errors;\noutput.__attempt = attempt;\noutput.__raw = typeof raw === 'string' ? raw : JSON.stringify(raw);\n\nreturn [{ json: output }];\n"
      }
    },
    {
      "id": "512261fd-832f-4c54-b584-199df7c8a2e5",
      "name": "Is WeeklyPlan valid? (attempt 2)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2560,
        800
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.__valid }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "60ab564c-0d54-46ac-857f-17eaa539b4bc",
      "name": "Fallback Trigger",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2760,
        980
      ],
      "parameters": {
        "jsCode": "throw new Error('Fallback required after max repair attempts.');"
      }
    },
    {
      "id": "1a5427aa-0afa-409b-bbda-2c0808182bbf",
      "name": "Build Run Event (success)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1268,
        328
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst plan = content.activityPlan || {};\nconst nextWeek = plan.nextWeek || {};\n\nconst runId = `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\n\nconst runEvent = {\n  runId,\n  status: 'success',\n  attempt: content.__attempt ?? null,\n  weekStart: nextWeek.weekStart || null,\n  weekEnd: nextWeek.weekEnd || null,\n  errorCount: errors.length,\n  errors,\n  createdAt: new Date().toISOString()\n};\n\nreturn [{\n  json: Object.assign({}, content, runEvent, { runEvent })\n}];\n"
      }
    },
    {
      "id": "76a0bc8d-962a-4fb4-adbd-f5968b5b83eb",
      "name": "Run Events DB (success)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1588,
        328
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_events",
        "updateKey": "runId",
        "fields": "runId, status, attempt, weekStart, weekEnd, errorCount, errors, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "92307575-ea91-4bac-b23a-1860c54c24c9",
      "name": "Build Failure Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        980
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst plan = content.activityPlan || {};\nconst nextWeek = plan.nextWeek || {};\n\nconst runId = `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst errors = Array.isArray(content.__errors) ? content.__errors : ['validation failed'];\n\nconst runEvent = {\n  runId,\n  status: 'failure',\n  attempt: content.__attempt ?? null,\n  weekStart: nextWeek.weekStart || null,\n  weekEnd: nextWeek.weekEnd || null,\n  errorCount: errors.length,\n  errors,\n  createdAt: new Date().toISOString()\n};\n\nconst alertMessage = [\n  '\u26a0\ufe0f Running Coach workflow failed',\n  `Run: ${runId}`,\n  `Errors (${errors.length}):`,\n  ...errors.map(err => `- ${err}`)\n].join('\n');\n\nreturn [{\n  json: Object.assign({}, runEvent, { runEvent, alertMessage })\n}];\n"
      }
    },
    {
      "id": "57d9052d-75a5-468d-a5f8-e61dbd8f7f91",
      "name": "Run Events DB (failure)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        2480,
        980
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_events",
        "updateKey": "runId",
        "fields": "runId, status, attempt, weekStart, weekEnd, errorCount, errors, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "e0eb79f9-5da4-43bb-a51f-230f787624fd",
      "name": "Send Failure Alert",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        2720,
        980
      ],
      "parameters": {
        "chatId": "730354404",
        "text": "={{ $json.alertMessage }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "webhookId": "ae55f720-070b-42e2-b07e-f202cb99ced4",
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "id": "2d8f2e3c-1c6b-4b11-8b6f-6d6a1fcb55a2",
      "name": "Plan Snapshots DB",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1388,
        328
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "plan_snapshots",
        "updateKey": "runId",
        "fields": "runId, attempt, weekStart, weekEnd, schema_version, activityPlan, justification, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking \u2018Execute workflow\u2019": {
      "main": [
        [
          {
            "node": "GET Activities",
            "type": "main",
            "index": 0
          },
          {
            "node": "GET Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Map Activities + Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Activities": {
      "main": [
        [
          {
            "node": "Activities DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Wellness": {
      "main": [
        [
          {
            "node": "Wellness DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET Wellness": {
      "main": [
        [
          {
            "node": "Shape Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET Activities": {
      "main": [
        [
          {
            "node": "Shape Activities",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Weekly Metrics": {
      "main": [
        [
          {
            "node": "Weekly Metrics DB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Previous Weeks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Previous Weeks": {
      "main": [
        [
          {
            "node": "Merge Current & History",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Current & History": {
      "main": [
        [
          {
            "node": "Map Current + History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Current + History": {
      "main": [
        [
          {
            "node": "Merge Request Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Weekly Metrics DB": {
      "main": [
        [
          {
            "node": "Merge Current & History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Activities + Wellness": {
      "main": [
        [
          {
            "node": "Shape Weekly Metrics",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Request Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Request Data": {
      "main": [
        [
          {
            "node": "Prompt Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prompt Builder": {
      "main": [
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message a model": {
      "main": [
        [
          {
            "node": "Validate WeeklyPlan (attempt 0)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Telegram Message": {
      "main": [
        [
          {
            "node": "Run Events DB (success)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wellness DB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Activities DB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "GET Activities",
            "type": "main",
            "index": 0
          },
          {
            "node": "GET Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate WeeklyPlan (attempt 0)": {
      "main": [
        [
          {
            "node": "Is WeeklyPlan valid? (attempt 0)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is WeeklyPlan valid? (attempt 0)": {
      "main": [
        [
          {
            "node": "Build Telegram Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Repair Prompt (attempt 1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Repair Prompt (attempt 1)": {
      "main": [
        [
          {
            "node": "Repair Plan 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repair Plan 1": {
      "main": [
        [
          {
            "node": "Validate WeeklyPlan (attempt 1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate WeeklyPlan (attempt 1)": {
      "main": [
        [
          {
            "node": "Is WeeklyPlan valid? (attempt 1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is WeeklyPlan valid? (attempt 1)": {
      "main": [
        [
          {
            "node": "Build Telegram Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Repair Prompt (attempt 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Repair Prompt (attempt 2)": {
      "main": [
        [
          {
            "node": "Repair Plan 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repair Plan 2": {
      "main": [
        [
          {
            "node": "Validate WeeklyPlan (attempt 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate WeeklyPlan (attempt 2)": {
      "main": [
        [
          {
            "node": "Is WeeklyPlan valid? (attempt 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is WeeklyPlan valid? (attempt 2)": {
      "main": [
        [
          {
            "node": "Build Run Event (success)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Failure Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fallback Trigger": {
      "main": []
    },
    "Build Run Event (success)": {
      "main": [
        [
          {
            "node": "Plan Snapshots DB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Telegram Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Events DB (success)": {
      "main": [
        [
          {
            "node": "Send a text message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Failure Event": {
      "main": [
        [
          {
            "node": "Run Events DB (failure)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Events DB (failure)": {
      "main": [
        [
          {
            "node": "Send Failure Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Failure Alert": {
      "main": [
        [
          {
            "node": "Fallback Trigger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Plan Snapshots DB": {
      "main": []
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "a3f728cc-fe6f-45c9-bd6d-430a6e8a3f9b",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "32e042aaa93a0c2717f17fdbf6d1b765a1d2543e64737ddc9ed84499712f834c"
  },
  "id": "Q9nTNHZ5vUBf58oI",
  "tags": []
}
