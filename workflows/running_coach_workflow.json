{
  "name": "Running Coach",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1600,
        448
      ],
      "id": "8181fc0a-148a-4556-9619-997e448253f7",
      "name": "When clicking \u2018Execute workflow\u2019"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -704,
        448
      ],
      "id": "bbab3a2d-65f6-4afd-bc79-d5792a915a4a",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  const a = item.json;\n  return {\n    json: {\n      id:              a.id,\n      athleteId:       a.icu_athlete_id,\n      date:            new Date(a.start_date),         // ISO 8601\n      type:            a.type,\n      duration:        a.elapsed_time,       // seconds\n      distance:        a.distance,           // meters (or null)\n      calories:        a.calories,\n      trimp:           a.trimp,\n      ctl:             a.icu_ctl,\n      atl:             a.icu_atl,\n      rampRate:        a.rampRate ?? (a.icu_ctl - a.icu_atl),\n      avgHeartRate:    a.average_heartrate,\n      maxHeartRate:    a.max_heartrate,\n      interval_summary: a.interval_summary,  // e.g. [\"1x...\",\"3x...\"]\n      sportInfo:       a.sportInfo           // you can leave the array or map to just types\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1152,
        352
      ],
      "id": "3f360e1c-10e3-49a8-b4a3-73e4b48479f3",
      "name": "Shape Activities"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  const w = item.json;\n  return {\n    json: {\n      id:         w.id,                            // e.g. \"2025-07-10\"\n      athleteId:  w.icu_athlete_id,                // your athlete key\n      date:       new Date(w.updated),                       // ISO timestamp of the record\n      ctl:        w.ctl,                           // chronic training load\n      atl:        w.atl,                           // acute training load\n      rampRate:   w.rampRate ?? (w.ctl - w.atl),   // change in load\n      ctlLoad:    w.ctlLoad,                       // daily CTL \u201cload\u201d\n      atlLoad:    w.atlLoad,                       // daily ATL \u201cload\u201d\n      restingHR:  w.restingHR,                     // recovery HR\n      hrv:        w.hrv,                           // HRV\n      sleepScore: w.sleepScore,                    // sleep quality\n      steps:      w.steps,                         // daily step count\n      weight:     w.weight                         // body weight (if available)\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1152,
        544
      ],
      "id": "2cc3212b-59ec-4b12-bb69-be867071d7ab",
      "name": "Shape Wellness"
    },
    {
      "parameters": {
        "url": "https://intervals.icu/api/v1/athlete/i372001/wellness",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "oldest",
              "value": "={{ $now.minus({ days: 7 }).toISODate() }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Basic QVBJX0tFWTo1d2VtM2xxbXh2Mjluenl3ZXVpMzh2cTc="
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          },
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        544
      ],
      "id": "43f25252-a6d2-4350-9005-faef42df185c",
      "name": "GET Wellness"
    },
    {
      "parameters": {
        "url": "https://intervals.icu/api/v1/athlete/i372001/activities",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "oldest",
              "value": "={{ $now.minus({ days: 7 }).toISO({ includeOffset: false }) }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Basic QVBJX0tFWTo1d2VtM2xxbXh2Mjluenl3ZXVpMzh2cTc="
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          },
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        352
      ],
      "id": "14d91aca-0f01-43a4-be95-8852730b31fe",
      "name": "GET Activities"
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "activities",
        "fields": "id, athleteId, date, type, duration, distance, calories, trimp, ctl, atl, rampRate, avgHeartRate, maxHeartRate, interval_summary, sportInfo",
        "upsert": true,
        "options": {
          "dateFields": "date"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -928,
        352
      ],
      "id": "3598eb29-2010-4428-b678-eaa40eeb6806",
      "name": "Activities DB",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "wellness",
        "fields": "id, athleteId, date, ctl, atl, rampRate, ctlLoad, atlLoad, restingHR, hrv, sleepScore, steps, weight",
        "upsert": true,
        "options": {
          "dateFields": "date"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -928,
        544
      ],
      "id": "ad492890-49d5-4580-9278-7272c4a00be6",
      "name": "Wellness DB",
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Function node: Compute weekly_metrics for the CURRENT week (Monday\u2013Sunday)\n// Input: one item whose JSON has { activities: [...], wellness: [...] }\n\nconst { activities: acts, wellness: well } = items[0].json;\n\n// 1\ufe0f\u20e3 Compute current week boundaries (Monday 00:00 to Sunday 23:59:59)\nconst today = new Date();\nconst day = today.getDay();               // 0=Sun, 1=Mon, \u2026 6=Sat\nconst diffToMonday = (day + 6) % 7;\nconst monday = new Date(today);\nmonday.setDate(today.getDate() - diffToMonday);\nmonday.setHours(0,0,0,0);\nconst sunday = new Date(monday);\nsunday.setDate(monday.getDate() + 6);\nsunday.setHours(23,59,59,999);\n\n// 2\ufe0f\u20e3 Helper: average over non-null\nconst avg = arr => arr.length\n  ? arr.reduce((sum, v) => sum + v, 0) / arr.length\n  : 0;\n\n// 3\ufe0f\u20e3 Filter this week\u2019s activities\nconst inWeek = a => {\n  const d = new Date(a.start_date);\n  return d >= monday && d <= sunday;\n};\nconst weekActs = acts.filter(inWeek);\n\n// 4\ufe0f\u20e3 Run, ride & strength metrics\nconst runActs      = weekActs.filter(a => a.type === 'Run');\nconst rideActs     = weekActs.filter(a => /Ride/.test(a.type));\nconst strengthActs = weekActs.filter(a => a.type === 'WeightTraining');\n\nconst runCount     = runActs.length;\nconst runDistance  = runActs.reduce((s,a) => s + (a.distance||0), 0);\nconst runTime      = runActs.reduce((s,a) => s + (a.elapsed_time||0), 0);\n\nconst rideCount    = rideActs.length;\nconst rideDistance = rideActs.reduce((s,a) => s + (a.distance||0), 0);\nconst rideTime     = rideActs.reduce((s,a) => s + (a.elapsed_time||0), 0);\nconst rideTrimp    = rideActs.reduce((s,a) => s + (a.trimp||0), 0);\n\nconst strengthCount = strengthActs.length;\nconst strengthTrimp = strengthActs.reduce((s,a) => s + (a.trimp||0), 0);\n\n// 5\ufe0f\u20e3 Session\u2010type counts by keyword in activity name\nconst vo2Sessions   = runActs.filter(a => /vo2/i.test(a.name)).length;\nconst tempoSessions = runActs.filter(a => /tempo|threshold|umbral/i.test(a.name)).length;\nconst longRuns      = runActs.filter(a => /long/i.test(a.name)).length;\n\n// 6\ufe0f\u20e3 Wellness this week (filter by id = YYYY-MM-DD)\nconst wellWeek = well.filter(w => {\n  const d = new Date(w.id);\n  return d >= monday && d <= sunday;\n});\n\nconst ctlMean        = avg(wellWeek.map(w=>w.ctl||0));\nconst atlMean        = avg(wellWeek.map(w=>w.atl||0));\nconst rampRateMean   = avg(wellWeek.map(w=>w.rampRate||0));\nconst restHrMean     = avg(wellWeek.map(w=>w.restingHR||0));\nconst stepsMean      = avg(wellWeek.map(w=>w.steps||0));\nconst sleepScoreMean = avg(wellWeek.map(w=>w.sleepScore||0));\nconst hrvMean        = avg(wellWeek.map(w=>w.hrv||0));\n\n// 7\ufe0f\u20e3 Identify athleteId (from any activity)\nconst athleteId = acts.length\n  ? acts[0].icu_athlete_id\n  : null;\n\n// 8\ufe0f\u20e3 Build weekly_metrics record\nconst weekStart = monday.toISOString().slice(0,10);\nconst weekEnd   = sunday.toISOString().slice(0,10);\nconst now       = new Date().toISOString();\n\nreturn [{\n  json: {\n    athleteId,\n    weekStart,\n    weekEnd,\n\n    runCount,\n    runDistance,\n    runTime,\n\n    rideCount,\n    rideDistance,\n    rideTime,\n    rideTrimp,\n\n    vo2Sessions,\n    tempoSessions,\n    longRuns,\n\n    strengthCount,\n    strengthTrimp,\n\n    ctlMean,\n    atlMean,\n    rampRateMean,\n\n    restHrMean,\n    stepsMean,\n    sleepScoreMean,\n    hrvMean,\n\n    createdAt: now,\n    updatedAt: now\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        96
      ],
      "id": "7196222d-0aea-4faa-8189-fb0bbb8d9379",
      "name": "Shape Weekly Metrics"
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "weekly_metrics",
        "updateKey": "weekStart",
        "fields": "athleteId, weekStart, weekEnd, runCount, runDistance, runTime, rideCount, rideDistance, rideTime, rideTrimp, vo2Sessions, tempoSessions, longRuns, strengthCount, strengthTrimp, ctlMean, atlMean, rampRateMean, restHrMean, stepsMean, sleepScoreMean, hrvMean, createdAt, updatedAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt, updatedAt"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ],
      "id": "8e7ba141-3fdf-4a40-a2d2-50d1705d6aff",
      "name": "Weekly Metrics DB",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "collection": "weekly_metrics",
        "options": {
          "sort": "{ \"weekStart\": -1 }"
        },
        "query": "={\n  \"weekStart\": {\n    \"$lt\": \"{{ $json.weekStart }}\"\n  }\n}\n"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        0,
        192
      ],
      "id": "2f2bc56d-2b5f-46ca-adf1-ad302a398f4e",
      "name": "Read Previous Weeks",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        224,
        96
      ],
      "id": "46575de3-0c9d-4381-ba47-c93f9625b9cd",
      "name": "Merge Current & History"
    },
    {
      "parameters": {
        "jsCode": "// El primer \u00edtem es el current\nconst current = items[0].json;\n\n// Los siguientes \u00edtems son tu hist\u00f3rico\nconst pastWeeks = items.slice(1).map(i => i.json);\n\nreturn [{\n  json: {\n    current,       // todas las m\u00e9tricas y el prompt de esta semana\n    history: pastWeeks  // tu hist\u00f3rico ya preparado\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        96
      ],
      "id": "e9f1806a-cb9c-4797-9969-ab99ad3442eb",
      "name": "Map Current + History"
    },
    {
      "parameters": {
        "jsCode": "// in a Function node (Run Once for All Items)\n\nconst activities = $items(\"GET Activities\").map(item => item.json);\nconst wellness   = $items(\"GET Wellness\"  ).map(item => item.json);\n\nreturn [\n  {\n    json: {\n      activities,\n      wellness\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -480,
        448
      ],
      "id": "b677badd-1fbf-4f1d-a40d-1648c59871fa",
      "name": "Map Activities + Wellness"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        640,
        448
      ],
      "id": "c90609f0-5298-4df0-9c53-22d304b3a8c1",
      "name": "Merge Request Data"
    },
    {
      "parameters": {
        "collection": "feedback_events",
        "options": {
          "sort": "{ \"receivedAt\": -1 }"
        },
        "query": "={\n}\n"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        760,
        304
      ],
      "id": "f8aba5ee-a953-4256-9776-75ef637e978d",
      "name": "Read Recent Feedback Summary",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const LOOKBACK_DAYS = 21;\nconst cutoffMs = Date.now() - (LOOKBACK_DAYS * 24 * 60 * 60 * 1000);\nconst DEFAULT_CHAT_ID = '730354404';\n\nconst getVar = (key) => {\n  if (typeof $vars !== 'undefined' && $vars[key] != null) {\n    return String($vars[key]);\n  }\n  if (typeof process !== 'undefined' && process.env && process.env[key] != null) {\n    return String(process.env[key]);\n  }\n  return '';\n};\n\nconst isTruthy = (value) => ['1', 'true', 'yes', 'on'].includes(String(value).toLowerCase());\n\nconst previewEnabled = isTruthy(getVar('RC_TELEGRAM_PREVIEW_MODE'));\nconst previewChatRaw = getVar('RC_TELEGRAM_PREVIEW_CHAT_ID').trim();\nif (previewEnabled && !previewChatRaw) {\n  throw new Error('RC_TELEGRAM_PREVIEW_CHAT_ID is required when RC_TELEGRAM_PREVIEW_MODE is enabled.');\n}\nconst targetChatId = previewEnabled ? previewChatRaw : DEFAULT_CHAT_ID;\n\nconst toTs = (value) => {\n  const ts = new Date(value || 0).getTime();\n  return Number.isFinite(ts) ? ts : null;\n};\n\nconst normalizeType = (doc) => String(doc.type || doc.response || '').toLowerCase();\n\nconst docs = items\n  .map((item) => item.json || {})\n  .filter((doc) => doc && Object.keys(doc).length > 0);\n\nconst docsForChat = docs.filter((doc) => String(doc.chatId || '') === targetChatId);\n\nconst recentDocs = docsForChat.filter((doc) => {\n  const ts = toTs(doc.receivedAt || doc.timestamp || doc.sessionDate);\n  return ts !== null && ts >= cutoffMs;\n});\n\n// Mongo find can run once per upstream item; dedupe to avoid double-counting.\nconst seen = new Set();\nconst uniqueRecentDocs = recentDocs.filter((doc) => {\n  const dedupeKey = String(\n    doc.sessionKey\n      || [doc.runId, doc.sessionRef, doc.type || doc.response, doc.receivedAt || doc.timestamp || doc.sessionDate]\n           .filter(Boolean)\n           .join('|')\n  );\n  if (!dedupeKey || seen.has(dedupeKey)) {\n    return false;\n  }\n  seen.add(dedupeKey);\n  return true;\n});\n\nconst counts = { done: 0, skipped: 0, hard: 0, pain: 0 };\nfor (const doc of uniqueRecentDocs) {\n  const type = normalizeType(doc);\n  if (Object.prototype.hasOwnProperty.call(counts, type)) {\n    counts[type] += 1;\n  }\n}\n\nconst totalResponses = counts.done + counts.skipped + counts.hard + counts.pain;\nconst adherenceSampleSize = counts.done + counts.skipped;\nconst adherenceRate = adherenceSampleSize > 0 ? counts.done / adherenceSampleSize : null;\nconst skipRate = adherenceSampleSize > 0 ? counts.skipped / adherenceSampleSize : null;\n\nconst latestPainDoc = uniqueRecentDocs\n  .filter((doc) => normalizeType(doc) === 'pain')\n  .sort((a, b) => (toTs(b.receivedAt || b.timestamp || b.sessionDate) || 0) - (toTs(a.receivedAt || a.timestamp || a.sessionDate) || 0))[0] || null;\n\nconst hasRecentPain = counts.pain > 0;\nconst hasLowAdherence = counts.skipped >= 2 || (adherenceSampleSize > 0 && adherenceRate !== null && adherenceRate < 0.6);\n\nconst adaptationTriggers = [];\nconst adaptationReasons = [];\nif (hasRecentPain) {\n  adaptationTriggers.push('painReported');\n  adaptationReasons.push('Recent pain feedback detected; biasing plan toward recovery and lower impact/intensity.');\n}\nif (hasLowAdherence) {\n  adaptationTriggers.push('lowAdherence');\n  adaptationReasons.push('Adherence is low; simplifying the week and prioritizing consistency.');\n}\n\nconst feedbackSummary = {\n  windowDays: LOOKBACK_DAYS,\n  chatId: targetChatId,\n  totalResponses,\n  counts,\n  adherenceRate,\n  skipRate,\n  hasRecentPain,\n  hasLowAdherence,\n  latestPainDate: latestPainDoc ? (latestPainDoc.sessionDate || String(latestPainDoc.receivedAt || latestPainDoc.timestamp || '').slice(0, 10)) : null,\n  adaptationTriggers,\n  adaptationReasons,\n};\n\nconst requestItems = $items('Merge Request Data');\nconst requestPayload = requestItems.reduce((acc, item) => {\n  return Object.assign(acc, item.json || {});\n}, {});\n\nreturn [{\n  json: Object.assign({}, requestPayload, { feedbackSummary }),\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        760,
        448
      ],
      "id": "bd921e4f-76d3-42ed-acc0-222e414a078c",
      "name": "Summarize Recent Feedback"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Prompt Builder para generar el JSON limpio que le enviaremos a OpenAI\n * Incluye semana, fechas y solicita al modelo los campos necesarios.\n */\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 CONFIGURACI\u00d3N \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n// Fecha de inicio de tu plan (puedes ajustarla)\nconst programStartDate = new Date('2025-07-19');\n\n// Fecha de la competici\u00f3n\nconst raceDate = new Date('2026-02-15');\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 C\u00c1LCULOS DE FECHAS \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst today = new Date();\nconst msPerWeek = 7 * 24 * 60 * 60 * 1000;\nconst weeksSinceStart = Math.floor((today - programStartDate) / msPerWeek) + 1;\nconst weeksToRace = Math.ceil((raceDate - today) / msPerWeek);\nconst totalPlanWeeks = weeksSinceStart + weeksToRace;\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 DETERMINACI\u00d3N DE FASE \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nlet phaseName, phaseNote;\nif (weeksSinceStart <= Math.floor(totalPlanWeeks * 0.3)) {\n  phaseName = 'Base';\n  phaseNote = 'Rodajes suaves y fuerza general.';\n} else if (weeksSinceStart <= Math.floor(totalPlanWeeks * 0.7)) {\n  phaseName = 'Desarrollo';\n  phaseNote = 'Interv\u00e1licos, tempo runs y fuerza espec\u00edfica.';\n} else if (weeksToRace > 2) {\n  phaseName = 'Espec\u00edfica';\n  phaseNote = 'Ritmo objetivo, simulaciones de competici\u00f3n.';\n} else {\n  phaseName = 'Taper';\n  phaseNote = 'Reducci\u00f3n de carga manteniendo chispa.';\n}\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 DESCOMPOSICI\u00d3N DE DATOS \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst { current, history: rawHistory } = items[0].json;\nconst history = Array.isArray(rawHistory)\n  ? rawHistory\n      .sort((a, b) => b.weekStart.localeCompare(a.weekStart))\n      .slice(0, 4)\n  : [];\n\nconst feedbackSummaryRaw = items[0].json.feedbackSummary;\nconst feedbackSummary = (feedbackSummaryRaw && typeof feedbackSummaryRaw === 'object')\n  ? feedbackSummaryRaw\n  : {\n      windowDays: 21,\n      totalResponses: 0,\n      counts: { done: 0, skipped: 0, hard: 0, pain: 0 },\n      adherenceRate: null,\n      skipRate: null,\n      hasRecentPain: false,\n      hasLowAdherence: false,\n      latestPainDate: null,\n      adaptationTriggers: [],\n      adaptationReasons: [],\n    };\n\nconst sourceActivities = Array.isArray(items[0].json.activities) ? items[0].json.activities : [];\nconst sourceWellness = Array.isArray(items[0].json.wellness) ? items[0].json.wellness : [];\nconst activities = sourceActivities;\nconst wellness = sourceWellness;\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 EXTRACCI\u00d3N DE FCMAX \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst DEFAULT_FCMAX = 202;\nconst recordedMaxHR = Math.max(\n  ...activities.map(a => a.max_heartrate || 0).filter(hr => hr > 0)\n);\nconst fcMax = recordedMaxHR >= 190 ? recordedMaxHR : DEFAULT_FCMAX;\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 HELPERS \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst avg = arr => arr.length ? arr.reduce((sum, v) => sum + v, 0) / arr.length : 0;\nconst fmt = x   => x != null ? x.toFixed(1) : '\u2014';\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 M\u00c9TRICAS SEMANA ACTUAL \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst { weekStart, weekEnd } = current;\nconst ctlActs    = avg( activities.map(a => a.icu_ctl      || 0) );\nconst atlActs    = avg( activities.map(a => a.icu_atl      || 0) );\nconst rampActs   = avg( activities.map(a => a.icu_rampRate || 0) );\nconst totalTrimp = activities.reduce((s,a) => s + (a.trimp || 0), 0);\n\nconst restVals = [...activities, ...wellness]\n  .map(o => o.restingHR).filter(v => v != null);\nconst stepVals = [...activities, ...wellness]\n  .map(o => o.steps).filter(v => v != null);\n\nconst restHR   = avg(restVals);\nconst steps    = avg(stepVals);\nconst hrvWel   = avg( wellness.map(w => w.hrv        || 0) );\nconst sleepWel = avg( wellness.map(w => w.sleepScore || 0) );\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 CONSTRUCCI\u00d3N DEL PROMPT (FORZAR JSON PURA) \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst prompt = `\n// PROMPT_BEGIN\nEres mi coach experto en medio marat\u00f3n (m\u00e9todo noruego, h\u00edbrido fuerza+carrera).\n\nContexto:\n- Mitja Marat\u00f3 Barcelona (15\u201102\u20112026), objetivo 1h45m (~4:59/km).\n- Empezamos el plan el ${programStartDate.toISOString().slice(0,10)}, esta es la semana **${weeksSinceStart}** de un plan de **${totalPlanWeeks}** semanas.\n- Quedan **${weeksToRace}** semanas \u2192 Fase **${phaseName}**: ${phaseNote}\n\nResumen ${weekStart} \u2192 ${weekEnd}:\n\u2022 CTL avg: ${fmt(ctlActs)}, ATL avg: ${fmt(atlActs)}, RampRate avg: ${fmt(rampActs)}\n\u2022 TRIMP total: ${fmt(totalTrimp)}\n\u2022 FC reposo medio: ${fmt(restHR)}\u202fbpm, Pasos/d\u00eda medio: ${fmt(steps)}\n\u2022 HRV avg: ${fmt(hrvWel)}, SleepScore avg: ${fmt(sleepWel)}\n\nHistorial (4 semanas anteriores):\n${history.map(h =>\n  `- Semana ${h.weekStart}: ${fmt(h.runDistance/1000)}\u202fkm \u00b7 ATL\u202f${fmt(h.atlMean)} \u00b7 RampRate\u202f${fmt(h.rampRateMean)} \u00b7 RHR\u202f${fmt(h.restHrMean)}`\n).join('\\n')}\n\nFeedback reciente (${feedbackSummary.windowDays} dias):\n\u2022 done=${feedbackSummary.counts.done}, skipped=${feedbackSummary.counts.skipped}, hard=${feedbackSummary.counts.hard}, pain=${feedbackSummary.counts.pain}\n\u2022 adherenceRate=${feedbackSummary.adherenceRate == null ? 'n/a' : feedbackSummary.adherenceRate.toFixed(2)}, skipRate=${feedbackSummary.skipRate == null ? 'n/a' : feedbackSummary.skipRate.toFixed(2)}\n\u2022 triggers=${feedbackSummary.adaptationTriggers.length ? feedbackSummary.adaptationTriggers.join(', ') : 'none'}\n\nPor favor genera mi plan PARA LA PR\u00d3XIMA SEMANA siguiendo el m\u00e9todo noruego:\n- Indica fase del plan y el objetivo de la semana.\n- **Gimnasio**: Mar, Jue y S\u00e1b (orden: Pecho y brazos, Espalda y hombros, Piernas).\n- **Running** seg\u00fan carga (CTL, ATL, TRIMP, HRV/Sue\u00f1o):\n  1. Sesi\u00f3n VO\u2082\u202fm\u00e1x  \n  2. Sesi\u00f3n tempo/umbral  \n  3. Tirada larga aer\u00f3bica  \n  4. Easy/recovery  \n\nReglas de adaptacion por feedback:\n- Si trigger= painReported: reduce intensidad/volumen, evita impacto duro, y a\u00f1ade guidance explicita de recuperacion.\n- Si trigger= lowAdherence: simplifica el plan (menos complejidad/intensidad) y prioriza adherencia/consistencia.\n- Cuando haya triggers activos, reflejalos en nextWeek.objective y en justification con razones concretas.\n\n**IMPORTANTE**:  \n- Gimnasio a las 12\u201313h, calcula recuperaci\u00f3n y planifica alrededor.  \n- Usa **zonas de FC Garmin (Z1\u2013Z5)** basadas en FCm\u00e1x=${fcMax}\u202fbpm; indica % y rango de bpm.  \n- Si dispones de LTHR (183\u202fbpm), \u00fasalo para definir las zonas de umbral.\n\n\n\nSALIDA (OBLIGATORIA):\n\n- Devuelve exclusivamente un JSON v\u00e1lido y minificado en UNA sola l\u00ednea (sin texto extra, sin bloques de c\u00f3digo, sin comentarios).\n- Sustituye en todos los textos: &\u2192&amp;, <\u2192&lt;, >\u2192&gt;.\n- La respuesta empieza con { y termina con }.\n- \u2264 3000 caracteres en total.\n\nEstructura EXACTA con 7 objetos en days (uno por cada d\u00eda de la semana). Si no cabe, reduce primero note y luego justification.\n\n\\`\\`\\`json\n{\n  \"schema_version\": \"1.0\",\n  \"activityPlan\": {\n    \"nextWeek\": {\n      \"phase\": string,\n      \"objective\": string,\n      \"weekStart\": string,   // e.g. \"2025-07-14\"\n      \"weekEnd\":   string    // e.g. \"2025-07-20\"\n    },\n    \"days\": [\n      {\n        \"day\": string,         // Nombre en espa\u00f1ol, ej. \"Lunes\"\n        \"date\": string,        // Fecha concreta, ej. \"2025-07-14\"\n        \"activity\": string,\n        \"distance_time\": string,\n        \"intensity\": string,\n        \"goal\": string,\n        \"note\": string\n      }\n      // \u2026un objeto por cada d\u00eda de la semana\n    ]\n  },\n  \"justification\": [ string, \u2026 ]\n}\n\\`\\`\\`\n// PROMPT_END\n`.trim();\n\n// \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 RETORNO \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nconst runId = `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst PROMPT_VERSION = \"2026-02-13\";\n// Bump PROMPT_VERSION whenever the prompt template changes.\nconst modelId = \"gpt-5\";\nconst createdAt = new Date().toISOString();\n\nreturn [{\n  json: {\n    runId,\n    promptVersion: PROMPT_VERSION,\n    modelId,\n    createdAt,\n    prompt,\n    metrics: {\n      programStartDate: programStartDate.toISOString().slice(0,10),\n      weeksSinceStart,\n      totalPlanWeeks,\n      weeksToRace,\n      phaseName,\n      weekStart,\n      weekEnd,\n      ctlActs,\n      atlActs,\n      rampActs,\n      totalTrimp,\n      restHR,\n      steps,\n      hrvWel,\n      sleepWel,\n      fcMax\n    },\n    history,\n    feedbackSummary,\n    activities,\n    wellness\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        448
      ],
      "id": "76c7ae56-2f54-4c18-9fef-774b12705f5b",
      "name": "Prompt Builder"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.prompt }}",
              "role": "system"
            },
            {
              "content": "={{\n  `Datos de la \u00daLTIMA SEMANA:\\n` +\n  `M\u00e9tricas: ${JSON.stringify($json.metrics, null, 2)}\\n\\n` +\n  `Historial (semanas anteriores): ${JSON.stringify($json.history, null, 2)}\\n\\n` +\n  `Feedback reciente: ${JSON.stringify($json.feedbackSummary, null, 2)}`\n}}"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        1088,
        448
      ],
      "id": "34773ad2-7d76-4f29-a297-bc1c86ddabf6",
      "name": "Message a model",
      "alwaysOutputData": false,
      "credentials": {
        "openAiApi": {
          "id": "olyatB4PnLtBz9VL",
          "name": "OpenAi account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.htmlMessage }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1712,
        448
      ],
      "id": "f044dc1e-c6df-4372-8334-1dee1dc7a75f",
      "name": "Send a text message",
      "webhookId": "2300ed5a-c28d-45ed-93fc-3b3df686f46d",
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const TEMPLATE_VERSION = 'telegram-v2.1';\n\nconst DEFAULT_CHAT_ID = '730354404';\n\nconst isObject = (value) => value !== null && typeof value === 'object' && !Array.isArray(value);\n\nconst parseContent = (input) => {\n  if (typeof input !== 'string') {\n    return input;\n  }\n  try {\n    return JSON.parse(input);\n  } catch {\n    return null;\n  }\n};\n\nconst rawContent = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\nconst content = parseContent(rawContent);\n\nif (!isObject(content) || !isObject(content.activityPlan)) {\n  throw new Error('Missing or invalid activityPlan in response.');\n}\n\nconst plan = content.activityPlan;\nconst nextWeek = isObject(plan.nextWeek) ? plan.nextWeek : {};\nconst days = Array.isArray(plan.days) ? plan.days : [];\nconst justifications = Array.isArray(content.justification) ? content.justification : [];\n\nconst getVar = (key) => {\n  if (typeof $vars !== 'undefined' && $vars[key] != null) {\n    return String($vars[key]);\n  }\n  if (typeof process !== 'undefined' && process.env && process.env[key] != null) {\n    return String(process.env[key]);\n  }\n  return '';\n};\n\nconst isTruthy = (value) => ['1', 'true', 'yes', 'on'].includes(String(value).toLowerCase());\n\nconst previewEnabled = isTruthy(getVar('RC_TELEGRAM_PREVIEW_MODE'));\nconst previewChatRaw = getVar('RC_TELEGRAM_PREVIEW_CHAT_ID').trim();\nif (previewEnabled && !previewChatRaw) {\n  throw new Error('RC_TELEGRAM_PREVIEW_CHAT_ID is required when RC_TELEGRAM_PREVIEW_MODE is enabled.');\n}\nconst targetChatId = previewEnabled ? previewChatRaw : DEFAULT_CHAT_ID;\n\nconst runContextItems = $items('Prompt Builder');\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst metrics = isObject(runContext.metrics) ? runContext.metrics : {};\nconst history = Array.isArray(runContext.history) ? runContext.history : [];\n\nconst feedbackSummaryRaw = isObject(content.feedbackSummary)\n  ? content.feedbackSummary\n  : (isObject(runContext.feedbackSummary) ? runContext.feedbackSummary : null);\n\nconst valueOr = (value, fallback = '--') => {\n  if (value === null || value === undefined) return fallback;\n  const text = String(value).trim();\n  return text || fallback;\n};\n\nconst esc = (value) => String(value)\n  .replace(/&/g, '&amp;')\n  .replace(/</g, '&lt;')\n  .replace(/>/g, '&gt;')\n  .replace(/\"/g, '&quot;')\n  .replace(/'/g, '&#39;');\n\nconst num = (value) => {\n  if (value === null || value === undefined || value === '') return null;\n  const parsed = Number(value);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst mean = (values) => {\n  const valid = values.map(num).filter((value) => value !== null);\n  if (!valid.length) return null;\n  return valid.reduce((sum, value) => sum + value, 0) / valid.length;\n};\n\nconst fmt = (value, suffix = '') => (value === null ? '--' : `${value.toFixed(1)}${suffix}`);\nconst pct = (value) => (value === null ? '--' : `${(value * 100).toFixed(0)}%`);\n\nconst intOrZero = (value) => {\n  const parsed = Number.parseInt(value, 10);\n  return Number.isFinite(parsed) ? parsed : 0;\n};\n\nconst normalizeDay = (value) => String(value || '')\n  .toLowerCase()\n  .replace(/[\u00e1\u00e0\u00e4]/g, 'a')\n  .replace(/[\u00e9\u00e8\u00eb]/g, 'e')\n  .replace(/[\u00ed\u00ec\u00ef]/g, 'i')\n  .replace(/[\u00f3\u00f2\u00f6]/g, 'o')\n  .replace(/[\u00fa\u00f9\u00fc]/g, 'u')\n  .replace(/\u00f1/g, 'n');\n\nconst dayOrder = {\n  lunes: 0,\n  monday: 0,\n  martes: 1,\n  tuesday: 1,\n  miercoles: 2,\n  wednesday: 2,\n  jueves: 3,\n  thursday: 3,\n  viernes: 4,\n  friday: 4,\n  sabado: 5,\n  saturday: 5,\n  domingo: 6,\n  sunday: 6,\n};\n\nconst sortedDays = [...days].sort((a, b) => {\n  const aOrder = dayOrder[normalizeDay(a.day)];\n  const bOrder = dayOrder[normalizeDay(b.day)];\n  const safeA = aOrder === undefined ? 99 : aOrder;\n  const safeB = bOrder === undefined ? 99 : bOrder;\n  if (safeA !== safeB) return safeA - safeB;\n  return String(a.date || '').localeCompare(String(b.date || ''));\n});\n\nconst ctlNow = num(metrics.ctlActs);\nconst atlNow = num(metrics.atlActs);\nconst rampNow = num(metrics.rampActs);\nconst trimpNow = num(metrics.totalTrimp);\nconst restNow = num(metrics.restHR);\nconst hrvNow = num(metrics.hrvWel);\nconst sleepNow = num(metrics.sleepWel);\nconst stepsNow = num(metrics.steps);\n\nconst lastWeekSummaryLines = [];\nif (ctlNow !== null || atlNow !== null || rampNow !== null) {\n  lastWeekSummaryLines.push(`CTL / ATL / Ramp: ${fmt(ctlNow)} / ${fmt(atlNow)} / ${fmt(rampNow)}`);\n}\nif (trimpNow !== null) {\n  lastWeekSummaryLines.push(`TRIMP total: ${fmt(trimpNow)}`);\n}\nif (restNow !== null || hrvNow !== null || sleepNow !== null) {\n  lastWeekSummaryLines.push(`Recovery signals: Resting HR ${fmt(restNow)} bpm, HRV ${fmt(hrvNow)}, Sleep ${fmt(sleepNow)}`);\n}\nif (stepsNow !== null) {\n  lastWeekSummaryLines.push(`Average steps/day: ${fmt(stepsNow)}`);\n}\nconst hasLastWeekSummaryData = lastWeekSummaryLines.length > 0;\nif (!hasLastWeekSummaryData) {\n  lastWeekSummaryLines.push('No recent metrics available.');\n}\n\nconst feedbackCountsRaw = feedbackSummaryRaw && isObject(feedbackSummaryRaw.counts)\n  ? feedbackSummaryRaw.counts\n  : {};\nconst feedbackCounts = {\n  done: intOrZero(feedbackCountsRaw.done),\n  skipped: intOrZero(feedbackCountsRaw.skipped),\n  hard: intOrZero(feedbackCountsRaw.hard),\n  pain: intOrZero(feedbackCountsRaw.pain),\n};\nconst feedbackWindowDays = intOrZero(feedbackSummaryRaw && feedbackSummaryRaw.windowDays);\nconst feedbackTotalResponses = intOrZero(feedbackSummaryRaw && feedbackSummaryRaw.totalResponses);\nconst feedbackAdherenceRate = num(feedbackSummaryRaw && feedbackSummaryRaw.adherenceRate);\nconst feedbackSkipRate = num(feedbackSummaryRaw && feedbackSummaryRaw.skipRate);\nconst feedbackHasRecentPain = Boolean(feedbackSummaryRaw && feedbackSummaryRaw.hasRecentPain);\nconst feedbackHasLowAdherence = Boolean(feedbackSummaryRaw && feedbackSummaryRaw.hasLowAdherence);\nconst feedbackLatestPainDate = feedbackSummaryRaw && feedbackSummaryRaw.latestPainDate\n  ? String(feedbackSummaryRaw.latestPainDate)\n  : null;\nconst feedbackAdaptationTriggers = Array.isArray(feedbackSummaryRaw && feedbackSummaryRaw.adaptationTriggers)\n  ? feedbackSummaryRaw.adaptationTriggers.map((item) => String(item))\n  : [];\nconst feedbackAdaptationReasons = Array.isArray(feedbackSummaryRaw && feedbackSummaryRaw.adaptationReasons)\n  ? feedbackSummaryRaw.adaptationReasons.map((item) => String(item))\n  : [];\n\nconst weeklyAdherenceSummary = {\n  windowDays: feedbackWindowDays || null,\n  totalResponses: feedbackTotalResponses,\n  counts: feedbackCounts,\n  adherenceRate: feedbackAdherenceRate,\n  skipRate: feedbackSkipRate,\n  hasRecentPain: feedbackHasRecentPain,\n  hasLowAdherence: feedbackHasLowAdherence,\n  latestPainDate: feedbackLatestPainDate,\n  adaptationTriggers: feedbackAdaptationTriggers,\n  adaptationReasons: feedbackAdaptationReasons,\n};\n\nconst weeklyAdherenceLines = [];\nif (feedbackTotalResponses > 0) {\n  const windowLabel = feedbackWindowDays > 0 ? `${feedbackWindowDays}` : '--';\n  weeklyAdherenceLines.push(`Window: last ${windowLabel} days`);\n  weeklyAdherenceLines.push(\n    `Responses: ${feedbackTotalResponses} (done ${feedbackCounts.done}, skipped ${feedbackCounts.skipped}, hard ${feedbackCounts.hard}, pain ${feedbackCounts.pain})`,\n  );\n  weeklyAdherenceLines.push(`Adherence: ${pct(feedbackAdherenceRate)} | Skipped: ${pct(feedbackSkipRate)}`);\n  if (feedbackAdaptationTriggers.length) {\n    weeklyAdherenceLines.push(`Adaptation triggers: ${feedbackAdaptationTriggers.join(', ')}`);\n  }\n  if (feedbackHasLowAdherence) {\n    weeklyAdherenceLines.push('Low adherence detected recently. Plan is simplified for consistency.');\n  }\n  if (feedbackHasRecentPain && feedbackLatestPainDate) {\n    weeklyAdherenceLines.push(`Latest pain report: ${feedbackLatestPainDate}`);\n  }\n} else {\n  weeklyAdherenceLines.push('No recent feedback responses available.');\n}\nconst hasWeeklyAdherenceData = feedbackTotalResponses > 0;\n\nconst weekStart = valueOr(nextWeek.weekStart);\nconst weekEnd = valueOr(nextWeek.weekEnd);\nconst phase = valueOr(nextWeek.phase);\nconst objective = valueOr(nextWeek.objective);\n\nconst thisWeekGoalLines = [\n  `Week: ${weekStart} -> ${weekEnd}`,\n  `Phase: ${phase}`,\n  `Objective: ${objective}`,\n];\nif (justifications.length) {\n  const rationale = justifications\n    .slice(0, 3)\n    .map((item) => valueOr(item))\n    .join(' | ');\n  thisWeekGoalLines.push(`Rationale: ${rationale}`);\n}\nconst hasThisWeekGoalData = [nextWeek.weekStart, nextWeek.weekEnd, nextWeek.phase, nextWeek.objective].some(Boolean);\n\nconst dailyPlanLines = sortedDays.map((day) => {\n  const dayName = valueOr(day.day, 'Day');\n  const date = valueOr(day.date);\n  const activity = valueOr(day.activity);\n  const distanceTime = valueOr(day.distance_time);\n  const intensity = valueOr(day.intensity);\n  const goal = valueOr(day.goal);\n  const note = day.note ? ` | Note: ${valueOr(day.note, '')}` : '';\n  return `${dayName} (${date}) - ${activity} | ${distanceTime} | ${intensity} | ${goal}${note}`;\n});\nif (!dailyPlanLines.length) {\n  dailyPlanLines.push('No day-by-day entries available.');\n}\nconst hasCompleteDailyPlan = sortedDays.length === 7;\n\nconst combinedText = (day) => `${valueOr(day.activity, '')} ${valueOr(day.intensity, '')} ${valueOr(day.goal, '')} ${valueOr(day.note, '')}`.toLowerCase();\nconst hardPattern = /(\\bz4\\b|\\bz5\\b|vo2|tempo|threshold|umbral|interval)/;\nconst longPattern = /(\\blong\\b|tirada|larga)/;\n\nconst keySessionDay = sortedDays.find((day) => hardPattern.test(combinedText(day)))\n  || sortedDays.find((day) => longPattern.test(combinedText(day)))\n  || sortedDays[0]\n  || null;\n\nconst keySessionLines = [];\nif (keySessionDay) {\n  keySessionLines.push(\n    `${valueOr(keySessionDay.day, 'Day')} (${valueOr(keySessionDay.date)}) - ${valueOr(keySessionDay.activity)} | ${valueOr(keySessionDay.distance_time)} | ${valueOr(keySessionDay.intensity)} | ${valueOr(keySessionDay.goal)}`,\n  );\n  if (keySessionDay.note) {\n    keySessionLines.push(`Note: ${valueOr(keySessionDay.note, '')}`);\n  }\n} else {\n  keySessionLines.push('No key session identified.');\n}\nconst hasKeySessionData = Boolean(keySessionDay);\n\nconst baselineHrv = mean(history.map((entry) => entry.hrvMean));\nconst baselineRest = mean(history.map((entry) => entry.restHrMean));\nconst baselineRamp = mean(history.map((entry) => entry.rampRateMean));\n\nconst rationaleCandidates = [];\nconst addRationale = (text, metricKeys) => {\n  rationaleCandidates.push({ text, metricKeys });\n};\n\nif (ctlNow !== null && atlNow !== null && rampNow !== null) {\n  addRationale(\n    `Load balance: CTL ${fmt(ctlNow)}, ATL ${fmt(atlNow)}, ramp ${fmt(rampNow)}.`,\n    ['ctlActs', 'atlActs', 'rampActs'],\n  );\n}\nif (trimpNow !== null) {\n  addRationale(\n    `Weekly load volume: total TRIMP ${fmt(trimpNow)}.`,\n    ['totalTrimp'],\n  );\n}\nif (restNow !== null && hrvNow !== null && sleepNow !== null) {\n  addRationale(\n    `Recovery profile: Resting HR ${fmt(restNow)} bpm, HRV ${fmt(hrvNow)}, Sleep ${fmt(sleepNow)}.`,\n    ['restHR', 'hrvWel', 'sleepWel'],\n  );\n}\nif (hrvNow !== null && baselineHrv !== null && restNow !== null && baselineRest !== null) {\n  addRationale(\n    `Trend vs baseline: HRV ${fmt(hrvNow)} vs ${fmt(baselineHrv)}, Resting HR ${fmt(restNow)} vs ${fmt(baselineRest)} bpm.`,\n    ['hrvWel', 'histHrv', 'restHR', 'histRestHR'],\n  );\n}\nif (stepsNow !== null) {\n  addRationale(\n    `Daily activity support: average steps ${fmt(stepsNow)}.`,\n    ['steps'],\n  );\n}\nif (rampNow !== null && baselineRamp !== null) {\n  addRationale(\n    `Ramp management: current ramp ${fmt(rampNow)} vs baseline ${fmt(baselineRamp)}.`,\n    ['rampActs', 'histRamp'],\n  );\n}\n\nlet whyPlanHallucinationFailures = 0;\nconst whyThisPlan = [];\nconst whyMetricGroups = [];\nfor (const candidate of rationaleCandidates) {\n  const invalid = candidate.metricKeys.some((key) => key == null || key === '');\n  if (invalid) {\n    whyPlanHallucinationFailures += 1;\n    continue;\n  }\n  whyThisPlan.push(candidate.text);\n  whyMetricGroups.push(candidate.metricKeys);\n}\n\nif (whyThisPlan.length < 2) {\n  const fallback = [\n    ['ctlActs', ctlNow, 'CTL'],\n    ['atlActs', atlNow, 'ATL'],\n    ['rampActs', rampNow, 'ramp rate'],\n    ['totalTrimp', trimpNow, 'TRIMP'],\n    ['restHR', restNow, 'resting HR'],\n    ['hrvWel', hrvNow, 'HRV'],\n    ['sleepWel', sleepNow, 'sleep score'],\n    ['steps', stepsNow, 'steps'],\n  ];\n  for (const [key, value, label] of fallback) {\n    if (whyThisPlan.length >= 2) break;\n    if (value === null) continue;\n    const alreadyUsed = whyMetricGroups.some((group) => group.includes(key));\n    if (alreadyUsed) continue;\n    whyThisPlan.push(`Signal check: ${label} is ${fmt(value)}.`);\n    whyMetricGroups.push([key]);\n  }\n}\n\nif (whyThisPlan.length < 2) {\n  whyThisPlan.push('Insufficient metrics to generate full rationale bullets.');\n  whyMetricGroups.push([]);\n}\n\nconst whyThisPlanFinal = whyThisPlan.slice(0, 4);\nconst whyMetricGroupsFinal = whyMetricGroups.slice(0, 4);\nconst whyPlanMetricKeys = Array.from(new Set(whyMetricGroupsFinal.flat()));\n\n\nconst riskFeedback = (content.riskFeedback && typeof content.riskFeedback === 'object')\n  ? content.riskFeedback\n  : {};\n\nconst riskFlags = [];\nif (hrvNow !== null && baselineHrv !== null && hrvNow < baselineHrv * 0.9) {\n  riskFlags.push({\n    trigger: 'wellnessLow',\n    message: `HRV is ${fmt(hrvNow)} vs baseline ${fmt(baselineHrv)} (>=10% lower).`,\n    action: 'Prioritize recovery and keep intensity low for the next session.',\n  });\n}\nif (restNow !== null && baselineRest !== null && restNow > baselineRest + 3) {\n  riskFlags.push({\n    trigger: 'restHrHigh',\n    message: `Resting HR is ${fmt(restNow)} bpm vs baseline ${fmt(baselineRest)} (+3 bpm).`,\n    action: 'Reduce intensity and monitor morning fatigue over the next 48h.',\n  });\n}\nif (rampNow !== null && (rampNow > 5 || (baselineRamp !== null && rampNow > baselineRamp + 1.5))) {\n  riskFlags.push({\n    trigger: 'rampHigh',\n    message: `Ramp rate is high (${fmt(rampNow)}).`,\n    action: 'Avoid adding extra volume this week.',\n  });\n}\nif (sleepNow !== null && sleepNow < 70) {\n  riskFlags.push({\n    trigger: 'wellnessLow',\n    message: `Sleep score is low (${fmt(sleepNow)}).`,\n    action: 'Prefer easy aerobic work until sleep stabilizes.',\n  });\n}\nif (ctlNow !== null && atlNow !== null && atlNow - ctlNow > 10) {\n  riskFlags.push({\n    trigger: 'atlOverload',\n    message: `ATL (${fmt(atlNow)}) is notably above CTL (${fmt(ctlNow)}).`,\n    action: 'Add recovery between hard efforts.',\n  });\n}\nif (riskFeedback.hasRecentPain) {\n  const painDate = riskFeedback.latestPainDate || 'recent session';\n  riskFlags.push({\n    trigger: 'painReported',\n    message: `Pain feedback reported (${painDate}).`,\n    action: 'Avoid hard impact sessions and reassess symptoms before progressing.',\n  });\n}\n\nconst riskWarningTriggers = Array.from(new Set(riskFlags.map((flag) => flag.trigger)));\nconst riskWarningTriggerCounts = {\n  wellnessLow: riskFlags.some((flag) => flag.trigger === 'wellnessLow') ? 1 : 0,\n  rampHigh: riskFlags.some((flag) => flag.trigger === 'rampHigh') ? 1 : 0,\n  painReported: riskFlags.some((flag) => flag.trigger === 'painReported') ? 1 : 0,\n  restHrHigh: riskFlags.some((flag) => flag.trigger === 'restHrHigh') ? 1 : 0,\n  atlOverload: riskFlags.some((flag) => flag.trigger === 'atlOverload') ? 1 : 0,\n};\nconst riskWarningTriggerCount = riskWarningTriggers.length;\n\nconst hasWarningData = riskFlags.length > 0;\nconst warningLines = hasWarningData\n  ? riskFlags.map((flag) => `${flag.message} Action: ${flag.action}`)\n  : ['No red flags detected from current signals.'];\n\nconst sectionCompleteness = {\n  lastWeekSummary: hasLastWeekSummaryData,\n  weeklyAdherence: hasWeeklyAdherenceData,\n  thisWeekGoal: hasThisWeekGoalData,\n  dailyPlan: hasCompleteDailyPlan,\n  keySession: hasKeySessionData,\n  warnings: hasWarningData,\n};\nconst sectionMissingCount = Object.values(sectionCompleteness).filter((value) => !value).length;\n\nconst sections = [\n  { title: 'Last-week summary', lines: lastWeekSummaryLines },\n  { title: 'Weekly adherence', lines: weeklyAdherenceLines },\n  { title: 'This-week goal', lines: thisWeekGoalLines },\n  { title: 'Why this plan', lines: whyThisPlanFinal },\n  { title: 'Daily plan', lines: dailyPlanLines },\n  { title: 'Key session', lines: keySessionLines },\n  { title: 'Warnings', lines: warningLines },\n];\n\nconst htmlParts = [];\nhtmlParts.push(`<b>Weekly plan</b> ${esc(weekStart)} -> ${esc(weekEnd)}`);\nhtmlParts.push('');\n\nif (previewEnabled) {\n  htmlParts.push('<b>Preview mode</b>');\n  htmlParts.push(`- Messages are routed to preview chat ${esc(targetChatId)}.`);\n  htmlParts.push('');\n}\n\nfor (const section of sections) {\n  htmlParts.push(`<b>${esc(section.title)}</b>`);\n  for (const line of section.lines) {\n    htmlParts.push(`- ${esc(line)}`);\n  }\n  htmlParts.push('');\n}\n\nconst debugEnabled = isTruthy(getVar('RC_TELEGRAM_DEBUG_FOOTER'));\n\nif (debugEnabled) {\n  const runId = (content.runEvent && content.runEvent.runId)\n    || content.runId\n    || content.__runId\n    || runContext.runId\n    || '-';\n  const attempt = content.__attempt ?? (content.runEvent && content.runEvent.attempt) ?? '-';\n  const promptVersion = content.promptVersion || content.__promptVersion || runContext.promptVersion || '-';\n  const modelId = content.modelId || content.__modelId || runContext.modelId || '-';\n  htmlParts.push('<pre>'\n    + `run_id: ${esc(runId)}\\n`\n    + `attempt: ${esc(attempt)}\\n`\n    + `prompt_version: ${esc(promptVersion)}\\n`\n    + `model: ${esc(modelId)}\\n`\n    + `template_version: ${esc(TEMPLATE_VERSION)}\\n`\n    + `sections_missing: ${esc(sectionMissingCount)}\\n`\n    + `preview_mode: ${esc(previewEnabled)}\\n`\n    + `chat_id: ${esc(targetChatId)}`\n    + '</pre>');\n}\n\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\nconst baseRunEvent = isObject(content.runEvent)\n  ? content.runEvent\n  : {\n      runId: `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`,\n      status: 'success',\n      attempt: content.__attempt ?? null,\n      weekStart: nextWeek.weekStart || null,\n      weekEnd: nextWeek.weekEnd || null,\n      errorCount: errors.length,\n      errors,\n      createdAt: new Date().toISOString(),\n    };\n\nconst runEvent = Object.assign({}, baseRunEvent, {\n  telegramTemplateVersion: TEMPLATE_VERSION,\n  sectionCompleteness,\n  sectionMissingCount,\n  whyThisPlan: whyThisPlanFinal,\n  whyPlanMetricKeys,\n  whyPlanHallucinationFailures,\n  previewMode: previewEnabled,\n  previewChatId: targetChatId,\n  riskWarningTriggerCount,\n  riskWarningTriggers,\n  riskWarningTriggerCounts,\n  riskFeedback,\n  weeklyAdherenceSummary,\n});\n\nreturn [{\n  json: Object.assign({}, content, runEvent, {\n    runEvent,\n    telegramTemplateVersion: TEMPLATE_VERSION,\n    sectionCompleteness,\n    sectionMissingCount,\n    whyThisPlan: whyThisPlanFinal,\n    whyPlanMetricKeys,\n    whyPlanHallucinationFailures,\n    previewMode: previewEnabled,\n    previewChatId: targetChatId,\n    riskWarningTriggerCount,\n    riskWarningTriggers,\n    riskWarningTriggerCounts,\n    riskFeedback,\n    weeklyAdherenceSummary,\n    chatId: targetChatId,\n    htmlMessage: htmlParts.join('\\n').trim(),\n  }),\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        448
      ],
      "id": "ac201b6e-375f-48f5-9b1a-656f3987aa2c",
      "name": "Build Telegram Message"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 0 21 * * 0"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1600,
        640
      ],
      "id": "a666d5c6-fc73-4016-9518-04b879e1022b",
      "name": "Schedule Trigger"
    },
    {
      "id": "9522f055-e183-4aaa-b75e-803aecae3754",
      "name": "Validate WeeklyPlan (attempt 0)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        448
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 0;\n\nconst raw = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nlet parsed = raw;\nlet parseError = null;\n\nif (typeof raw === 'string') {\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    parseError = err && err.message ? err.message : String(err);\n    parsed = null;\n  }\n}\n\nconst errors = [];\n\nif (parseError) {\n  errors.push(`invalid_json: ${parseError}`);\n}\n\nconst isObject = value => value && typeof value === 'object' && !Array.isArray(value);\nconst plan = isObject(parsed) ? parsed : {};\n\nconst dateRe = /^\\d{4}-\\d{2}-\\d{2}$/;\nconst dayRe = /^(Lunes|Martes|Miercoles|Mi\\u00e9rcoles|Jueves|Viernes|Sabado|S\\u00e1bado|Domingo)$/;\nconst intensityRe = /^(?:-|--|\\u2014|.*\\b(Z[1-5]|interval|Interval|VO2|Tempo|tempo|Umbral|umbral|Threshold|threshold|Easy|easy|Recovery|recovery)\\b.*)$/;\n\nconst reqString = (obj, key, path) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string' || !value.trim()) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  return true;\n};\n\nif (plan.schema_version !== '1.0') {\n  errors.push('schema_version must be \"1.0\"');\n}\n\nif (!isObject(plan.activityPlan)) {\n  errors.push('activityPlan must be object');\n}\n\nconst nextWeek = plan.activityPlan && plan.activityPlan.nextWeek;\nif (!isObject(nextWeek)) {\n  errors.push('activityPlan.nextWeek must be object');\n} else {\n  reqString(nextWeek, 'phase', 'activityPlan.nextWeek');\n  reqString(nextWeek, 'objective', 'activityPlan.nextWeek');\n  if (!reqString(nextWeek, 'weekStart', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekStart)) {\n    errors.push('activityPlan.nextWeek.weekStart must be YYYY-MM-DD');\n  }\n  if (!reqString(nextWeek, 'weekEnd', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekEnd)) {\n    errors.push('activityPlan.nextWeek.weekEnd must be YYYY-MM-DD');\n  }\n}\n\nconst days = plan.activityPlan && plan.activityPlan.days;\nif (!Array.isArray(days)) {\n  errors.push('activityPlan.days must be array');\n} else if (days.length !== 7) {\n  errors.push('activityPlan.days must have length 7');\n} else {\n  days.forEach((day, idx) => {\n    const path = `activityPlan.days[${idx}]`;\n    if (!isObject(day)) {\n      errors.push(`${path} must be object`);\n      return;\n    }\n    if (!reqString(day, 'day', path) || !dayRe.test(day.day)) {\n      errors.push(`${path}.day must be a valid weekday`);\n    }\n    if (!reqString(day, 'date', path) || !dateRe.test(day.date)) {\n      errors.push(`${path}.date must be YYYY-MM-DD`);\n    }\n    reqString(day, 'activity', path);\n    reqString(day, 'distance_time', path);\n    if (!reqString(day, 'intensity', path) || !intensityRe.test(day.intensity)) {\n      errors.push(`${path}.intensity must include a zone/label or be '-'/'--'/'\u2014'`);\n    }\n    reqString(day, 'goal', path);\n  });\n}\n\n\n// Guardrails (hard rules)\nif (Array.isArray(days) && days.length === 7) {\n  const normalizeDay = (value) => (value || '')\n    .toLowerCase()\n    .replace(/[\u00e1\u00e0\u00e4]/g, 'a')\n    .replace(/[\u00e9\u00e8\u00eb]/g, 'e')\n    .replace(/[\u00ed\u00ec\u00ef]/g, 'i')\n    .replace(/[\u00f3\u00f2\u00f6]/g, 'o')\n    .replace(/[\u00fa\u00f9\u00fc]/g, 'u')\n    .replace(/\u00f1/g, 'n');\n  const activityText = (day) => `${day.activity || ''} ${day.goal || ''} ${day.note || ''}`.toLowerCase();\n  const intensityText = (day) => (day.intensity || '').toLowerCase();\n  const containsToken = (text, tokens) => tokens.some((token) => text.includes(token));\n\n  const hardTokens = ['z4', 'z5', 'vo2', 'interval', 'umbral', 'tempo', 'threshold'];\n  const easyTokens = ['z1', 'z2', 'easy', 'recovery', 'recuper', 'suave'];\n  const restTokens = ['descanso', 'rest', 'off'];\n  const longTokens = ['tirada', 'larga', 'long'];\n  const gymTokens = ['gimnasio', 'gym', 'fuerza', 'strength'];\n\n  const isHard = (day) => containsToken(intensityText(day), hardTokens) || containsToken(activityText(day), hardTokens);\n  const isEasy = (day) => containsToken(intensityText(day), easyTokens) || containsToken(activityText(day), easyTokens);\n  const isRest = (day) => containsToken(activityText(day), restTokens) || ['-', '--', '\u2014', '\u2013'].includes((day.intensity || '').trim());\n  const normalizedDays = days.map((day) => normalizeDay(day.day));\n  const uniqueDays = new Set(normalizedDays);\n  if (uniqueDays.size !== 7) {\n    errors.push('guardrail: days must cover all weekdays exactly once');\n  }\n  const requiredDays = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'];\n  requiredDays.forEach((name) => {\n    if (!uniqueDays.has(name)) {\n      errors.push(`guardrail: missing weekday ${name}`);\n    }\n  });\n\n  const isLong = (day) => containsToken(activityText(day), longTokens);\n\n  const hardCount = days.filter(isHard).length;\n  if (hardCount > 2) {\n    errors.push(`guardrail: too many hard sessions (${hardCount} > 2)`);\n  }\n\n  for (let i = 1; i < days.length; i += 1) {\n    if (isHard(days[i]) && isHard(days[i - 1])) {\n      errors.push(`guardrail: back-to-back hard sessions (days ${i} and ${i + 1})`);\n    }\n  }\n\n  const hasRecovery = days.some((day) => isRest(day) || isEasy(day));\n  if (!hasRecovery) {\n    errors.push('guardrail: must include at least one rest or recovery day');\n  }\n\n  const longCount = days.filter(isLong).length;\n  if (longCount > 1) {\n    errors.push('guardrail: only one long run per week');\n  }\n\n  days.forEach((day, idx) => {\n    if (isLong(day) && isHard(day)) {\n      errors.push(`guardrail: long run cannot be hard intensity (day ${idx + 1})`);\n    }\n  });\n\n  const gymDays = ['martes', 'jueves', 'sabado'];\n  gymDays.forEach((name) => {\n    const day = days.find((d) => normalizeDay(d.day) === name);\n    if (day && !containsToken(activityText(day), gymTokens)) {\n      errors.push(`guardrail: ${name} should include gym/strength`);\n    }\n  });\n}\nconst valid = errors.length == 0;\n\nconst output = isObject(plan) ? JSON.parse(JSON.stringify(plan)) : {};\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\n\noutput.__valid = valid;\noutput.__errors = errors;\noutput.__attempt = attempt;\noutput.__raw = typeof raw === 'string' ? raw : JSON.stringify(raw);\nif (runContext.runId) output.__runId = runContext.runId;\nif (runContext.promptVersion) output.__promptVersion = runContext.promptVersion;\nif (runContext.modelId) output.__modelId = runContext.modelId;\n\nreturn [{ json: output }];\n"
      }
    },
    {
      "id": "7a2b301d-fd6d-4ee5-b110-49a4e452043a",
      "name": "Is WeeklyPlan valid? (attempt 0)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1360,
        448
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.__valid }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "87e5a8a5-9c48-41cc-896a-c3e01ba62563",
      "name": "Build Repair Prompt (attempt 1)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1360,
        620
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 1;\nconst raw = items[0].json.__raw || JSON.stringify(items[0].json || {});\nconst errors = items[0].json.__errors || [];\n\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst runId = runContext.runId || null;\nconst promptVersion = runContext.promptVersion || null;\nconst modelId = runContext.modelId || null;\n\nconst schemaSnippet = `{\n  \"schema_version\": \"1.0\",\n  \"activityPlan\": {\n    \"nextWeek\": { \"phase\": \"...\", \"objective\": \"...\", \"weekStart\": \"YYYY-MM-DD\", \"weekEnd\": \"YYYY-MM-DD\" },\n    \"days\": [\n      { \"day\": \"Lunes\", \"date\": \"YYYY-MM-DD\", \"activity\": \"...\", \"distance_time\": \"...\", \"intensity\": \"Z1-Z5\", \"goal\": \"...\", \"note\": \"...\" }\n    ]\n  },\n  \"justification\": [\"...\"]\n}`;\n\nconst repair_prompt = `You must return ONLY a valid minified JSON object that matches this schema snippet:\\n${schemaSnippet}\\n\\nInvalid output:\\n${raw}\\n\\nValidation errors:\\n${errors.join('\\n')}`;\n\nreturn [{ json: { repair_prompt, __attempt: attempt, __errors: errors, __raw: raw, runId, promptVersion, modelId } }];\n"
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a JSON repair bot. Return only valid minified JSON."
            },
            {
              "role": "user",
              "content": "={{ $json.repair_prompt }}"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        1560,
        620
      ],
      "id": "4c22d709-ea45-42bf-89dd-4142310c7f61",
      "name": "Repair Plan 1",
      "alwaysOutputData": false,
      "credentials": {
        "openAiApi": {
          "id": "olyatB4PnLtBz9VL",
          "name": "OpenAi account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "62498923-3e4e-4a4d-ae27-72860fdf147d",
      "name": "Validate WeeklyPlan (attempt 1)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        620
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 1;\n\nconst raw = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nlet parsed = raw;\nlet parseError = null;\n\nif (typeof raw === 'string') {\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    parseError = err && err.message ? err.message : String(err);\n    parsed = null;\n  }\n}\n\nconst errors = [];\n\nif (parseError) {\n  errors.push(`invalid_json: ${parseError}`);\n}\n\nconst isObject = value => value && typeof value === 'object' && !Array.isArray(value);\nconst plan = isObject(parsed) ? parsed : {};\n\nconst dateRe = /^\\d{4}-\\d{2}-\\d{2}$/;\nconst dayRe = /^(Lunes|Martes|Miercoles|Mi\\u00e9rcoles|Jueves|Viernes|Sabado|S\\u00e1bado|Domingo)$/;\nconst intensityRe = /^(?:-|--|\\u2014|.*\\b(Z[1-5]|interval|Interval|VO2|Tempo|tempo|Umbral|umbral|Threshold|threshold|Easy|easy|Recovery|recovery)\\b.*)$/;\n\nconst reqString = (obj, key, path) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string' || !value.trim()) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  return true;\n};\n\nif (plan.schema_version !== '1.0') {\n  errors.push('schema_version must be \"1.0\"');\n}\n\nif (!isObject(plan.activityPlan)) {\n  errors.push('activityPlan must be object');\n}\n\nconst nextWeek = plan.activityPlan && plan.activityPlan.nextWeek;\nif (!isObject(nextWeek)) {\n  errors.push('activityPlan.nextWeek must be object');\n} else {\n  reqString(nextWeek, 'phase', 'activityPlan.nextWeek');\n  reqString(nextWeek, 'objective', 'activityPlan.nextWeek');\n  if (!reqString(nextWeek, 'weekStart', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekStart)) {\n    errors.push('activityPlan.nextWeek.weekStart must be YYYY-MM-DD');\n  }\n  if (!reqString(nextWeek, 'weekEnd', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekEnd)) {\n    errors.push('activityPlan.nextWeek.weekEnd must be YYYY-MM-DD');\n  }\n}\n\nconst days = plan.activityPlan && plan.activityPlan.days;\nif (!Array.isArray(days)) {\n  errors.push('activityPlan.days must be array');\n} else if (days.length !== 7) {\n  errors.push('activityPlan.days must have length 7');\n} else {\n  days.forEach((day, idx) => {\n    const path = `activityPlan.days[${idx}]`;\n    if (!isObject(day)) {\n      errors.push(`${path} must be object`);\n      return;\n    }\n    if (!reqString(day, 'day', path) || !dayRe.test(day.day)) {\n      errors.push(`${path}.day must be a valid weekday`);\n    }\n    if (!reqString(day, 'date', path) || !dateRe.test(day.date)) {\n      errors.push(`${path}.date must be YYYY-MM-DD`);\n    }\n    reqString(day, 'activity', path);\n    reqString(day, 'distance_time', path);\n    if (!reqString(day, 'intensity', path) || !intensityRe.test(day.intensity)) {\n      errors.push(`${path}.intensity must include a zone/label or be '-'/'--'/'\u2014'`);\n    }\n    reqString(day, 'goal', path);\n  });\n}\n\n\n// Guardrails (hard rules)\nif (Array.isArray(days) && days.length === 7) {\n  const normalizeDay = (value) => (value || '')\n    .toLowerCase()\n    .replace(/[\u00e1\u00e0\u00e4]/g, 'a')\n    .replace(/[\u00e9\u00e8\u00eb]/g, 'e')\n    .replace(/[\u00ed\u00ec\u00ef]/g, 'i')\n    .replace(/[\u00f3\u00f2\u00f6]/g, 'o')\n    .replace(/[\u00fa\u00f9\u00fc]/g, 'u')\n    .replace(/\u00f1/g, 'n');\n  const activityText = (day) => `${day.activity || ''} ${day.goal || ''} ${day.note || ''}`.toLowerCase();\n  const intensityText = (day) => (day.intensity || '').toLowerCase();\n  const containsToken = (text, tokens) => tokens.some((token) => text.includes(token));\n\n  const hardTokens = ['z4', 'z5', 'vo2', 'interval', 'umbral', 'tempo', 'threshold'];\n  const easyTokens = ['z1', 'z2', 'easy', 'recovery', 'recuper', 'suave'];\n  const restTokens = ['descanso', 'rest', 'off'];\n  const longTokens = ['tirada', 'larga', 'long'];\n  const gymTokens = ['gimnasio', 'gym', 'fuerza', 'strength'];\n\n  const isHard = (day) => containsToken(intensityText(day), hardTokens) || containsToken(activityText(day), hardTokens);\n  const isEasy = (day) => containsToken(intensityText(day), easyTokens) || containsToken(activityText(day), easyTokens);\n  const isRest = (day) => containsToken(activityText(day), restTokens) || ['-', '--', '\u2014', '\u2013'].includes((day.intensity || '').trim());\n  const normalizedDays = days.map((day) => normalizeDay(day.day));\n  const uniqueDays = new Set(normalizedDays);\n  if (uniqueDays.size !== 7) {\n    errors.push('guardrail: days must cover all weekdays exactly once');\n  }\n  const requiredDays = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'];\n  requiredDays.forEach((name) => {\n    if (!uniqueDays.has(name)) {\n      errors.push(`guardrail: missing weekday ${name}`);\n    }\n  });\n\n  const isLong = (day) => containsToken(activityText(day), longTokens);\n\n  const hardCount = days.filter(isHard).length;\n  if (hardCount > 2) {\n    errors.push(`guardrail: too many hard sessions (${hardCount} > 2)`);\n  }\n\n  for (let i = 1; i < days.length; i += 1) {\n    if (isHard(days[i]) && isHard(days[i - 1])) {\n      errors.push(`guardrail: back-to-back hard sessions (days ${i} and ${i + 1})`);\n    }\n  }\n\n  const hasRecovery = days.some((day) => isRest(day) || isEasy(day));\n  if (!hasRecovery) {\n    errors.push('guardrail: must include at least one rest or recovery day');\n  }\n\n  const longCount = days.filter(isLong).length;\n  if (longCount > 1) {\n    errors.push('guardrail: only one long run per week');\n  }\n\n  days.forEach((day, idx) => {\n    if (isLong(day) && isHard(day)) {\n      errors.push(`guardrail: long run cannot be hard intensity (day ${idx + 1})`);\n    }\n  });\n\n  const gymDays = ['martes', 'jueves', 'sabado'];\n  gymDays.forEach((name) => {\n    const day = days.find((d) => normalizeDay(d.day) === name);\n    if (day && !containsToken(activityText(day), gymTokens)) {\n      errors.push(`guardrail: ${name} should include gym/strength`);\n    }\n  });\n}\nconst valid = errors.length == 0;\n\nconst output = isObject(plan) ? JSON.parse(JSON.stringify(plan)) : {};\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\n\noutput.__valid = valid;\noutput.__errors = errors;\noutput.__attempt = attempt;\noutput.__raw = typeof raw === 'string' ? raw : JSON.stringify(raw);\nif (runContext.runId) output.__runId = runContext.runId;\nif (runContext.promptVersion) output.__promptVersion = runContext.promptVersion;\nif (runContext.modelId) output.__modelId = runContext.modelId;\n\nreturn [{ json: output }];\n"
      }
    },
    {
      "id": "fa78a02f-56e7-4eb7-9abe-13ee6d7391b0",
      "name": "Is WeeklyPlan valid? (attempt 1)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1960,
        620
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.__valid }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "82fbdd65-c54a-431a-b4af-7a0dec970aba",
      "name": "Build Repair Prompt (attempt 2)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1960,
        800
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 2;\nconst raw = items[0].json.__raw || JSON.stringify(items[0].json || {});\nconst errors = items[0].json.__errors || [];\n\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst runId = runContext.runId || null;\nconst promptVersion = runContext.promptVersion || null;\nconst modelId = runContext.modelId || null;\n\nconst schemaSnippet = `{\n  \"schema_version\": \"1.0\",\n  \"activityPlan\": {\n    \"nextWeek\": { \"phase\": \"...\", \"objective\": \"...\", \"weekStart\": \"YYYY-MM-DD\", \"weekEnd\": \"YYYY-MM-DD\" },\n    \"days\": [\n      { \"day\": \"Lunes\", \"date\": \"YYYY-MM-DD\", \"activity\": \"...\", \"distance_time\": \"...\", \"intensity\": \"Z1-Z5\", \"goal\": \"...\", \"note\": \"...\" }\n    ]\n  },\n  \"justification\": [\"...\"]\n}`;\n\nconst repair_prompt = `You must return ONLY a valid minified JSON object that matches this schema snippet:\\n${schemaSnippet}\\n\\nInvalid output:\\n${raw}\\n\\nValidation errors:\\n${errors.join('\\n')}`;\n\nreturn [{ json: { repair_prompt, __attempt: attempt, __errors: errors, __raw: raw, runId, promptVersion, modelId } }];\n"
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a JSON repair bot. Return only valid minified JSON."
            },
            {
              "role": "user",
              "content": "={{ $json.repair_prompt }}"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        2160,
        800
      ],
      "id": "6001c0c9-0433-4398-b371-ef28ba5f7a0d",
      "name": "Repair Plan 2",
      "alwaysOutputData": false,
      "credentials": {
        "openAiApi": {
          "id": "olyatB4PnLtBz9VL",
          "name": "OpenAi account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "fb318502-d4da-4197-8708-51e0946a6a5b",
      "name": "Validate WeeklyPlan (attempt 2)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2360,
        800
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 2;\n\nconst raw = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nlet parsed = raw;\nlet parseError = null;\n\nif (typeof raw === 'string') {\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    parseError = err && err.message ? err.message : String(err);\n    parsed = null;\n  }\n}\n\nconst errors = [];\n\nif (parseError) {\n  errors.push(`invalid_json: ${parseError}`);\n}\n\nconst isObject = value => value && typeof value === 'object' && !Array.isArray(value);\nconst plan = isObject(parsed) ? parsed : {};\n\nconst dateRe = /^\\d{4}-\\d{2}-\\d{2}$/;\nconst dayRe = /^(Lunes|Martes|Miercoles|Mi\\u00e9rcoles|Jueves|Viernes|Sabado|S\\u00e1bado|Domingo)$/;\nconst intensityRe = /^(?:-|--|\\u2014|.*\\b(Z[1-5]|interval|Interval|VO2|Tempo|tempo|Umbral|umbral|Threshold|threshold|Easy|easy|Recovery|recovery)\\b.*)$/;\n\nconst reqString = (obj, key, path) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string' || !value.trim()) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  return true;\n};\n\nif (plan.schema_version !== '1.0') {\n  errors.push('schema_version must be \"1.0\"');\n}\n\nif (!isObject(plan.activityPlan)) {\n  errors.push('activityPlan must be object');\n}\n\nconst nextWeek = plan.activityPlan && plan.activityPlan.nextWeek;\nif (!isObject(nextWeek)) {\n  errors.push('activityPlan.nextWeek must be object');\n} else {\n  reqString(nextWeek, 'phase', 'activityPlan.nextWeek');\n  reqString(nextWeek, 'objective', 'activityPlan.nextWeek');\n  if (!reqString(nextWeek, 'weekStart', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekStart)) {\n    errors.push('activityPlan.nextWeek.weekStart must be YYYY-MM-DD');\n  }\n  if (!reqString(nextWeek, 'weekEnd', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekEnd)) {\n    errors.push('activityPlan.nextWeek.weekEnd must be YYYY-MM-DD');\n  }\n}\n\nconst days = plan.activityPlan && plan.activityPlan.days;\nif (!Array.isArray(days)) {\n  errors.push('activityPlan.days must be array');\n} else if (days.length !== 7) {\n  errors.push('activityPlan.days must have length 7');\n} else {\n  days.forEach((day, idx) => {\n    const path = `activityPlan.days[${idx}]`;\n    if (!isObject(day)) {\n      errors.push(`${path} must be object`);\n      return;\n    }\n    if (!reqString(day, 'day', path) || !dayRe.test(day.day)) {\n      errors.push(`${path}.day must be a valid weekday`);\n    }\n    if (!reqString(day, 'date', path) || !dateRe.test(day.date)) {\n      errors.push(`${path}.date must be YYYY-MM-DD`);\n    }\n    reqString(day, 'activity', path);\n    reqString(day, 'distance_time', path);\n    if (!reqString(day, 'intensity', path) || !intensityRe.test(day.intensity)) {\n      errors.push(`${path}.intensity must include a zone/label or be '-'/'--'/'\u2014'`);\n    }\n    reqString(day, 'goal', path);\n  });\n}\n\n\n// Guardrails (hard rules)\nif (Array.isArray(days) && days.length === 7) {\n  const normalizeDay = (value) => (value || '')\n    .toLowerCase()\n    .replace(/[\u00e1\u00e0\u00e4]/g, 'a')\n    .replace(/[\u00e9\u00e8\u00eb]/g, 'e')\n    .replace(/[\u00ed\u00ec\u00ef]/g, 'i')\n    .replace(/[\u00f3\u00f2\u00f6]/g, 'o')\n    .replace(/[\u00fa\u00f9\u00fc]/g, 'u')\n    .replace(/\u00f1/g, 'n');\n  const activityText = (day) => `${day.activity || ''} ${day.goal || ''} ${day.note || ''}`.toLowerCase();\n  const intensityText = (day) => (day.intensity || '').toLowerCase();\n  const containsToken = (text, tokens) => tokens.some((token) => text.includes(token));\n\n  const hardTokens = ['z4', 'z5', 'vo2', 'interval', 'umbral', 'tempo', 'threshold'];\n  const easyTokens = ['z1', 'z2', 'easy', 'recovery', 'recuper', 'suave'];\n  const restTokens = ['descanso', 'rest', 'off'];\n  const longTokens = ['tirada', 'larga', 'long'];\n  const gymTokens = ['gimnasio', 'gym', 'fuerza', 'strength'];\n\n  const isHard = (day) => containsToken(intensityText(day), hardTokens) || containsToken(activityText(day), hardTokens);\n  const isEasy = (day) => containsToken(intensityText(day), easyTokens) || containsToken(activityText(day), easyTokens);\n  const isRest = (day) => containsToken(activityText(day), restTokens) || ['-', '--', '\u2014', '\u2013'].includes((day.intensity || '').trim());\n  const normalizedDays = days.map((day) => normalizeDay(day.day));\n  const uniqueDays = new Set(normalizedDays);\n  if (uniqueDays.size !== 7) {\n    errors.push('guardrail: days must cover all weekdays exactly once');\n  }\n  const requiredDays = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'];\n  requiredDays.forEach((name) => {\n    if (!uniqueDays.has(name)) {\n      errors.push(`guardrail: missing weekday ${name}`);\n    }\n  });\n\n  const isLong = (day) => containsToken(activityText(day), longTokens);\n\n  const hardCount = days.filter(isHard).length;\n  if (hardCount > 2) {\n    errors.push(`guardrail: too many hard sessions (${hardCount} > 2)`);\n  }\n\n  for (let i = 1; i < days.length; i += 1) {\n    if (isHard(days[i]) && isHard(days[i - 1])) {\n      errors.push(`guardrail: back-to-back hard sessions (days ${i} and ${i + 1})`);\n    }\n  }\n\n  const hasRecovery = days.some((day) => isRest(day) || isEasy(day));\n  if (!hasRecovery) {\n    errors.push('guardrail: must include at least one rest or recovery day');\n  }\n\n  const longCount = days.filter(isLong).length;\n  if (longCount > 1) {\n    errors.push('guardrail: only one long run per week');\n  }\n\n  days.forEach((day, idx) => {\n    if (isLong(day) && isHard(day)) {\n      errors.push(`guardrail: long run cannot be hard intensity (day ${idx + 1})`);\n    }\n  });\n\n  const gymDays = ['martes', 'jueves', 'sabado'];\n  gymDays.forEach((name) => {\n    const day = days.find((d) => normalizeDay(d.day) === name);\n    if (day && !containsToken(activityText(day), gymTokens)) {\n      errors.push(`guardrail: ${name} should include gym/strength`);\n    }\n  });\n}\nconst valid = errors.length == 0;\n\nconst output = isObject(plan) ? JSON.parse(JSON.stringify(plan)) : {};\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\n\noutput.__valid = valid;\noutput.__errors = errors;\noutput.__attempt = attempt;\noutput.__raw = typeof raw === 'string' ? raw : JSON.stringify(raw);\nif (runContext.runId) output.__runId = runContext.runId;\nif (runContext.promptVersion) output.__promptVersion = runContext.promptVersion;\nif (runContext.modelId) output.__modelId = runContext.modelId;\n\nreturn [{ json: output }];\n"
      }
    },
    {
      "id": "512261fd-832f-4c54-b584-199df7c8a2e5",
      "name": "Is WeeklyPlan valid? (attempt 2)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2560,
        800
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.__valid }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "60ab564c-0d54-46ac-857f-17eaa539b4bc",
      "name": "Fallback Trigger",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2760,
        980
      ],
      "parameters": {
        "jsCode": "throw new Error('Fallback required after max repair attempts.');"
      }
    },
    {
      "id": "1a5427aa-0afa-409b-bbda-2c0808182bbf",
      "name": "Build Run Event (success)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1268,
        328
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst plan = content.activityPlan || {};\nconst nextWeek = plan.nextWeek || {};\n\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst runId = runContext.runId || content.runId || `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\n\nconst feedbackSummary = runContext.feedbackSummary && typeof runContext.feedbackSummary === 'object'\n  ? runContext.feedbackSummary\n  : null;\nconst adaptationTriggers = Array.isArray(feedbackSummary && feedbackSummary.adaptationTriggers)\n  ? feedbackSummary.adaptationTriggers\n  : [];\nconst adaptationReasons = Array.isArray(feedbackSummary && feedbackSummary.adaptationReasons)\n  ? feedbackSummary.adaptationReasons\n  : [];\n\nconst createdAt = new Date().toISOString();\nconst startedAtRaw = runContext.createdAt || content.createdAt || createdAt;\nconst startedAtTs = new Date(startedAtRaw).getTime();\nconst runDurationMs = Number.isFinite(startedAtTs)\n  ? Math.max(Date.now() - startedAtTs, 0)\n  : 0;\n\nconst structuredLogRequiredFields = ['run_id', 'node_name', 'duration_ms', 'status', 'error_type'];\n\nconst buildLog = (nodeName, status, errorType = null, durationMs = runDurationMs) => ({\n  run_id: runId,\n  runId,\n  node_name: String(nodeName),\n  duration_ms: Math.max(Number(durationMs) || 0, 0),\n  status: String(status),\n  error_type: errorType == null ? null : String(errorType),\n  timestamp: new Date().toISOString(),\n});\n\nconst structuredLogs = [\n  buildLog('Prompt Builder', 'success', null, Math.round(runDurationMs * 0.2)),\n  buildLog('Message a model', 'success', null, Math.round(runDurationMs * 0.35)),\n  buildLog('Validate WeeklyPlan', 'success', null, Math.round(runDurationMs * 0.25)),\n  buildLog('Build Telegram Message', 'success', null, Math.round(runDurationMs * 0.2)),\n];\n\nconst hasAllRequiredFields = (entry) => structuredLogRequiredFields.every((field) => Object.prototype.hasOwnProperty.call(entry, field));\nconst validStructuredLogCount = structuredLogs.filter((entry) => hasAllRequiredFields(entry)).length;\nconst structuredLogCoverageRate = structuredLogs.length\n  ? validStructuredLogCount / structuredLogs.length\n  : 0;\n\nconst rawAttempt = Number(content.__attempt);\nconst retryCount = Number.isFinite(rawAttempt) ? Math.max(Math.trunc(rawAttempt), 0) : 0;\n\nconst validationNodeNames = [\n  'Validate WeeklyPlan (attempt 0)',\n  'Validate WeeklyPlan (attempt 1)',\n  'Validate WeeklyPlan (attempt 2)',\n];\nconst startsWithInvalidJson = (value) => String(value || '').toLowerCase().startsWith('invalid_json');\nconst validationAttempts = validationNodeNames\n  .flatMap((nodeName) => {\n    try {\n      const nodeItems = $items(nodeName);\n      return Array.isArray(nodeItems) ? nodeItems : [];\n    } catch {\n      return [];\n    }\n  })\n  .map((item) => (item && item.json && typeof item.json === 'object' ? item.json : null))\n  .filter((payload) => payload && (!runId || !payload.__runId || String(payload.__runId) === String(runId)));\n\nconst validationAttemptCount = validationAttempts.length > 0\n  ? validationAttempts.length\n  : (retryCount + 1);\nconst invalidJsonCount = validationAttempts.length > 0\n  ? validationAttempts.filter((payload) => Array.isArray(payload.__errors) && payload.__errors.some(startsWithInvalidJson)).length\n  : errors.filter(startsWithInvalidJson).length;\nconst invalidJsonRate = validationAttemptCount > 0 ? invalidJsonCount / validationAttemptCount : 0;\n\nconst coreMetrics = {\n  successRate: 1,\n  retryCount,\n  validationAttemptCount,\n  invalidJsonCount,\n  invalidJsonRate,\n  latencyMs: runDurationMs,\n  status: 'success',\n};\n\nconst coreMetricThresholds = {\n  minSuccessRate: 0.95,\n  maxRetries: 1,\n  maxInvalidJsonRate: 0.05,\n  maxLatencyMs: 120000,\n};\n\nconst coreMetricBreaches = [];\nif (coreMetrics.successRate < coreMetricThresholds.minSuccessRate) {\n  coreMetricBreaches.push('successRate');\n}\nif (coreMetrics.retryCount > coreMetricThresholds.maxRetries) {\n  coreMetricBreaches.push('retries');\n}\nif (coreMetrics.invalidJsonRate > coreMetricThresholds.maxInvalidJsonRate) {\n  coreMetricBreaches.push('invalid_json_rate');\n}\nif (coreMetrics.latencyMs > coreMetricThresholds.maxLatencyMs) {\n  coreMetricBreaches.push('latency');\n}\n\nconst coreMetricsReport = {\n  reportVersion: '1.0',\n  generatedAt: createdAt,\n  runId,\n  metrics: coreMetrics,\n  thresholds: coreMetricThresholds,\n  breaches: coreMetricBreaches,\n};\n\nconst runEvent = {\n  runId,\n  status: 'success',\n  attempt: content.__attempt ?? null,\n  weekStart: nextWeek.weekStart || null,\n  weekEnd: nextWeek.weekEnd || null,\n  errorCount: errors.length,\n  errors,\n  feedbackSummary,\n  feedbackAdaptationApplied: adaptationTriggers.length > 0,\n  adaptationTriggerCount: adaptationTriggers.length,\n  adaptationTriggers,\n  adaptationReasons,\n  runDurationMs,\n  structuredLogs,\n  structuredLogRequiredFields,\n  structuredLogCount: structuredLogs.length,\n  structuredLogCoverageRate,\n  structured_log_coverage_rate: structuredLogCoverageRate,\n  coreMetrics,\n  coreMetricThresholds,\n  coreMetricBreaches,\n  coreMetricsReport,\n  createdAt,\n};\n\nreturn [{\n  json: Object.assign({}, content, runEvent, { runEvent })\n}];"
      }
    },
    {
      "id": "76a0bc8d-962a-4fb4-adbd-f5968b5b83eb",
      "name": "Run Events DB (success)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1588,
        328
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_events",
        "updateKey": "runId",
        "fields": "runId, status, attempt, weekStart, weekEnd, errorCount, errors, telegramTemplateVersion, sectionCompleteness, sectionMissingCount, whyThisPlan, whyPlanMetricKeys, whyPlanHallucinationFailures, previewMode, previewChatId, riskWarningTriggerCount, riskWarningTriggers, riskWarningTriggerCounts, riskFeedback, createdAt, feedbackSummary, feedbackAdaptationApplied, adaptationTriggerCount, adaptationTriggers, adaptationReasons, weeklyAdherenceSummary, runDurationMs, structuredLogs, structuredLogRequiredFields, structuredLogCount, structuredLogCoverageRate, structured_log_coverage_rate, coreMetrics, coreMetricThresholds, coreMetricBreaches, coreMetricsReport",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "92307575-ea91-4bac-b23a-1860c54c24c9",
      "name": "Build Failure Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        980
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst plan = content.activityPlan || {};\nconst nextWeek = plan.nextWeek || {};\n\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst runId = runContext.runId || content.runId || `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst errors = Array.isArray(content.__errors) ? content.__errors : ['validation failed'];\n\nconst createdAt = new Date().toISOString();\nconst startedAtRaw = runContext.createdAt || content.createdAt || createdAt;\nconst startedAtTs = new Date(startedAtRaw).getTime();\nconst runDurationMs = Number.isFinite(startedAtTs)\n  ? Math.max(Date.now() - startedAtTs, 0)\n  : 0;\n\nconst normalizeErrorType = (value) => {\n  const text = String(value || '').trim();\n  if (!text) return 'unknown';\n  const firstSegment = text.split(':')[0].trim();\n  if (!firstSegment) return 'unknown';\n  return firstSegment.toLowerCase().replace(/[^a-z0-9_]+/g, '_').replace(/^_+|_+$/g, '') || 'unknown';\n};\n\nconst primaryErrorType = normalizeErrorType(errors[0]);\nconst structuredLogRequiredFields = ['run_id', 'node_name', 'duration_ms', 'status', 'error_type'];\n\nconst buildLog = (nodeName, status, errorType = primaryErrorType, durationMs = runDurationMs) => ({\n  run_id: runId,\n  runId,\n  node_name: String(nodeName),\n  duration_ms: Math.max(Number(durationMs) || 0, 0),\n  status: String(status),\n  error_type: errorType == null ? null : String(errorType),\n  timestamp: new Date().toISOString(),\n});\n\nconst structuredLogs = [\n  buildLog('Validate WeeklyPlan', 'failure', primaryErrorType, Math.round(runDurationMs * 0.5)),\n  buildLog('Build Failure Event', 'failure', primaryErrorType, Math.round(runDurationMs * 0.5)),\n];\n\nconst hasAllRequiredFields = (entry) => structuredLogRequiredFields.every((field) => Object.prototype.hasOwnProperty.call(entry, field));\nconst validStructuredLogCount = structuredLogs.filter((entry) => hasAllRequiredFields(entry)).length;\nconst structuredLogCoverageRate = structuredLogs.length\n  ? validStructuredLogCount / structuredLogs.length\n  : 0;\n\nconst rawAttempt = Number(content.__attempt);\nconst retryCount = Number.isFinite(rawAttempt) ? Math.max(Math.trunc(rawAttempt), 0) : 0;\n\nconst validationNodeNames = [\n  'Validate WeeklyPlan (attempt 0)',\n  'Validate WeeklyPlan (attempt 1)',\n  'Validate WeeklyPlan (attempt 2)',\n];\nconst startsWithInvalidJson = (value) => String(value || '').toLowerCase().startsWith('invalid_json');\nconst validationAttempts = validationNodeNames\n  .flatMap((nodeName) => {\n    try {\n      const nodeItems = $items(nodeName);\n      return Array.isArray(nodeItems) ? nodeItems : [];\n    } catch {\n      return [];\n    }\n  })\n  .map((item) => (item && item.json && typeof item.json === 'object' ? item.json : null))\n  .filter((payload) => payload && (!runId || !payload.__runId || String(payload.__runId) === String(runId)));\n\nconst validationAttemptCount = validationAttempts.length > 0\n  ? validationAttempts.length\n  : (retryCount + 1);\nconst invalidJsonCount = validationAttempts.length > 0\n  ? validationAttempts.filter((payload) => Array.isArray(payload.__errors) && payload.__errors.some(startsWithInvalidJson)).length\n  : errors.filter(startsWithInvalidJson).length;\nconst invalidJsonRate = validationAttemptCount > 0 ? invalidJsonCount / validationAttemptCount : 0;\n\nconst coreMetrics = {\n  successRate: 0,\n  retryCount,\n  validationAttemptCount,\n  invalidJsonCount,\n  invalidJsonRate,\n  latencyMs: runDurationMs,\n  status: 'failure',\n};\n\nconst coreMetricThresholds = {\n  minSuccessRate: 0.95,\n  maxRetries: 1,\n  maxInvalidJsonRate: 0.05,\n  maxLatencyMs: 120000,\n};\n\nconst coreMetricBreaches = [];\nif (coreMetrics.successRate < coreMetricThresholds.minSuccessRate) {\n  coreMetricBreaches.push('successRate');\n}\nif (coreMetrics.retryCount > coreMetricThresholds.maxRetries) {\n  coreMetricBreaches.push('retries');\n}\nif (coreMetrics.invalidJsonRate > coreMetricThresholds.maxInvalidJsonRate) {\n  coreMetricBreaches.push('invalid_json_rate');\n}\nif (coreMetrics.latencyMs > coreMetricThresholds.maxLatencyMs) {\n  coreMetricBreaches.push('latency');\n}\n\nconst coreMetricsReport = {\n  reportVersion: '1.0',\n  generatedAt: createdAt,\n  runId,\n  metrics: coreMetrics,\n  thresholds: coreMetricThresholds,\n  breaches: coreMetricBreaches,\n};\n\nconst runEvent = {\n  runId,\n  status: 'failure',\n  attempt: content.__attempt ?? null,\n  weekStart: nextWeek.weekStart || null,\n  weekEnd: nextWeek.weekEnd || null,\n  errorCount: errors.length,\n  errors,\n  runDurationMs,\n  structuredLogs,\n  structuredLogRequiredFields,\n  structuredLogCount: structuredLogs.length,\n  structuredLogCoverageRate,\n  structured_log_coverage_rate: structuredLogCoverageRate,\n  coreMetrics,\n  coreMetricThresholds,\n  coreMetricBreaches,\n  coreMetricsReport,\n  createdAt,\n};\n\nconst alertMessage = [\n  '\u26a0\ufe0f Running Coach workflow failed',\n  `Run: ${runId}`,\n  `Errors (${errors.length}):`,\n  ...errors.map(err => `- ${err}`)\n].join('\\n');\n\nreturn [{\n  json: Object.assign({}, content, runEvent, { runEvent, alertMessage })\n}];"
      }
    },
    {
      "id": "57d9052d-75a5-468d-a5f8-e61dbd8f7f91",
      "name": "Run Events DB (failure)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        2480,
        980
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_events",
        "updateKey": "runId",
        "fields": "runId, status, attempt, weekStart, weekEnd, errorCount, errors, createdAt, runDurationMs, structuredLogs, structuredLogRequiredFields, structuredLogCount, structuredLogCoverageRate, structured_log_coverage_rate, coreMetrics, coreMetricThresholds, coreMetricBreaches, coreMetricsReport",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "e0eb79f9-5da4-43bb-a51f-230f787624fd",
      "name": "Send Failure Alert",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        2720,
        980
      ],
      "parameters": {
        "chatId": "730354404",
        "text": "={{ $json.alertMessage }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "webhookId": "ae55f720-070b-42e2-b07e-f202cb99ced4",
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "id": "2d8f2e3c-1c6b-4b11-8b6f-6d6a1fcb55a2",
      "name": "Plan Snapshots DB",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1388,
        328
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "plan_snapshots",
        "updateKey": "runId",
        "fields": "runId, attempt, weekStart, weekEnd, schema_version, activityPlan, justification, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "948d6cd7-5470-4427-8cce-914769862399",
      "name": "Run Artifacts DB (inputs)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1088,
        640
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_artifacts",
        "updateKey": "runId",
        "fields": "runId, promptVersion, modelId, prompt, metrics, history, feedbackSummary, activities, wellness, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "3912d34c-0bb2-4073-b920-2a9ce7009bc1",
      "name": "Build Run Artifact (outputs)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        128
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\n\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\nconst outputValidated = content.activityPlan ? {\n  schema_version: content.schema_version,\n  activityPlan: content.activityPlan,\n  justification: content.justification\n} : null;\n\nconst feedbackSummary = runContext.feedbackSummary && typeof runContext.feedbackSummary === 'object'\n  ? runContext.feedbackSummary\n  : null;\nconst adaptationTriggers = Array.isArray(feedbackSummary && feedbackSummary.adaptationTriggers)\n  ? feedbackSummary.adaptationTriggers\n  : [];\n\nconst structuredLogs = Array.isArray(content.structuredLogs)\n  ? content.structuredLogs\n  : [];\nconst structuredLogCoverageRate = typeof content.structuredLogCoverageRate === 'number'\n  ? content.structuredLogCoverageRate\n  : (typeof content.structured_log_coverage_rate === 'number' ? content.structured_log_coverage_rate : null);\nconst structuredLogCount = Number.isInteger(content.structuredLogCount)\n  ? content.structuredLogCount\n  : structuredLogs.length;\n\nconst fallbackAttempt = Number(content.__attempt);\nconst retryCountFallback = Number.isFinite(fallbackAttempt) ? Math.max(Math.trunc(fallbackAttempt), 0) : 0;\n\nconst validationNodeNames = [\n  'Validate WeeklyPlan (attempt 0)',\n  'Validate WeeklyPlan (attempt 1)',\n  'Validate WeeklyPlan (attempt 2)',\n];\nconst startsWithInvalidJson = (value) => String(value || '').toLowerCase().startsWith('invalid_json');\nconst validationAttempts = validationNodeNames\n  .flatMap((nodeName) => {\n    try {\n      const nodeItems = $items(nodeName);\n      return Array.isArray(nodeItems) ? nodeItems : [];\n    } catch {\n      return [];\n    }\n  })\n  .map((item) => (item && item.json && typeof item.json === 'object' ? item.json : null))\n  .filter((payload) => payload && (!runContext.runId || !payload.__runId || String(payload.__runId) === String(runContext.runId)));\n\nconst validationAttemptCountFallback = validationAttempts.length > 0\n  ? validationAttempts.length\n  : (retryCountFallback + 1);\nconst invalidJsonCountFallback = validationAttempts.length > 0\n  ? validationAttempts.filter((payload) => Array.isArray(payload.__errors) && payload.__errors.some(startsWithInvalidJson)).length\n  : errors.filter(startsWithInvalidJson).length;\nconst invalidJsonRateFallback = validationAttemptCountFallback > 0 ? invalidJsonCountFallback / validationAttemptCountFallback : 0;\n\nconst coreMetrics = (content.coreMetrics && typeof content.coreMetrics === 'object')\n  ? content.coreMetrics\n  : {\n      successRate: content.status === 'failure' ? 0 : 1,\n      retryCount: retryCountFallback,\n      validationAttemptCount: validationAttemptCountFallback,\n      invalidJsonCount: invalidJsonCountFallback,\n      invalidJsonRate: invalidJsonRateFallback,\n      latencyMs: Number.isFinite(content.runDurationMs) ? content.runDurationMs : null,\n      status: content.status || (content.__valid ? 'success' : 'failure'),\n    };\n\nconst coreMetricThresholds = (content.coreMetricThresholds && typeof content.coreMetricThresholds === 'object')\n  ? content.coreMetricThresholds\n  : null;\nconst coreMetricBreaches = Array.isArray(content.coreMetricBreaches)\n  ? content.coreMetricBreaches\n  : [];\nconst coreMetricsReport = (content.coreMetricsReport && typeof content.coreMetricsReport === 'object')\n  ? content.coreMetricsReport\n  : null;\n\nreturn [{\n  json: {\n    runId: runContext.runId || content.runId,\n    promptVersion: runContext.promptVersion || null,\n    modelId: runContext.modelId || null,\n    status: content.status || (content.__valid ? 'success' : 'failure'),\n    attempt: content.__attempt ?? null,\n    outputValidated,\n    outputRaw: content.__raw ?? null,\n    errors,\n    errorCount: errors.length,\n    feedbackSummary,\n    adaptationTriggers,\n    runDurationMs: Number.isFinite(content.runDurationMs) ? content.runDurationMs : null,\n    structuredLogs,\n    structuredLogCount,\n    structuredLogCoverageRate,\n    structured_log_coverage_rate: structuredLogCoverageRate,\n    coreMetrics,\n    coreMetricThresholds,\n    coreMetricBreaches,\n    coreMetricsReport,\n    updatedAt: new Date().toISOString()\n  }\n}];"
      }
    },
    {
      "id": "9e28f9fd-c2ae-4df0-9557-1808cc338b53",
      "name": "Run Artifacts DB (outputs)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1712,
        128
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_artifacts",
        "updateKey": "runId",
        "fields": "runId, promptVersion, modelId, status, attempt, outputValidated, outputRaw, errors, errorCount, updatedAt, feedbackSummary, adaptationTriggers, runDurationMs, structuredLogs, structuredLogCount, structuredLogCoverageRate, structured_log_coverage_rate, coreMetrics, coreMetricThresholds, coreMetricBreaches, coreMetricsReport",
        "upsert": true,
        "options": {
          "dateFields": "updatedAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "3623b766-3f29-4593-b706-255a8becd8c3",
      "name": "Build Feedback Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        448
      ],
      "parameters": {
        "jsCode": "const DEFAULT_CHAT_ID = '730354404';\n\nconst getVar = (key) => {\n  if (typeof $vars !== 'undefined' && $vars[key] != null) {\n    return String($vars[key]);\n  }\n  if (typeof process !== 'undefined' && process.env && process.env[key] != null) {\n    return String(process.env[key]);\n  }\n  return '';\n};\n\nconst isTruthy = (value) => ['1', 'true', 'yes', 'on'].includes(String(value).toLowerCase());\n\nconst previewEnabled = isTruthy(getVar('RC_TELEGRAM_PREVIEW_MODE'));\nconst previewChatRaw = getVar('RC_TELEGRAM_PREVIEW_CHAT_ID').trim();\nif (previewEnabled && !previewChatRaw) {\n  throw new Error('RC_TELEGRAM_PREVIEW_CHAT_ID is required when RC_TELEGRAM_PREVIEW_MODE is enabled.');\n}\nconst targetChatId = previewEnabled ? previewChatRaw : DEFAULT_CHAT_ID;\n\nconst runContextItems = $items('Prompt Builder');\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst plan = $json.activityPlan || {};\nconst nextWeek = plan.nextWeek || {};\nconst runId = (runContext.runId || $json.runId || ($json.runEvent && $json.runEvent.runId) || $json.__runId || null);\nif (!runId) { return []; }\n\nconst weekLabel = (nextWeek.weekStart && nextWeek.weekEnd) ? `${nextWeek.weekStart} \u2192 ${nextWeek.weekEnd}` : 'this week';\nconst text = [\n  previewEnabled ? '\ud83e\uddea <b>Preview mode</b>' : null,\n  `\ud83d\udcdd <b>Quick feedback</b> (${weekLabel})`,\n  'How did your latest session feel?',\n  'Tap one option:'\n].filter(Boolean).join('\\n');\n\nconst replyMarkup = {\n  inline_keyboard: [\n    [{ text: '\u2705 Done', callback_data: `feedback|${runId}|done` }],\n    [{ text: '\u274c Skipped', callback_data: `feedback|${runId}|skipped` }],\n    [{ text: '\ud83d\ude35 Hard', callback_data: `feedback|${runId}|hard` }],\n    [{ text: '\ud83e\uddb5 Pain', callback_data: `feedback|${runId}|pain` }],\n  ]\n};\n\nreturn [{\n  json: {\n    chatId: targetChatId,\n    text,\n    replyMarkup,\n    runId,\n    previewMode: previewEnabled,\n    previewChatId: targetChatId,\n  }\n}];\n"
      }
    },
    {
      "id": "81adaf55-23cc-466c-8876-c4ff27f4073b",
      "name": "Send Feedback Prompt",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        2000,
        448
      ],
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "parse_mode": "HTML",
          "replyMarkup": "={{ JSON.stringify($json.replyMarkup) }}"
        }
      },
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "id": "d2b2cc48-5fe2-4dac-8bd5-5edfc8984a54",
      "name": "Telegram Feedback Trigger",
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1,
      "position": [
        -200,
        -200
      ],
      "parameters": {
        "updates": [
          "callback_query"
        ]
      },
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "id": "4febcf54-ca29-4bdb-b2f4-e28c880f9b95",
      "name": "Parse Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -200
      ],
      "parameters": {
        "jsCode": "const update = items[0].json || {};\nconst callback = update.callback_query || update.body?.callback_query || null;\nif (!callback || !callback.data) { return []; }\n\nconst parts = String(callback.data).split('|');\nif (parts[0] !== 'feedback' || parts.length < 3) { return []; }\n\nconst runId = parts[1];\nconst type = parts[2].toLowerCase().trim();\nconst allowedTypes = new Set(['done', 'skipped', 'hard', 'pain']);\nif (!allowedTypes.has(type)) { return []; }\n\nconst noteRaw = parts.length > 3 ? parts.slice(3).join('|') : '';\nconst decodeNote = (value) => {\n  try {\n    return decodeURIComponent(value);\n  } catch {\n    return value;\n  }\n};\nconst noteDecoded = noteRaw ? decodeNote(noteRaw) : '';\nconst note = noteDecoded.trim() || null;\n\nconst message = callback.message || {};\nconst chatId = message.chat && message.chat.id ? String(message.chat.id) : null;\nconst messageId = message.message_id || null;\nconst messageDate = message.date ? new Date(message.date * 1000) : new Date();\nconst now = new Date();\nconst nowIso = now.toISOString();\nconst sessionDate = messageDate.toISOString().slice(0, 10);\nconst sessionDay = messageDate.toLocaleDateString('en-US', { weekday: 'long' });\nconst promptAgeDays = Math.floor(Math.max(now.getTime() - messageDate.getTime(), 0) / 86400000);\nconst isLateResponse = promptAgeDays > 14;\n\nconst user = callback.from || {};\nconst userId = user.id || null;\nconst sessionRef = `${runId}-${messageId || sessionDate}`;\nconst sessionKey = `${sessionRef}-${userId || 'anon'}`;\n\nreturn [{\n  json: {\n    sessionKey,\n    sessionRef,\n    runId,\n    type,\n    response: type,\n    note,\n    sessionDate,\n    date: sessionDate,\n    sessionDay,\n    day: sessionDay,\n    chatId,\n    messageId,\n    userId,\n    username: user.username || null,\n    promptSentAt: messageDate.toISOString(),\n    promptAgeDays,\n    isLateResponse,\n    timestamp: nowIso,\n    receivedAt: nowIso,\n  }\n}];\n"
      }
    },
    {
      "id": "71c41d55-4ed9-4934-ad94-1d6044774104",
      "name": "Feedback Events DB",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        220,
        -200
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "feedback_events",
        "updateKey": "sessionKey",
        "fields": "sessionKey, sessionRef, runId, type, response, note, sessionDate, date, sessionDay, day, chatId, messageId, userId, username, promptSentAt, promptAgeDays, isLateResponse, timestamp, receivedAt",
        "upsert": true,
        "options": {
          "dateFields": "timestamp,receivedAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "3c6afed0-56fe-4a6c-b0f2-59fee294b969",
      "name": "Send Feedback Ack",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        440,
        -200
      ],
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.isLateResponse ? `\u26a0\ufe0f Feedback ignored: this prompt is ${$json.promptAgeDays} days old. Please answer from your latest weekly message.` : `\u2705 Feedback saved: ${$json.type || $json.response}` }}"
      },
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "collection": "feedback_events",
        "options": {
          "sort": "{ \"receivedAt\": -1 }"
        },
        "query": "={\n  \"$or\": [\n    {\n      \"type\": \"pain\"\n    },\n    {\n      \"response\": \"pain\"\n    }\n  ]\n}\n"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1320,
        620
      ],
      "id": "ac9f5d41-e9e0-4f3c-96af-185f56cb29ce",
      "name": "Read Recent Pain Feedback",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const RISK_WINDOW_DAYS = 14;\nconst cutoffMs = Date.now() - (RISK_WINDOW_DAYS * 24 * 60 * 60 * 1000);\nconst DEFAULT_CHAT_ID = '730354404';\n\nconst getVar = (key) => {\n  if (typeof $vars !== 'undefined' && $vars[key] != null) {\n    return String($vars[key]);\n  }\n  if (typeof process !== 'undefined' && process.env && process.env[key] != null) {\n    return String(process.env[key]);\n  }\n  return '';\n};\n\nconst isTruthy = (value) => ['1', 'true', 'yes', 'on'].includes(String(value).toLowerCase());\n\nconst previewEnabled = isTruthy(getVar('RC_TELEGRAM_PREVIEW_MODE'));\nconst previewChatRaw = getVar('RC_TELEGRAM_PREVIEW_CHAT_ID').trim();\nif (previewEnabled && !previewChatRaw) {\n  throw new Error('RC_TELEGRAM_PREVIEW_CHAT_ID is required when RC_TELEGRAM_PREVIEW_MODE is enabled.');\n}\nconst targetChatId = previewEnabled ? previewChatRaw : DEFAULT_CHAT_ID;\n\nconst docs = items\n  .map((item) => item.json || {})\n  .filter((doc) => doc && Object.keys(doc).length > 0);\n\nconst docsForChat = docs.filter((doc) => String(doc.chatId || '') === targetChatId);\n\nconst toTs = (value) => {\n  const ts = new Date(value || 0).getTime();\n  return Number.isFinite(ts) ? ts : null;\n};\n\nconst painDocs = docsForChat.filter((doc) => {\n  const responseType = String(doc.type || doc.response || '').toLowerCase();\n  if (responseType !== 'pain') return false;\n  const ts = toTs(doc.receivedAt || doc.timestamp || doc.sessionDate);\n  return ts !== null && ts >= cutoffMs;\n});\n\nconst latestPain = [...painDocs].sort((a, b) => {\n  const aTs = toTs(a.receivedAt || a.timestamp || a.sessionDate) || 0;\n  const bTs = toTs(b.receivedAt || b.timestamp || b.sessionDate) || 0;\n  return bTs - aTs;\n})[0] || null;\n\nconst baseItems = $items('Build Run Event (success)');\nconst basePayload = baseItems.length ? (baseItems[0].json || {}) : {};\n\nconst riskFeedback = {\n  chatId: targetChatId,\n  hasRecentPain: painDocs.length > 0,\n  painEventCount: painDocs.length,\n  latestPainDate: latestPain ? (latestPain.sessionDate || String(latestPain.receivedAt || latestPain.timestamp || '').slice(0, 10)) : null,\n  windowDays: RISK_WINDOW_DAYS,\n};\n\nreturn [{\n  json: Object.assign({}, basePayload, { riskFeedback }),\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        620
      ],
      "id": "799a0656-9818-4e74-9046-5c70b2898757",
      "name": "Summarize Pain Feedback"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isLateResponse }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        220,
        -320
      ],
      "id": "f0b90789-89af-4b90-a1a5-df6507a43f63",
      "name": "Is Feedback Late?"
    },
    {
      "id": "e2034a41-23b2-4eff-aa0c-3baad42ad4b3",
      "name": "Daily Reminder Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1600,
        940
      ],
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 * * * * *"
            }
          ]
        }
      }
    },
    {
      "id": "4d025492-9aeb-4e68-b607-8bc0f91eec5a",
      "name": "Build Reminder Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1360,
        940
      ],
      "parameters": {
        "jsCode": "const DEFAULT_CHAT_ID = '730354404';\nconst DEFAULT_REMINDER_TIME = '08:00';\nconst DEFAULT_REMINDER_TIMEZONE = 'Europe/Madrid';\n\nconst getVar = (key) => {\n  if (typeof $vars !== 'undefined' && $vars[key] != null) {\n    return String($vars[key]);\n  }\n  if (typeof $env !== 'undefined' && $env[key] != null) {\n    return String($env[key]);\n  }\n  if (typeof process !== 'undefined' && process.env && process.env[key] != null) {\n    return String(process.env[key]);\n  }\n  return '';\n};\n\nconst isTruthy = (value) => ['1', 'true', 'yes', 'on'].includes(String(value).toLowerCase());\n\nconst isValidTime = (value) => /^([01]\\d|2[0-3]):([0-5]\\d)$/.test(value);\n\nconst getLocalNow = (timeZone) => {\n  const now = new Date();\n  const formatter = new Intl.DateTimeFormat('en-CA', {\n    timeZone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: false,\n    weekday: 'long',\n  });\n\n  const parts = formatter.formatToParts(now).reduce((acc, part) => {\n    if (part.type !== 'literal') {\n      acc[part.type] = part.value;\n    }\n    return acc;\n  }, {});\n\n  return {\n    iso: now.toISOString(),\n    date: `${parts.year}-${parts.month}-${parts.day}`,\n    time: `${parts.hour}:${parts.minute}`,\n    weekday: parts.weekday || '',\n  };\n};\n\nconst previewEnabled = isTruthy(getVar('RC_TELEGRAM_PREVIEW_MODE'));\nconst previewChatRaw = getVar('RC_TELEGRAM_PREVIEW_CHAT_ID').trim();\nif (previewEnabled && !previewChatRaw) {\n  throw new Error('RC_TELEGRAM_PREVIEW_CHAT_ID is required when RC_TELEGRAM_PREVIEW_MODE is enabled.');\n}\n\nconst reminderEnabled = isTruthy(getVar('RC_REMINDER_ENABLED'));\nif (!reminderEnabled) {\n  return [];\n}\n\nconst reminderTime = (getVar('RC_REMINDER_TIME').trim() || DEFAULT_REMINDER_TIME);\nif (!isValidTime(reminderTime)) {\n  throw new Error('RC_REMINDER_TIME must use HH:MM (24-hour) format.');\n}\n\nconst reminderTimezone = getVar('RC_REMINDER_TIMEZONE').trim() || DEFAULT_REMINDER_TIMEZONE;\nlet localNow;\ntry {\n  localNow = getLocalNow(reminderTimezone);\n} catch (error) {\n  throw new Error(`Invalid reminder timezone: ${reminderTimezone}`);\n}\n\nconst forceSend = isTruthy(getVar('RC_REMINDER_FORCE_SEND'));\nif (!forceSend && localNow.time !== reminderTime) {\n  return [];\n}\n\nconst targetChatId = previewEnabled ? previewChatRaw : DEFAULT_CHAT_ID;\nconst runId = `reminder-${localNow.date}-${Math.random().toString(36).slice(2, 10)}`;\n\nreturn [{\n  json: {\n    runId,\n    status: 'reminder',\n    createdAt: localNow.iso,\n    chatId: targetChatId,\n    previewMode: previewEnabled,\n    previewChatId: targetChatId,\n    reminderEnabled,\n    reminderDate: localNow.date,\n    reminderWeekday: localNow.weekday,\n    reminderTime,\n    reminderTimezone,\n    reminderForceSend: forceSend,\n    reminderKey: `${targetChatId}:${localNow.date}`,\n    reminderOptInUsersCount: 1,\n    reminder_opt_in_users_count: 1,\n  }\n}];"
      }
    },
    {
      "id": "45ff64d9-b51c-41cc-9ade-fa060185d1c8",
      "name": "Read Latest Plan Snapshot",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -1120,
        940
      ],
      "alwaysOutputData": true,
      "parameters": {
        "collection": "plan_snapshots",
        "options": {
          "sort": "{ \"createdAt\": -1 }"
        },
        "query": "={\n  \"activityPlan\": {\n    \"$exists\": true\n  }\n}\n"
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "376db49c-8b14-46e5-883f-04e1492745f2",
      "name": "Read Reminder Sends Today",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -880,
        940
      ],
      "alwaysOutputData": true,
      "parameters": {
        "collection": "reminder_events",
        "options": {
          "sort": "{ \"createdAt\": -1 }"
        },
        "query": "={\n  \"chatId\": \"{{ $items('Build Reminder Context')[0].json.chatId }}\",\n  \"reminderDate\": \"{{ $items('Build Reminder Context')[0].json.reminderDate }}\",\n  \"deliveryStatus\": \"sent\"\n}\n"
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "9c968705-5e90-4782-abaa-c3ecc83f6e50",
      "name": "Build Reminder Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -640,
        940
      ],
      "parameters": {
        "jsCode": "const contextItems = $items('Build Reminder Context');\nif (!contextItems.length) {\n  return [];\n}\n\nconst context = contextItems[0].json || {};\n\nconst snapshotDocs = $items('Read Latest Plan Snapshot')\n  .map((item) => item.json || {})\n  .filter((doc) => doc && Object.keys(doc).length > 0);\n\nconst sentDocs = items\n  .map((item) => item.json || {})\n  .filter((doc) => doc && Object.keys(doc).length > 0);\n\nconst planSnapshot = snapshotDocs[0] || {};\nconst activityPlan = (planSnapshot.activityPlan && typeof planSnapshot.activityPlan === 'object')\n  ? planSnapshot.activityPlan\n  : {};\nconst days = Array.isArray(activityPlan.days) ? activityPlan.days : [];\n\nconst normalizeDay = (value) => {\n  const text = String(value || '').trim().toLowerCase();\n  if (!text) return '';\n  const map = {\n    monday: 'monday',\n    lunes: 'monday',\n    tuesday: 'tuesday',\n    martes: 'tuesday',\n    wednesday: 'wednesday',\n    miercoles: 'wednesday',\n    'mi\u00e9rcoles': 'wednesday',\n    thursday: 'thursday',\n    jueves: 'thursday',\n    friday: 'friday',\n    viernes: 'friday',\n    saturday: 'saturday',\n    sabado: 'saturday',\n    's\u00e1bado': 'saturday',\n    sunday: 'sunday',\n    domingo: 'sunday',\n  };\n  return map[text] || text;\n};\n\nconst todayDayKey = normalizeDay(context.reminderWeekday);\nlet session = days.find((day) => String(day.date || '') === String(context.reminderDate || '')) || null;\nif (!session && todayDayKey) {\n  session = days.find((day) => normalizeDay(day.day) === todayDayKey) || null;\n}\n\nconst alreadySent = sentDocs.length > 0;\nlet shouldSend = false;\nlet deliveryStatus = 'skipped';\nlet deliveryReason = 'unknown';\n\nif (!Array.isArray(days) || days.length === 0) {\n  deliveryStatus = 'skipped_no_plan';\n  deliveryReason = 'missing_plan_days';\n} else if (!session) {\n  deliveryStatus = 'skipped_no_session';\n  deliveryReason = 'missing_daily_session';\n} else if (alreadySent) {\n  deliveryStatus = 'skipped_already_sent';\n  deliveryReason = 'already_sent_today';\n} else {\n  shouldSend = true;\n  deliveryStatus = 'pending';\n  deliveryReason = 'ready_to_send';\n}\n\nconst esc = (value) => String(value || '')\n  .replace(/&/g, '&amp;')\n  .replace(/</g, '&lt;')\n  .replace(/>/g, '&gt;');\n\nconst lines = [\n  context.previewMode ? '\ud83e\uddea <b>Preview mode</b>' : null,\n  `\u23f0 <b>Training reminder</b> (${esc(context.reminderDate)})`,\n];\n\nif (session) {\n  lines.push(`\ud83c\udfc3 <b>${esc(session.activity || 'Session')}</b>`);\n  if (session.distance_time) {\n    lines.push(`Duration: ${esc(session.distance_time)}`);\n  }\n  if (session.intensity && session.intensity !== '-') {\n    lines.push(`Intensity: ${esc(session.intensity)}`);\n  }\n  if (session.goal) {\n    lines.push(`Goal: ${esc(session.goal)}`);\n  }\n  if (session.note) {\n    lines.push(`Note: ${esc(session.note)}`);\n  }\n} else {\n  lines.push('No planned session found for today.');\n}\n\nif (!shouldSend && deliveryStatus === 'skipped_already_sent') {\n  lines.push('Reminder already sent today.');\n}\n\nreturn [{\n  json: {\n    runId: context.runId,\n    status: context.status,\n    createdAt: context.createdAt,\n    chatId: context.chatId,\n    previewMode: context.previewMode,\n    previewChatId: context.previewChatId,\n    reminderDate: context.reminderDate,\n    reminderWeekday: context.reminderWeekday,\n    reminderTime: context.reminderTime,\n    reminderTimezone: context.reminderTimezone,\n    reminderForceSend: context.reminderForceSend,\n    reminderKey: context.reminderKey,\n    reminderEnabled: context.reminderEnabled,\n    reminderOptInUsersCount: context.reminderOptInUsersCount,\n    reminder_opt_in_users_count: context.reminder_opt_in_users_count,\n    reminderSentCount: shouldSend ? 1 : 0,\n    reminder_sent_count: shouldSend ? 1 : 0,\n    shouldSend,\n    deliveryStatus,\n    deliveryReason,\n    session,\n    text: lines.filter(Boolean).join('\\n'),\n  }\n}];"
      }
    },
    {
      "id": "63401a52-028d-4dfc-84de-dc996b9ca79b",
      "name": "Should Send Reminder?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -400,
        940
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.shouldSend }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "fb5f6473-9774-49f5-96cc-1e104ec9d59e",
      "name": "Send Reminder Message",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        -160,
        820
      ],
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "id": "b409f1bb-0422-412d-a326-815ff730e116",
      "name": "Build Reminder Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        940
      ],
      "parameters": {
        "jsCode": "const baseItems = $items('Build Reminder Message');\nif (!baseItems.length) {\n  return [];\n}\n\nconst base = baseItems[0].json || {};\nconst incoming = (items[0] && items[0].json && typeof items[0].json === 'object') ? items[0].json : {};\nconst incomingHasPayload = Object.prototype.hasOwnProperty.call(incoming, 'shouldSend');\n\nlet deliveryStatus = base.deliveryStatus || 'skipped';\nlet deliveryReason = base.deliveryReason || null;\nlet reminderSentCount = base.shouldSend ? 1 : 0;\nlet telegramMessageId = null;\nlet telegramResponse = null;\n\nif (incomingHasPayload) {\n  deliveryStatus = incoming.deliveryStatus || deliveryStatus;\n  deliveryReason = incoming.deliveryReason || deliveryReason;\n  reminderSentCount = incoming.shouldSend ? 1 : 0;\n} else if (base.shouldSend) {\n  deliveryStatus = 'sent';\n  deliveryReason = 'sent';\n  reminderSentCount = 1;\n  telegramResponse = incoming;\n  if (incoming && incoming.result && incoming.result.message_id != null) {\n    telegramMessageId = incoming.result.message_id;\n  }\n}\n\nconst createdAt = new Date().toISOString();\n\nreturn [{\n  json: {\n    runId: base.runId || `reminder-${Math.random().toString(36).slice(2, 10)}`,\n    status: 'reminder',\n    chatId: base.chatId || null,\n    previewMode: Boolean(base.previewMode),\n    previewChatId: base.previewChatId || null,\n    reminderDate: base.reminderDate || null,\n    reminderWeekday: base.reminderWeekday || null,\n    reminderTime: base.reminderTime || null,\n    reminderTimezone: base.reminderTimezone || null,\n    reminderForceSend: Boolean(base.reminderForceSend),\n    reminderKey: base.reminderKey || null,\n    reminderEnabled: Boolean(base.reminderEnabled),\n    deliveryStatus,\n    deliveryReason,\n    session: base.session || null,\n    text: base.text || null,\n    telegramMessageId,\n    telegramResponse,\n    reminderSentCount,\n    reminder_sent_count: reminderSentCount,\n    reminderOptInUsersCount: base.reminderOptInUsersCount === 1 ? 1 : 0,\n    reminder_opt_in_users_count: base.reminder_opt_in_users_count === 1 ? 1 : 0,\n    createdAt,\n  }\n}];"
      }
    },
    {
      "id": "768a9b31-7943-4301-84d7-553f780e4ad5",
      "name": "Reminder Events DB",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        320,
        860
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "reminder_events",
        "updateKey": "runId",
        "fields": "runId, status, chatId, previewMode, previewChatId, reminderDate, reminderWeekday, reminderTime, reminderTimezone, reminderForceSend, reminderKey, reminderEnabled, deliveryStatus, deliveryReason, session, text, telegramMessageId, telegramResponse, reminderSentCount, reminder_sent_count, reminderOptInUsersCount, reminder_opt_in_users_count, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "955198df-67a1-48dd-a9f4-17de2f2f49b3",
      "name": "Run Events DB (reminder)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        320,
        1020
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_events",
        "updateKey": "runId",
        "fields": "runId, status, chatId, previewMode, previewChatId, reminderDate, reminderWeekday, reminderTime, reminderTimezone, reminderForceSend, reminderKey, reminderEnabled, deliveryStatus, deliveryReason, session, reminderSentCount, reminder_sent_count, reminderOptInUsersCount, reminder_opt_in_users_count, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking \u2018Execute workflow\u2019": {
      "main": [
        [
          {
            "node": "GET Activities",
            "type": "main",
            "index": 0
          },
          {
            "node": "GET Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Map Activities + Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Activities": {
      "main": [
        [
          {
            "node": "Activities DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Wellness": {
      "main": [
        [
          {
            "node": "Wellness DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET Wellness": {
      "main": [
        [
          {
            "node": "Shape Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET Activities": {
      "main": [
        [
          {
            "node": "Shape Activities",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Weekly Metrics": {
      "main": [
        [
          {
            "node": "Weekly Metrics DB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Previous Weeks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Previous Weeks": {
      "main": [
        [
          {
            "node": "Merge Current & History",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Current & History": {
      "main": [
        [
          {
            "node": "Map Current + History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Current + History": {
      "main": [
        [
          {
            "node": "Merge Request Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Weekly Metrics DB": {
      "main": [
        [
          {
            "node": "Merge Current & History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Activities + Wellness": {
      "main": [
        [
          {
            "node": "Shape Weekly Metrics",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Request Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Request Data": {
      "main": [
        [
          {
            "node": "Read Recent Feedback Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prompt Builder": {
      "main": [
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          },
          {
            "node": "Run Artifacts DB (inputs)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message a model": {
      "main": [
        [
          {
            "node": "Validate WeeklyPlan (attempt 0)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Telegram Message": {
      "main": [
        [
          {
            "node": "Send a text message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Feedback Prompt",
            "type": "main",
            "index": 0
          },
          {
            "node": "Run Events DB (success)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wellness DB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Activities DB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "GET Activities",
            "type": "main",
            "index": 0
          },
          {
            "node": "GET Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate WeeklyPlan (attempt 0)": {
      "main": [
        [
          {
            "node": "Is WeeklyPlan valid? (attempt 0)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is WeeklyPlan valid? (attempt 0)": {
      "main": [
        [
          {
            "node": "Build Run Event (success)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Repair Prompt (attempt 1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Repair Prompt (attempt 1)": {
      "main": [
        [
          {
            "node": "Repair Plan 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repair Plan 1": {
      "main": [
        [
          {
            "node": "Validate WeeklyPlan (attempt 1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate WeeklyPlan (attempt 1)": {
      "main": [
        [
          {
            "node": "Is WeeklyPlan valid? (attempt 1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is WeeklyPlan valid? (attempt 1)": {
      "main": [
        [
          {
            "node": "Build Run Event (success)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Repair Prompt (attempt 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Repair Prompt (attempt 2)": {
      "main": [
        [
          {
            "node": "Repair Plan 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repair Plan 2": {
      "main": [
        [
          {
            "node": "Validate WeeklyPlan (attempt 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate WeeklyPlan (attempt 2)": {
      "main": [
        [
          {
            "node": "Is WeeklyPlan valid? (attempt 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is WeeklyPlan valid? (attempt 2)": {
      "main": [
        [
          {
            "node": "Build Run Event (success)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Failure Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fallback Trigger": {
      "main": []
    },
    "Build Run Event (success)": {
      "main": [
        [
          {
            "node": "Plan Snapshots DB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Run Artifact (outputs)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Recent Pain Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Failure Event": {
      "main": [
        [
          {
            "node": "Run Events DB (failure)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Run Artifact (outputs)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Events DB (failure)": {
      "main": [
        [
          {
            "node": "Send Failure Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Failure Alert": {
      "main": [
        [
          {
            "node": "Fallback Trigger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Plan Snapshots DB": {
      "main": []
    },
    "Build Run Artifact (outputs)": {
      "main": [
        [
          {
            "node": "Run Artifacts DB (outputs)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Artifacts DB (inputs)": {
      "main": []
    },
    "Run Artifacts DB (outputs)": {
      "main": []
    },
    "Build Feedback Prompt": {
      "main": [
        [
          {
            "node": "Send Feedback Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram Feedback Trigger": {
      "main": [
        [
          {
            "node": "Parse Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Feedback": {
      "main": [
        [
          {
            "node": "Is Feedback Late?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Feedback Events DB": {
      "main": [
        [
          {
            "node": "Send Feedback Ack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Recent Pain Feedback": {
      "main": [
        [
          {
            "node": "Summarize Pain Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize Pain Feedback": {
      "main": [
        [
          {
            "node": "Build Telegram Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Feedback Late?": {
      "main": [
        [
          {
            "node": "Feedback Events DB",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Feedback Ack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Recent Feedback Summary": {
      "main": [
        [
          {
            "node": "Summarize Recent Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize Recent Feedback": {
      "main": [
        [
          {
            "node": "Prompt Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Daily Reminder Trigger": {
      "main": [
        [
          {
            "node": "Build Reminder Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Reminder Context": {
      "main": [
        [
          {
            "node": "Read Latest Plan Snapshot",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Latest Plan Snapshot": {
      "main": [
        [
          {
            "node": "Read Reminder Sends Today",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Reminder Sends Today": {
      "main": [
        [
          {
            "node": "Build Reminder Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Reminder Message": {
      "main": [
        [
          {
            "node": "Should Send Reminder?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Send Reminder?": {
      "main": [
        [
          {
            "node": "Send Reminder Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Reminder Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reminder Message": {
      "main": [
        [
          {
            "node": "Build Reminder Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Reminder Event": {
      "main": [
        [
          {
            "node": "Reminder Events DB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Run Events DB (reminder)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "a3f728cc-fe6f-45c9-bd6d-430a6e8a3f9b",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "32e042aaa93a0c2717f17fdbf6d1b765a1d2543e64737ddc9ed84499712f834c"
  },
  "id": "Q9nTNHZ5vUBf58oI",
  "tags": []
}
