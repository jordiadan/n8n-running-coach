{
  "name": "Running Coach",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1600,
        448
      ],
      "id": "8181fc0a-148a-4556-9619-997e448253f7",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -704,
        448
      ],
      "id": "bbab3a2d-65f6-4afd-bc79-d5792a915a4a",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  const a = item.json;\n  return {\n    json: {\n      id:              a.id,\n      athleteId:       a.icu_athlete_id,\n      date:            new Date(a.start_date),         // ISO 8601\n      type:            a.type,\n      duration:        a.elapsed_time,       // seconds\n      distance:        a.distance,           // meters (or null)\n      calories:        a.calories,\n      trimp:           a.trimp,\n      ctl:             a.icu_ctl,\n      atl:             a.icu_atl,\n      rampRate:        a.rampRate ?? (a.icu_ctl - a.icu_atl),\n      avgHeartRate:    a.average_heartrate,\n      maxHeartRate:    a.max_heartrate,\n      interval_summary: a.interval_summary,  // e.g. [\"1x...\",\"3x...\"]\n      sportInfo:       a.sportInfo           // you can leave the array or map to just types\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1152,
        352
      ],
      "id": "3f360e1c-10e3-49a8-b4a3-73e4b48479f3",
      "name": "Shape Activities"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  const w = item.json;\n  return {\n    json: {\n      id:         w.id,                            // e.g. \"2025-07-10\"\n      athleteId:  w.icu_athlete_id,                // your athlete key\n      date:       new Date(w.updated),                       // ISO timestamp of the record\n      ctl:        w.ctl,                           // chronic training load\n      atl:        w.atl,                           // acute training load\n      rampRate:   w.rampRate ?? (w.ctl - w.atl),   // change in load\n      ctlLoad:    w.ctlLoad,                       // daily CTL “load”\n      atlLoad:    w.atlLoad,                       // daily ATL “load”\n      restingHR:  w.restingHR,                     // recovery HR\n      hrv:        w.hrv,                           // HRV\n      sleepScore: w.sleepScore,                    // sleep quality\n      steps:      w.steps,                         // daily step count\n      weight:     w.weight                         // body weight (if available)\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1152,
        544
      ],
      "id": "2cc3212b-59ec-4b12-bb69-be867071d7ab",
      "name": "Shape Wellness"
    },
    {
      "parameters": {
        "url": "https://intervals.icu/api/v1/athlete/i372001/wellness",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "oldest",
              "value": "={{ $now.minus({ days: 7 }).toISODate() }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Basic QVBJX0tFWTo1d2VtM2xxbXh2Mjluenl3ZXVpMzh2cTc="
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          },
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        544
      ],
      "id": "43f25252-a6d2-4350-9005-faef42df185c",
      "name": "GET Wellness"
    },
    {
      "parameters": {
        "url": "https://intervals.icu/api/v1/athlete/i372001/activities",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "oldest",
              "value": "={{ $now.minus({ days: 7 }).toISO({ includeOffset: false }) }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Basic QVBJX0tFWTo1d2VtM2xxbXh2Mjluenl3ZXVpMzh2cTc="
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          },
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1376,
        352
      ],
      "id": "14d91aca-0f01-43a4-be95-8852730b31fe",
      "name": "GET Activities"
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "activities",
        "fields": "id, athleteId, date, type, duration, distance, calories, trimp, ctl, atl, rampRate, avgHeartRate, maxHeartRate, interval_summary, sportInfo",
        "upsert": true,
        "options": {
          "dateFields": "date"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -928,
        352
      ],
      "id": "3598eb29-2010-4428-b678-eaa40eeb6806",
      "name": "Activities DB",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "wellness",
        "fields": "id, athleteId, date, ctl, atl, rampRate, ctlLoad, atlLoad, restingHR, hrv, sleepScore, steps, weight",
        "upsert": true,
        "options": {
          "dateFields": "date"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        -928,
        544
      ],
      "id": "ad492890-49d5-4580-9278-7272c4a00be6",
      "name": "Wellness DB",
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Function node: Compute weekly_metrics for the CURRENT week (Monday–Sunday)\n// Input: one item whose JSON has { activities: [...], wellness: [...] }\n\nconst { activities: acts, wellness: well } = items[0].json;\n\n// 1️⃣ Compute current week boundaries (Monday 00:00 to Sunday 23:59:59)\nconst today = new Date();\nconst day = today.getDay();               // 0=Sun, 1=Mon, … 6=Sat\nconst diffToMonday = (day + 6) % 7;\nconst monday = new Date(today);\nmonday.setDate(today.getDate() - diffToMonday);\nmonday.setHours(0,0,0,0);\nconst sunday = new Date(monday);\nsunday.setDate(monday.getDate() + 6);\nsunday.setHours(23,59,59,999);\n\n// 2️⃣ Helper: average over non-null\nconst avg = arr => arr.length\n  ? arr.reduce((sum, v) => sum + v, 0) / arr.length\n  : 0;\n\n// 3️⃣ Filter this week’s activities\nconst inWeek = a => {\n  const d = new Date(a.start_date);\n  return d >= monday && d <= sunday;\n};\nconst weekActs = acts.filter(inWeek);\n\n// 4️⃣ Run, ride & strength metrics\nconst runActs      = weekActs.filter(a => a.type === 'Run');\nconst rideActs     = weekActs.filter(a => /Ride/.test(a.type));\nconst strengthActs = weekActs.filter(a => a.type === 'WeightTraining');\n\nconst runCount     = runActs.length;\nconst runDistance  = runActs.reduce((s,a) => s + (a.distance||0), 0);\nconst runTime      = runActs.reduce((s,a) => s + (a.elapsed_time||0), 0);\n\nconst rideCount    = rideActs.length;\nconst rideDistance = rideActs.reduce((s,a) => s + (a.distance||0), 0);\nconst rideTime     = rideActs.reduce((s,a) => s + (a.elapsed_time||0), 0);\nconst rideTrimp    = rideActs.reduce((s,a) => s + (a.trimp||0), 0);\n\nconst strengthCount = strengthActs.length;\nconst strengthTrimp = strengthActs.reduce((s,a) => s + (a.trimp||0), 0);\n\n// 5️⃣ Session‐type counts by keyword in activity name\nconst vo2Sessions   = runActs.filter(a => /vo2/i.test(a.name)).length;\nconst tempoSessions = runActs.filter(a => /tempo|threshold|umbral/i.test(a.name)).length;\nconst longRuns      = runActs.filter(a => /long/i.test(a.name)).length;\n\n// 6️⃣ Wellness this week (filter by id = YYYY-MM-DD)\nconst wellWeek = well.filter(w => {\n  const d = new Date(w.id);\n  return d >= monday && d <= sunday;\n});\n\nconst ctlMean        = avg(wellWeek.map(w=>w.ctl||0));\nconst atlMean        = avg(wellWeek.map(w=>w.atl||0));\nconst rampRateMean   = avg(wellWeek.map(w=>w.rampRate||0));\nconst restHrMean     = avg(wellWeek.map(w=>w.restingHR||0));\nconst stepsMean      = avg(wellWeek.map(w=>w.steps||0));\nconst sleepScoreMean = avg(wellWeek.map(w=>w.sleepScore||0));\nconst hrvMean        = avg(wellWeek.map(w=>w.hrv||0));\n\n// 7️⃣ Identify athleteId (from any activity)\nconst athleteId = acts.length\n  ? acts[0].icu_athlete_id\n  : null;\n\n// 8️⃣ Build weekly_metrics record\nconst weekStart = monday.toISOString().slice(0,10);\nconst weekEnd   = sunday.toISOString().slice(0,10);\nconst now       = new Date().toISOString();\n\nreturn [{\n  json: {\n    athleteId,\n    weekStart,\n    weekEnd,\n\n    runCount,\n    runDistance,\n    runTime,\n\n    rideCount,\n    rideDistance,\n    rideTime,\n    rideTrimp,\n\n    vo2Sessions,\n    tempoSessions,\n    longRuns,\n\n    strengthCount,\n    strengthTrimp,\n\n    ctlMean,\n    atlMean,\n    rampRateMean,\n\n    restHrMean,\n    stepsMean,\n    sleepScoreMean,\n    hrvMean,\n\n    createdAt: now,\n    updatedAt: now\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        96
      ],
      "id": "7196222d-0aea-4faa-8189-fb0bbb8d9379",
      "name": "Shape Weekly Metrics"
    },
    {
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "weekly_metrics",
        "updateKey": "weekStart",
        "fields": "athleteId, weekStart, weekEnd, runCount, runDistance, runTime, rideCount, rideDistance, rideTime, rideTrimp, vo2Sessions, tempoSessions, longRuns, strengthCount, strengthTrimp, ctlMean, atlMean, rampRateMean, restHrMean, stepsMean, sleepScoreMean, hrvMean, createdAt, updatedAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt, updatedAt"
        }
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ],
      "id": "8e7ba141-3fdf-4a40-a2d2-50d1705d6aff",
      "name": "Weekly Metrics DB",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "collection": "weekly_metrics",
        "options": {
          "sort": "{ \"weekStart\": -1 }"
        },
        "query": "={\n  \"weekStart\": {\n    \"$lt\": \"{{ $json.weekStart }}\"\n  }\n}\n"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        0,
        192
      ],
      "id": "2f2bc56d-2b5f-46ca-adf1-ad302a398f4e",
      "name": "Read Previous Weeks",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        224,
        96
      ],
      "id": "46575de3-0c9d-4381-ba47-c93f9625b9cd",
      "name": "Merge Current & History"
    },
    {
      "parameters": {
        "jsCode": "// El primer ítem es el current\nconst current = items[0].json;\n\n// Los siguientes ítems son tu histórico\nconst pastWeeks = items.slice(1).map(i => i.json);\n\nreturn [{\n  json: {\n    current,       // todas las métricas y el prompt de esta semana\n    history: pastWeeks  // tu histórico ya preparado\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        96
      ],
      "id": "e9f1806a-cb9c-4797-9969-ab99ad3442eb",
      "name": "Map Current + History"
    },
    {
      "parameters": {
        "jsCode": "// in a Function node (Run Once for All Items)\n\nconst activities = $items(\"GET Activities\").map(item => item.json);\nconst wellness   = $items(\"GET Wellness\"  ).map(item => item.json);\n\nreturn [\n  {\n    json: {\n      activities,\n      wellness\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -480,
        448
      ],
      "id": "b677badd-1fbf-4f1d-a40d-1648c59871fa",
      "name": "Map Activities + Wellness"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        640,
        448
      ],
      "id": "c90609f0-5298-4df0-9c53-22d304b3a8c1",
      "name": "Merge Request Data"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Prompt Builder para generar el JSON limpio que le enviaremos a OpenAI\n * Incluye semana, fechas y solicita al modelo los campos necesarios.\n */\n\n// —————————————— CONFIGURACIÓN ——————————————\n\n// Fecha de inicio de tu plan (puedes ajustarla)\nconst programStartDate = new Date('2025-07-19');\n\n// Fecha de la competición\nconst raceDate = new Date('2026-02-15');\n\n// ——————————— CÁLCULOS DE FECHAS ———————————\n\nconst today = new Date();\nconst msPerWeek = 7 * 24 * 60 * 60 * 1000;\nconst weeksSinceStart = Math.floor((today - programStartDate) / msPerWeek) + 1;\nconst weeksToRace = Math.ceil((raceDate - today) / msPerWeek);\nconst totalPlanWeeks = weeksSinceStart + weeksToRace;\n\n// —————————— DETERMINACIÓN DE FASE ——————————\n\nlet phaseName, phaseNote;\nif (weeksSinceStart <= Math.floor(totalPlanWeeks * 0.3)) {\n  phaseName = 'Base';\n  phaseNote = 'Rodajes suaves y fuerza general.';\n} else if (weeksSinceStart <= Math.floor(totalPlanWeeks * 0.7)) {\n  phaseName = 'Desarrollo';\n  phaseNote = 'Interválicos, tempo runs y fuerza específica.';\n} else if (weeksToRace > 2) {\n  phaseName = 'Específica';\n  phaseNote = 'Ritmo objetivo, simulaciones de competición.';\n} else {\n  phaseName = 'Taper';\n  phaseNote = 'Reducción de carga manteniendo chispa.';\n}\n\n// —————————— DESCOMPOSICIÓN DE DATOS ——————————\n\nconst { current, history: rawHistory } = items[0].json;\nconst history = Array.isArray(rawHistory)\n  ? rawHistory\n      .sort((a, b) => b.weekStart.localeCompare(a.weekStart))\n      .slice(0, 4)\n  : [];\n\nconst { activities, wellness } = items[1].json;\n\n// —————————— EXTRACCIÓN DE FCMAX ——————————\n\nconst DEFAULT_FCMAX = 202;\nconst recordedMaxHR = Math.max(\n  ...activities.map(a => a.max_heartrate || 0).filter(hr => hr > 0)\n);\nconst fcMax = recordedMaxHR >= 190 ? recordedMaxHR : DEFAULT_FCMAX;\n\n// —————————— HELPERS ——————————\n\nconst avg = arr => arr.length ? arr.reduce((sum, v) => sum + v, 0) / arr.length : 0;\nconst fmt = x   => x != null ? x.toFixed(1) : '—';\n\n// —————————— MÉTRICAS SEMANA ACTUAL ——————————\n\nconst { weekStart, weekEnd } = current;\nconst ctlActs    = avg( activities.map(a => a.icu_ctl      || 0) );\nconst atlActs    = avg( activities.map(a => a.icu_atl      || 0) );\nconst rampActs   = avg( activities.map(a => a.icu_rampRate || 0) );\nconst totalTrimp = activities.reduce((s,a) => s + (a.trimp || 0), 0);\n\nconst restVals = [...activities, ...wellness]\n  .map(o => o.restingHR).filter(v => v != null);\nconst stepVals = [...activities, ...wellness]\n  .map(o => o.steps).filter(v => v != null);\n\nconst restHR   = avg(restVals);\nconst steps    = avg(stepVals);\nconst hrvWel   = avg( wellness.map(w => w.hrv        || 0) );\nconst sleepWel = avg( wellness.map(w => w.sleepScore || 0) );\n\n// —————————— CONSTRUCCIÓN DEL PROMPT (FORZAR JSON PURA) ——————————\n\nconst prompt = `\n// PROMPT_BEGIN\nEres mi coach experto en medio maratón (método noruego, híbrido fuerza+carrera).\n\nContexto:\n- Mitja Marató Barcelona (15‑02‑2026), objetivo 1h45m (~4:59/km).\n- Empezamos el plan el ${programStartDate.toISOString().slice(0,10)}, esta es la semana **${weeksSinceStart}** de un plan de **${totalPlanWeeks}** semanas.\n- Quedan **${weeksToRace}** semanas → Fase **${phaseName}**: ${phaseNote}\n\nResumen ${weekStart} → ${weekEnd}:\n• CTL avg: ${fmt(ctlActs)}, ATL avg: ${fmt(atlActs)}, RampRate avg: ${fmt(rampActs)}\n• TRIMP total: ${fmt(totalTrimp)}\n• FC reposo medio: ${fmt(restHR)} bpm, Pasos/día medio: ${fmt(steps)}\n• HRV avg: ${fmt(hrvWel)}, SleepScore avg: ${fmt(sleepWel)}\n\nHistorial (4 semanas anteriores):\n${history.map(h =>\n  `- Semana ${h.weekStart}: ${fmt(h.runDistance/1000)} km · ATL ${fmt(h.atlMean)} · RampRate ${fmt(h.rampRateMean)} · RHR ${fmt(h.restHrMean)}`\n).join('\\n')}\n\nPor favor genera mi plan PARA LA PRÓXIMA SEMANA siguiendo el método noruego:\n- Indica fase del plan y el objetivo de la semana.\n- **Gimnasio**: Mar, Jue y Sáb (orden: Pecho y brazos, Espalda y hombros, Piernas).\n- **Running** según carga (CTL, ATL, TRIMP, HRV/Sueño):\n  1. Sesión VO₂ máx  \n  2. Sesión tempo/umbral  \n  3. Tirada larga aeróbica  \n  4. Easy/recovery  \n\n**IMPORTANTE**:  \n- Gimnasio a las 12–13h, calcula recuperación y planifica alrededor.  \n- Usa **zonas de FC Garmin (Z1–Z5)** basadas en FCmáx=${fcMax} bpm; indica % y rango de bpm.  \n- Si dispones de LTHR (183 bpm), úsalo para definir las zonas de umbral.\n\n\n\nSALIDA (OBLIGATORIA):\n\n- Devuelve exclusivamente un JSON válido y minificado en UNA sola línea (sin texto extra, sin bloques de código, sin comentarios).\n- Sustituye en todos los textos: &→&amp;, <→&lt;, >→&gt;.\n- La respuesta empieza con { y termina con }.\n- ≤ 3000 caracteres en total.\n\nEstructura EXACTA con 7 objetos en days (uno por cada día de la semana). Si no cabe, reduce primero note y luego justification.\n\n\\`\\`\\`json\n{\n  \"schema_version\": \"1.0\",\n  \"activityPlan\": {\n    \"nextWeek\": {\n      \"phase\": string,\n      \"objective\": string,\n      \"weekStart\": string,   // e.g. \"2025-07-14\"\n      \"weekEnd\":   string    // e.g. \"2025-07-20\"\n    },\n    \"days\": [\n      {\n        \"day\": string,         // Nombre en español, ej. \"Lunes\"\n        \"date\": string,        // Fecha concreta, ej. \"2025-07-14\"\n        \"activity\": string,\n        \"distance_time\": string,\n        \"intensity\": string,\n        \"goal\": string,\n        \"note\": string\n      }\n      // …un objeto por cada día de la semana\n    ]\n  },\n  \"justification\": [ string, … ]\n}\n\\`\\`\\`\n// PROMPT_END\n`.trim();\n\n// —————————— RETORNO ——————————\n\nconst runId = `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst PROMPT_VERSION = \"2026-02-05\";\n// Bump PROMPT_VERSION whenever the prompt template changes.\nconst modelId = \"gpt-5\";\nconst createdAt = new Date().toISOString();\n\nreturn [{\n  json: {\n    runId,\n    promptVersion: PROMPT_VERSION,\n    modelId,\n    createdAt,\n    prompt,\n    metrics: {\n      programStartDate: programStartDate.toISOString().slice(0,10),\n      weeksSinceStart,\n      totalPlanWeeks,\n      weeksToRace,\n      phaseName,\n      weekStart,\n      weekEnd,\n      ctlActs,\n      atlActs,\n      rampActs,\n      totalTrimp,\n      restHR,\n      steps,\n      hrvWel,\n      sleepWel,\n      fcMax\n    },\n    history,\n    activities,\n    wellness\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        448
      ],
      "id": "76c7ae56-2f54-4c18-9fef-774b12705f5b",
      "name": "Prompt Builder"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.prompt }}",
              "role": "system"
            },
            {
              "content": "={{\n  `Datos de la ÚLTIMA SEMANA:\\n` +\n  `Métricas: ${JSON.stringify($json.metrics, null, 2)}\\n\\n` +\n  `Historial (semanas anteriores): ${JSON.stringify($json.history, null, 2)}`\n}}"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        1088,
        448
      ],
      "id": "34773ad2-7d76-4f29-a297-bc1c86ddabf6",
      "name": "Message a model",
      "alwaysOutputData": false,
      "credentials": {
        "openAiApi": {
          "id": "olyatB4PnLtBz9VL",
          "name": "OpenAi account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.htmlMessage }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1712,
        448
      ],
      "id": "f044dc1e-c6df-4372-8334-1dee1dc7a75f",
      "name": "Send a text message",
      "webhookId": "2300ed5a-c28d-45ed-93fc-3b3df686f46d",
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const TEMPLATE_VERSION = 'telegram-v2.0';\n\nconst DEFAULT_CHAT_ID = '730354404';\n\nconst isObject = (value) => value !== null && typeof value === 'object' && !Array.isArray(value);\n\nconst parseContent = (input) => {\n  if (typeof input !== 'string') {\n    return input;\n  }\n  try {\n    return JSON.parse(input);\n  } catch {\n    return null;\n  }\n};\n\nconst rawContent = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\nconst content = parseContent(rawContent);\n\nif (!isObject(content) || !isObject(content.activityPlan)) {\n  throw new Error('Missing or invalid activityPlan in response.');\n}\n\nconst plan = content.activityPlan;\nconst nextWeek = isObject(plan.nextWeek) ? plan.nextWeek : {};\nconst days = Array.isArray(plan.days) ? plan.days : [];\nconst justifications = Array.isArray(content.justification) ? content.justification : [];\n\nconst getVar = (key) => {\n  if (typeof $vars !== 'undefined' && $vars[key] != null) {\n    return String($vars[key]);\n  }\n  if (typeof process !== 'undefined' && process.env && process.env[key] != null) {\n    return String(process.env[key]);\n  }\n  return '';\n};\n\nconst isTruthy = (value) => ['1', 'true', 'yes', 'on'].includes(String(value).toLowerCase());\n\nconst previewEnabled = isTruthy(getVar('RC_TELEGRAM_PREVIEW_MODE'));\nconst previewChatRaw = getVar('RC_TELEGRAM_PREVIEW_CHAT_ID').trim();\nif (previewEnabled && !previewChatRaw) {\n  throw new Error('RC_TELEGRAM_PREVIEW_CHAT_ID is required when RC_TELEGRAM_PREVIEW_MODE is enabled.');\n}\nconst targetChatId = previewEnabled ? previewChatRaw : DEFAULT_CHAT_ID;\n\nconst runContextItems = $items('Prompt Builder');\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst metrics = isObject(runContext.metrics) ? runContext.metrics : {};\nconst history = Array.isArray(runContext.history) ? runContext.history : [];\n\nconst valueOr = (value, fallback = '--') => {\n  if (value === null || value === undefined) return fallback;\n  const text = String(value).trim();\n  return text || fallback;\n};\n\nconst esc = (value) => String(value)\n  .replace(/&/g, '&amp;')\n  .replace(/</g, '&lt;')\n  .replace(/>/g, '&gt;')\n  .replace(/\"/g, '&quot;')\n  .replace(/'/g, '&#39;');\n\nconst num = (value) => {\n  if (value === null || value === undefined || value === '') return null;\n  const parsed = Number(value);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst mean = (values) => {\n  const valid = values.map(num).filter((value) => value !== null);\n  if (!valid.length) return null;\n  return valid.reduce((sum, value) => sum + value, 0) / valid.length;\n};\n\nconst fmt = (value, suffix = '') => (value === null ? '--' : `${value.toFixed(1)}${suffix}`);\n\nconst normalizeDay = (value) => String(value || '')\n  .toLowerCase()\n  .replace(/[áàä]/g, 'a')\n  .replace(/[éèë]/g, 'e')\n  .replace(/[íìï]/g, 'i')\n  .replace(/[óòö]/g, 'o')\n  .replace(/[úùü]/g, 'u')\n  .replace(/ñ/g, 'n');\n\nconst dayOrder = {\n  lunes: 0,\n  monday: 0,\n  martes: 1,\n  tuesday: 1,\n  miercoles: 2,\n  wednesday: 2,\n  jueves: 3,\n  thursday: 3,\n  viernes: 4,\n  friday: 4,\n  sabado: 5,\n  saturday: 5,\n  domingo: 6,\n  sunday: 6,\n};\n\nconst sortedDays = [...days].sort((a, b) => {\n  const aOrder = dayOrder[normalizeDay(a.day)];\n  const bOrder = dayOrder[normalizeDay(b.day)];\n  const safeA = aOrder === undefined ? 99 : aOrder;\n  const safeB = bOrder === undefined ? 99 : bOrder;\n  if (safeA !== safeB) return safeA - safeB;\n  return String(a.date || '').localeCompare(String(b.date || ''));\n});\n\nconst ctlNow = num(metrics.ctlActs);\nconst atlNow = num(metrics.atlActs);\nconst rampNow = num(metrics.rampActs);\nconst trimpNow = num(metrics.totalTrimp);\nconst restNow = num(metrics.restHR);\nconst hrvNow = num(metrics.hrvWel);\nconst sleepNow = num(metrics.sleepWel);\nconst stepsNow = num(metrics.steps);\n\nconst lastWeekSummaryLines = [];\nif (ctlNow !== null || atlNow !== null || rampNow !== null) {\n  lastWeekSummaryLines.push(`CTL / ATL / Ramp: ${fmt(ctlNow)} / ${fmt(atlNow)} / ${fmt(rampNow)}`);\n}\nif (trimpNow !== null) {\n  lastWeekSummaryLines.push(`TRIMP total: ${fmt(trimpNow)}`);\n}\nif (restNow !== null || hrvNow !== null || sleepNow !== null) {\n  lastWeekSummaryLines.push(`Recovery signals: Resting HR ${fmt(restNow)} bpm, HRV ${fmt(hrvNow)}, Sleep ${fmt(sleepNow)}`);\n}\nif (stepsNow !== null) {\n  lastWeekSummaryLines.push(`Average steps/day: ${fmt(stepsNow)}`);\n}\nconst hasLastWeekSummaryData = lastWeekSummaryLines.length > 0;\nif (!hasLastWeekSummaryData) {\n  lastWeekSummaryLines.push('No recent metrics available.');\n}\n\nconst weekStart = valueOr(nextWeek.weekStart);\nconst weekEnd = valueOr(nextWeek.weekEnd);\nconst phase = valueOr(nextWeek.phase);\nconst objective = valueOr(nextWeek.objective);\n\nconst thisWeekGoalLines = [\n  `Week: ${weekStart} -> ${weekEnd}`,\n  `Phase: ${phase}`,\n  `Objective: ${objective}`,\n];\nif (justifications.length) {\n  const rationale = justifications\n    .slice(0, 3)\n    .map((item) => valueOr(item))\n    .join(' | ');\n  thisWeekGoalLines.push(`Rationale: ${rationale}`);\n}\nconst hasThisWeekGoalData = [nextWeek.weekStart, nextWeek.weekEnd, nextWeek.phase, nextWeek.objective].some(Boolean);\n\nconst dailyPlanLines = sortedDays.map((day) => {\n  const dayName = valueOr(day.day, 'Day');\n  const date = valueOr(day.date);\n  const activity = valueOr(day.activity);\n  const distanceTime = valueOr(day.distance_time);\n  const intensity = valueOr(day.intensity);\n  const goal = valueOr(day.goal);\n  const note = day.note ? ` | Note: ${valueOr(day.note, '')}` : '';\n  return `${dayName} (${date}) - ${activity} | ${distanceTime} | ${intensity} | ${goal}${note}`;\n});\nif (!dailyPlanLines.length) {\n  dailyPlanLines.push('No day-by-day entries available.');\n}\nconst hasCompleteDailyPlan = sortedDays.length === 7;\n\nconst combinedText = (day) => `${valueOr(day.activity, '')} ${valueOr(day.intensity, '')} ${valueOr(day.goal, '')} ${valueOr(day.note, '')}`.toLowerCase();\nconst hardPattern = /(\\bz4\\b|\\bz5\\b|vo2|tempo|threshold|umbral|interval)/;\nconst longPattern = /(\\blong\\b|tirada|larga)/;\n\nconst keySessionDay = sortedDays.find((day) => hardPattern.test(combinedText(day)))\n  || sortedDays.find((day) => longPattern.test(combinedText(day)))\n  || sortedDays[0]\n  || null;\n\nconst keySessionLines = [];\nif (keySessionDay) {\n  keySessionLines.push(\n    `${valueOr(keySessionDay.day, 'Day')} (${valueOr(keySessionDay.date)}) - ${valueOr(keySessionDay.activity)} | ${valueOr(keySessionDay.distance_time)} | ${valueOr(keySessionDay.intensity)} | ${valueOr(keySessionDay.goal)}`,\n  );\n  if (keySessionDay.note) {\n    keySessionLines.push(`Note: ${valueOr(keySessionDay.note, '')}`);\n  }\n} else {\n  keySessionLines.push('No key session identified.');\n}\nconst hasKeySessionData = Boolean(keySessionDay);\n\nconst baselineHrv = mean(history.map((entry) => entry.hrvMean));\nconst baselineRest = mean(history.map((entry) => entry.restHrMean));\nconst baselineRamp = mean(history.map((entry) => entry.rampRateMean));\n\nconst rationaleCandidates = [];\nconst addRationale = (text, metricKeys) => {\n  rationaleCandidates.push({ text, metricKeys });\n};\n\nif (ctlNow !== null && atlNow !== null && rampNow !== null) {\n  addRationale(\n    `Load balance: CTL ${fmt(ctlNow)}, ATL ${fmt(atlNow)}, ramp ${fmt(rampNow)}.`,\n    ['ctlActs', 'atlActs', 'rampActs'],\n  );\n}\nif (trimpNow !== null) {\n  addRationale(\n    `Weekly load volume: total TRIMP ${fmt(trimpNow)}.`,\n    ['totalTrimp'],\n  );\n}\nif (restNow !== null && hrvNow !== null && sleepNow !== null) {\n  addRationale(\n    `Recovery profile: Resting HR ${fmt(restNow)} bpm, HRV ${fmt(hrvNow)}, Sleep ${fmt(sleepNow)}.`,\n    ['restHR', 'hrvWel', 'sleepWel'],\n  );\n}\nif (hrvNow !== null && baselineHrv !== null && restNow !== null && baselineRest !== null) {\n  addRationale(\n    `Trend vs baseline: HRV ${fmt(hrvNow)} vs ${fmt(baselineHrv)}, Resting HR ${fmt(restNow)} vs ${fmt(baselineRest)} bpm.`,\n    ['hrvWel', 'histHrv', 'restHR', 'histRestHR'],\n  );\n}\nif (stepsNow !== null) {\n  addRationale(\n    `Daily activity support: average steps ${fmt(stepsNow)}.`,\n    ['steps'],\n  );\n}\nif (rampNow !== null && baselineRamp !== null) {\n  addRationale(\n    `Ramp management: current ramp ${fmt(rampNow)} vs baseline ${fmt(baselineRamp)}.`,\n    ['rampActs', 'histRamp'],\n  );\n}\n\nlet whyPlanHallucinationFailures = 0;\nconst whyThisPlan = [];\nconst whyMetricGroups = [];\nfor (const candidate of rationaleCandidates) {\n  const invalid = candidate.metricKeys.some((key) => key == null || key === '');\n  if (invalid) {\n    whyPlanHallucinationFailures += 1;\n    continue;\n  }\n  whyThisPlan.push(candidate.text);\n  whyMetricGroups.push(candidate.metricKeys);\n}\n\nif (whyThisPlan.length < 2) {\n  const fallback = [\n    ['ctlActs', ctlNow, 'CTL'],\n    ['atlActs', atlNow, 'ATL'],\n    ['rampActs', rampNow, 'ramp rate'],\n    ['totalTrimp', trimpNow, 'TRIMP'],\n    ['restHR', restNow, 'resting HR'],\n    ['hrvWel', hrvNow, 'HRV'],\n    ['sleepWel', sleepNow, 'sleep score'],\n    ['steps', stepsNow, 'steps'],\n  ];\n  for (const [key, value, label] of fallback) {\n    if (whyThisPlan.length >= 2) break;\n    if (value === null) continue;\n    const alreadyUsed = whyMetricGroups.some((group) => group.includes(key));\n    if (alreadyUsed) continue;\n    whyThisPlan.push(`Signal check: ${label} is ${fmt(value)}.`);\n    whyMetricGroups.push([key]);\n  }\n}\n\nif (whyThisPlan.length < 2) {\n  whyThisPlan.push('Insufficient metrics to generate full rationale bullets.');\n  whyMetricGroups.push([]);\n}\n\nconst whyThisPlanFinal = whyThisPlan.slice(0, 4);\nconst whyMetricGroupsFinal = whyMetricGroups.slice(0, 4);\nconst whyPlanMetricKeys = Array.from(new Set(whyMetricGroupsFinal.flat()));\n\n\nconst riskFeedback = (content.riskFeedback && typeof content.riskFeedback === 'object')\n  ? content.riskFeedback\n  : {};\n\nconst riskFlags = [];\nif (hrvNow !== null && baselineHrv !== null && hrvNow < baselineHrv * 0.9) {\n  riskFlags.push({\n    trigger: 'wellnessLow',\n    message: `HRV is ${fmt(hrvNow)} vs baseline ${fmt(baselineHrv)} (>=10% lower).`,\n    action: 'Prioritize recovery and keep intensity low for the next session.',\n  });\n}\nif (restNow !== null && baselineRest !== null && restNow > baselineRest + 3) {\n  riskFlags.push({\n    trigger: 'restHrHigh',\n    message: `Resting HR is ${fmt(restNow)} bpm vs baseline ${fmt(baselineRest)} (+3 bpm).`,\n    action: 'Reduce intensity and monitor morning fatigue over the next 48h.',\n  });\n}\nif (rampNow !== null && (rampNow > 5 || (baselineRamp !== null && rampNow > baselineRamp + 1.5))) {\n  riskFlags.push({\n    trigger: 'rampHigh',\n    message: `Ramp rate is high (${fmt(rampNow)}).`,\n    action: 'Avoid adding extra volume this week.',\n  });\n}\nif (sleepNow !== null && sleepNow < 70) {\n  riskFlags.push({\n    trigger: 'wellnessLow',\n    message: `Sleep score is low (${fmt(sleepNow)}).`,\n    action: 'Prefer easy aerobic work until sleep stabilizes.',\n  });\n}\nif (ctlNow !== null && atlNow !== null && atlNow - ctlNow > 10) {\n  riskFlags.push({\n    trigger: 'atlOverload',\n    message: `ATL (${fmt(atlNow)}) is notably above CTL (${fmt(ctlNow)}).`,\n    action: 'Add recovery between hard efforts.',\n  });\n}\nif (riskFeedback.hasRecentPain) {\n  const painDate = riskFeedback.latestPainDate || 'recent session';\n  riskFlags.push({\n    trigger: 'painReported',\n    message: `Pain feedback reported (${painDate}).`,\n    action: 'Avoid hard impact sessions and reassess symptoms before progressing.',\n  });\n}\n\nconst riskWarningTriggers = Array.from(new Set(riskFlags.map((flag) => flag.trigger)));\nconst riskWarningTriggerCounts = {\n  wellnessLow: riskFlags.some((flag) => flag.trigger === 'wellnessLow') ? 1 : 0,\n  rampHigh: riskFlags.some((flag) => flag.trigger === 'rampHigh') ? 1 : 0,\n  painReported: riskFlags.some((flag) => flag.trigger === 'painReported') ? 1 : 0,\n  restHrHigh: riskFlags.some((flag) => flag.trigger === 'restHrHigh') ? 1 : 0,\n  atlOverload: riskFlags.some((flag) => flag.trigger === 'atlOverload') ? 1 : 0,\n};\nconst riskWarningTriggerCount = riskWarningTriggers.length;\n\nconst hasWarningData = riskFlags.length > 0;\nconst warningLines = hasWarningData\n  ? riskFlags.map((flag) => `${flag.message} Action: ${flag.action}`)\n  : ['No red flags detected from current signals.'];\n\nconst sectionCompleteness = {\n  lastWeekSummary: hasLastWeekSummaryData,\n  thisWeekGoal: hasThisWeekGoalData,\n  dailyPlan: hasCompleteDailyPlan,\n  keySession: hasKeySessionData,\n  warnings: hasWarningData,\n};\nconst sectionMissingCount = Object.values(sectionCompleteness).filter((value) => !value).length;\n\nconst sections = [\n  { title: 'Last-week summary', lines: lastWeekSummaryLines },\n  { title: 'This-week goal', lines: thisWeekGoalLines },\n  { title: 'Why this plan', lines: whyThisPlanFinal },\n  { title: 'Daily plan', lines: dailyPlanLines },\n  { title: 'Key session', lines: keySessionLines },\n  { title: 'Warnings', lines: warningLines },\n];\n\nconst htmlParts = [];\nhtmlParts.push(`<b>Weekly plan</b> ${esc(weekStart)} -> ${esc(weekEnd)}`);\nhtmlParts.push('');\n\nif (previewEnabled) {\n  htmlParts.push('<b>Preview mode</b>');\n  htmlParts.push(`- Messages are routed to preview chat ${esc(targetChatId)}.`);\n  htmlParts.push('');\n}\n\nfor (const section of sections) {\n  htmlParts.push(`<b>${esc(section.title)}</b>`);\n  for (const line of section.lines) {\n    htmlParts.push(`- ${esc(line)}`);\n  }\n  htmlParts.push('');\n}\n\nconst debugEnabled = isTruthy(getVar('RC_TELEGRAM_DEBUG_FOOTER'));\n\nif (debugEnabled) {\n  const runId = (content.runEvent && content.runEvent.runId)\n    || content.runId\n    || content.__runId\n    || runContext.runId\n    || '-';\n  const attempt = content.__attempt ?? (content.runEvent && content.runEvent.attempt) ?? '-';\n  const promptVersion = content.promptVersion || content.__promptVersion || runContext.promptVersion || '-';\n  const modelId = content.modelId || content.__modelId || runContext.modelId || '-';\n  htmlParts.push('<pre>'\n    + `run_id: ${esc(runId)}\\n`\n    + `attempt: ${esc(attempt)}\\n`\n    + `prompt_version: ${esc(promptVersion)}\\n`\n    + `model: ${esc(modelId)}\\n`\n    + `template_version: ${esc(TEMPLATE_VERSION)}\\n`\n    + `sections_missing: ${esc(sectionMissingCount)}\\n`\n    + `preview_mode: ${esc(previewEnabled)}\\n`\n    + `chat_id: ${esc(targetChatId)}`\n    + '</pre>');\n}\n\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\nconst baseRunEvent = isObject(content.runEvent)\n  ? content.runEvent\n  : {\n      runId: `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`,\n      status: 'success',\n      attempt: content.__attempt ?? null,\n      weekStart: nextWeek.weekStart || null,\n      weekEnd: nextWeek.weekEnd || null,\n      errorCount: errors.length,\n      errors,\n      createdAt: new Date().toISOString(),\n    };\n\nconst runEvent = Object.assign({}, baseRunEvent, {\n  telegramTemplateVersion: TEMPLATE_VERSION,\n  sectionCompleteness,\n  sectionMissingCount,\n  whyThisPlan: whyThisPlanFinal,\n  whyPlanMetricKeys,\n  whyPlanHallucinationFailures,\n  previewMode: previewEnabled,\n  previewChatId: targetChatId,\n  riskWarningTriggerCount,\n  riskWarningTriggers,\n  riskWarningTriggerCounts,\n  riskFeedback,\n});\n\nreturn [{\n  json: Object.assign({}, content, runEvent, {\n    runEvent,\n    telegramTemplateVersion: TEMPLATE_VERSION,\n    sectionCompleteness,\n    sectionMissingCount,\n    whyThisPlan: whyThisPlanFinal,\n    whyPlanMetricKeys,\n    whyPlanHallucinationFailures,\n    previewMode: previewEnabled,\n    previewChatId: targetChatId,\n    riskWarningTriggerCount,\n    riskWarningTriggers,\n    riskWarningTriggerCounts,\n    riskFeedback,\n    chatId: targetChatId,\n    htmlMessage: htmlParts.join('\\n').trim(),\n  }),\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        448
      ],
      "id": "ac201b6e-375f-48f5-9b1a-656f3987aa2c",
      "name": "Build Telegram Message"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 0 21 * * 0"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1600,
        640
      ],
      "id": "a666d5c6-fc73-4016-9518-04b879e1022b",
      "name": "Schedule Trigger"
    },
    {
      "id": "9522f055-e183-4aaa-b75e-803aecae3754",
      "name": "Validate WeeklyPlan (attempt 0)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        448
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 0;\n\nconst raw = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nlet parsed = raw;\nlet parseError = null;\n\nif (typeof raw === 'string') {\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    parseError = err && err.message ? err.message : String(err);\n    parsed = null;\n  }\n}\n\nconst errors = [];\n\nif (parseError) {\n  errors.push(`invalid_json: ${parseError}`);\n}\n\nconst isObject = value => value && typeof value === 'object' && !Array.isArray(value);\nconst plan = isObject(parsed) ? parsed : {};\n\nconst dateRe = /^\\d{4}-\\d{2}-\\d{2}$/;\nconst dayRe = /^(Lunes|Martes|Miercoles|Mi\\u00e9rcoles|Jueves|Viernes|Sabado|S\\u00e1bado|Domingo)$/;\nconst intensityRe = /^(?:-|--|\\u2014|.*\\b(Z[1-5]|interval|Interval|VO2|Tempo|tempo|Umbral|umbral|Threshold|threshold|Easy|easy|Recovery|recovery)\\b.*)$/;\n\nconst reqString = (obj, key, path) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string' || !value.trim()) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  return true;\n};\n\nif (plan.schema_version !== '1.0') {\n  errors.push('schema_version must be \"1.0\"');\n}\n\nif (!isObject(plan.activityPlan)) {\n  errors.push('activityPlan must be object');\n}\n\nconst nextWeek = plan.activityPlan && plan.activityPlan.nextWeek;\nif (!isObject(nextWeek)) {\n  errors.push('activityPlan.nextWeek must be object');\n} else {\n  reqString(nextWeek, 'phase', 'activityPlan.nextWeek');\n  reqString(nextWeek, 'objective', 'activityPlan.nextWeek');\n  if (!reqString(nextWeek, 'weekStart', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekStart)) {\n    errors.push('activityPlan.nextWeek.weekStart must be YYYY-MM-DD');\n  }\n  if (!reqString(nextWeek, 'weekEnd', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekEnd)) {\n    errors.push('activityPlan.nextWeek.weekEnd must be YYYY-MM-DD');\n  }\n}\n\nconst days = plan.activityPlan && plan.activityPlan.days;\nif (!Array.isArray(days)) {\n  errors.push('activityPlan.days must be array');\n} else if (days.length !== 7) {\n  errors.push('activityPlan.days must have length 7');\n} else {\n  days.forEach((day, idx) => {\n    const path = `activityPlan.days[${idx}]`;\n    if (!isObject(day)) {\n      errors.push(`${path} must be object`);\n      return;\n    }\n    if (!reqString(day, 'day', path) || !dayRe.test(day.day)) {\n      errors.push(`${path}.day must be a valid weekday`);\n    }\n    if (!reqString(day, 'date', path) || !dateRe.test(day.date)) {\n      errors.push(`${path}.date must be YYYY-MM-DD`);\n    }\n    reqString(day, 'activity', path);\n    reqString(day, 'distance_time', path);\n    if (!reqString(day, 'intensity', path) || !intensityRe.test(day.intensity)) {\n      errors.push(`${path}.intensity must include a zone/label or be '-'/'--'/'—'`);\n    }\n    reqString(day, 'goal', path);\n  });\n}\n\n\n// Guardrails (hard rules)\nif (Array.isArray(days) && days.length === 7) {\n  const normalizeDay = (value) => (value || '')\n    .toLowerCase()\n    .replace(/[áàä]/g, 'a')\n    .replace(/[éèë]/g, 'e')\n    .replace(/[íìï]/g, 'i')\n    .replace(/[óòö]/g, 'o')\n    .replace(/[úùü]/g, 'u')\n    .replace(/ñ/g, 'n');\n  const activityText = (day) => `${day.activity || ''} ${day.goal || ''} ${day.note || ''}`.toLowerCase();\n  const intensityText = (day) => (day.intensity || '').toLowerCase();\n  const containsToken = (text, tokens) => tokens.some((token) => text.includes(token));\n\n  const hardTokens = ['z4', 'z5', 'vo2', 'interval', 'umbral', 'tempo', 'threshold'];\n  const easyTokens = ['z1', 'z2', 'easy', 'recovery', 'recuper', 'suave'];\n  const restTokens = ['descanso', 'rest', 'off'];\n  const longTokens = ['tirada', 'larga', 'long'];\n  const gymTokens = ['gimnasio', 'gym', 'fuerza', 'strength'];\n\n  const isHard = (day) => containsToken(intensityText(day), hardTokens) || containsToken(activityText(day), hardTokens);\n  const isEasy = (day) => containsToken(intensityText(day), easyTokens) || containsToken(activityText(day), easyTokens);\n  const isRest = (day) => containsToken(activityText(day), restTokens) || ['-', '--', '—', '–'].includes((day.intensity || '').trim());\n  const normalizedDays = days.map((day) => normalizeDay(day.day));\n  const uniqueDays = new Set(normalizedDays);\n  if (uniqueDays.size !== 7) {\n    errors.push('guardrail: days must cover all weekdays exactly once');\n  }\n  const requiredDays = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'];\n  requiredDays.forEach((name) => {\n    if (!uniqueDays.has(name)) {\n      errors.push(`guardrail: missing weekday ${name}`);\n    }\n  });\n\n  const isLong = (day) => containsToken(activityText(day), longTokens);\n\n  const hardCount = days.filter(isHard).length;\n  if (hardCount > 2) {\n    errors.push(`guardrail: too many hard sessions (${hardCount} > 2)`);\n  }\n\n  for (let i = 1; i < days.length; i += 1) {\n    if (isHard(days[i]) && isHard(days[i - 1])) {\n      errors.push(`guardrail: back-to-back hard sessions (days ${i} and ${i + 1})`);\n    }\n  }\n\n  const hasRecovery = days.some((day) => isRest(day) || isEasy(day));\n  if (!hasRecovery) {\n    errors.push('guardrail: must include at least one rest or recovery day');\n  }\n\n  const longCount = days.filter(isLong).length;\n  if (longCount > 1) {\n    errors.push('guardrail: only one long run per week');\n  }\n\n  days.forEach((day, idx) => {\n    if (isLong(day) && isHard(day)) {\n      errors.push(`guardrail: long run cannot be hard intensity (day ${idx + 1})`);\n    }\n  });\n\n  const gymDays = ['martes', 'jueves', 'sabado'];\n  gymDays.forEach((name) => {\n    const day = days.find((d) => normalizeDay(d.day) === name);\n    if (day && !containsToken(activityText(day), gymTokens)) {\n      errors.push(`guardrail: ${name} should include gym/strength`);\n    }\n  });\n}\nconst valid = errors.length == 0;\n\nconst output = isObject(plan) ? JSON.parse(JSON.stringify(plan)) : {};\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\n\noutput.__valid = valid;\noutput.__errors = errors;\noutput.__attempt = attempt;\noutput.__raw = typeof raw === 'string' ? raw : JSON.stringify(raw);\nif (runContext.runId) output.__runId = runContext.runId;\nif (runContext.promptVersion) output.__promptVersion = runContext.promptVersion;\nif (runContext.modelId) output.__modelId = runContext.modelId;\n\nreturn [{ json: output }];\n"
      }
    },
    {
      "id": "7a2b301d-fd6d-4ee5-b110-49a4e452043a",
      "name": "Is WeeklyPlan valid? (attempt 0)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1360,
        448
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.__valid }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "87e5a8a5-9c48-41cc-896a-c3e01ba62563",
      "name": "Build Repair Prompt (attempt 1)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1360,
        620
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 1;\nconst raw = items[0].json.__raw || JSON.stringify(items[0].json || {});\nconst errors = items[0].json.__errors || [];\n\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst runId = runContext.runId || null;\nconst promptVersion = runContext.promptVersion || null;\nconst modelId = runContext.modelId || null;\n\nconst schemaSnippet = `{\n  \"schema_version\": \"1.0\",\n  \"activityPlan\": {\n    \"nextWeek\": { \"phase\": \"...\", \"objective\": \"...\", \"weekStart\": \"YYYY-MM-DD\", \"weekEnd\": \"YYYY-MM-DD\" },\n    \"days\": [\n      { \"day\": \"Lunes\", \"date\": \"YYYY-MM-DD\", \"activity\": \"...\", \"distance_time\": \"...\", \"intensity\": \"Z1-Z5\", \"goal\": \"...\", \"note\": \"...\" }\n    ]\n  },\n  \"justification\": [\"...\"]\n}`;\n\nconst repair_prompt = `You must return ONLY a valid minified JSON object that matches this schema snippet:\\n${schemaSnippet}\\n\\nInvalid output:\\n${raw}\\n\\nValidation errors:\\n${errors.join('\\n')}`;\n\nreturn [{ json: { repair_prompt, __attempt: attempt, __errors: errors, __raw: raw, runId, promptVersion, modelId } }];\n"
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a JSON repair bot. Return only valid minified JSON."
            },
            {
              "role": "user",
              "content": "={{ $json.repair_prompt }}"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        1560,
        620
      ],
      "id": "4c22d709-ea45-42bf-89dd-4142310c7f61",
      "name": "Repair Plan 1",
      "alwaysOutputData": false,
      "credentials": {
        "openAiApi": {
          "id": "olyatB4PnLtBz9VL",
          "name": "OpenAi account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "62498923-3e4e-4a4d-ae27-72860fdf147d",
      "name": "Validate WeeklyPlan (attempt 1)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1760,
        620
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 1;\n\nconst raw = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nlet parsed = raw;\nlet parseError = null;\n\nif (typeof raw === 'string') {\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    parseError = err && err.message ? err.message : String(err);\n    parsed = null;\n  }\n}\n\nconst errors = [];\n\nif (parseError) {\n  errors.push(`invalid_json: ${parseError}`);\n}\n\nconst isObject = value => value && typeof value === 'object' && !Array.isArray(value);\nconst plan = isObject(parsed) ? parsed : {};\n\nconst dateRe = /^\\d{4}-\\d{2}-\\d{2}$/;\nconst dayRe = /^(Lunes|Martes|Miercoles|Mi\\u00e9rcoles|Jueves|Viernes|Sabado|S\\u00e1bado|Domingo)$/;\nconst intensityRe = /^(?:-|--|\\u2014|.*\\b(Z[1-5]|interval|Interval|VO2|Tempo|tempo|Umbral|umbral|Threshold|threshold|Easy|easy|Recovery|recovery)\\b.*)$/;\n\nconst reqString = (obj, key, path) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string' || !value.trim()) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  return true;\n};\n\nif (plan.schema_version !== '1.0') {\n  errors.push('schema_version must be \"1.0\"');\n}\n\nif (!isObject(plan.activityPlan)) {\n  errors.push('activityPlan must be object');\n}\n\nconst nextWeek = plan.activityPlan && plan.activityPlan.nextWeek;\nif (!isObject(nextWeek)) {\n  errors.push('activityPlan.nextWeek must be object');\n} else {\n  reqString(nextWeek, 'phase', 'activityPlan.nextWeek');\n  reqString(nextWeek, 'objective', 'activityPlan.nextWeek');\n  if (!reqString(nextWeek, 'weekStart', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekStart)) {\n    errors.push('activityPlan.nextWeek.weekStart must be YYYY-MM-DD');\n  }\n  if (!reqString(nextWeek, 'weekEnd', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekEnd)) {\n    errors.push('activityPlan.nextWeek.weekEnd must be YYYY-MM-DD');\n  }\n}\n\nconst days = plan.activityPlan && plan.activityPlan.days;\nif (!Array.isArray(days)) {\n  errors.push('activityPlan.days must be array');\n} else if (days.length !== 7) {\n  errors.push('activityPlan.days must have length 7');\n} else {\n  days.forEach((day, idx) => {\n    const path = `activityPlan.days[${idx}]`;\n    if (!isObject(day)) {\n      errors.push(`${path} must be object`);\n      return;\n    }\n    if (!reqString(day, 'day', path) || !dayRe.test(day.day)) {\n      errors.push(`${path}.day must be a valid weekday`);\n    }\n    if (!reqString(day, 'date', path) || !dateRe.test(day.date)) {\n      errors.push(`${path}.date must be YYYY-MM-DD`);\n    }\n    reqString(day, 'activity', path);\n    reqString(day, 'distance_time', path);\n    if (!reqString(day, 'intensity', path) || !intensityRe.test(day.intensity)) {\n      errors.push(`${path}.intensity must include a zone/label or be '-'/'--'/'—'`);\n    }\n    reqString(day, 'goal', path);\n  });\n}\n\n\n// Guardrails (hard rules)\nif (Array.isArray(days) && days.length === 7) {\n  const normalizeDay = (value) => (value || '')\n    .toLowerCase()\n    .replace(/[áàä]/g, 'a')\n    .replace(/[éèë]/g, 'e')\n    .replace(/[íìï]/g, 'i')\n    .replace(/[óòö]/g, 'o')\n    .replace(/[úùü]/g, 'u')\n    .replace(/ñ/g, 'n');\n  const activityText = (day) => `${day.activity || ''} ${day.goal || ''} ${day.note || ''}`.toLowerCase();\n  const intensityText = (day) => (day.intensity || '').toLowerCase();\n  const containsToken = (text, tokens) => tokens.some((token) => text.includes(token));\n\n  const hardTokens = ['z4', 'z5', 'vo2', 'interval', 'umbral', 'tempo', 'threshold'];\n  const easyTokens = ['z1', 'z2', 'easy', 'recovery', 'recuper', 'suave'];\n  const restTokens = ['descanso', 'rest', 'off'];\n  const longTokens = ['tirada', 'larga', 'long'];\n  const gymTokens = ['gimnasio', 'gym', 'fuerza', 'strength'];\n\n  const isHard = (day) => containsToken(intensityText(day), hardTokens) || containsToken(activityText(day), hardTokens);\n  const isEasy = (day) => containsToken(intensityText(day), easyTokens) || containsToken(activityText(day), easyTokens);\n  const isRest = (day) => containsToken(activityText(day), restTokens) || ['-', '--', '—', '–'].includes((day.intensity || '').trim());\n  const normalizedDays = days.map((day) => normalizeDay(day.day));\n  const uniqueDays = new Set(normalizedDays);\n  if (uniqueDays.size !== 7) {\n    errors.push('guardrail: days must cover all weekdays exactly once');\n  }\n  const requiredDays = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'];\n  requiredDays.forEach((name) => {\n    if (!uniqueDays.has(name)) {\n      errors.push(`guardrail: missing weekday ${name}`);\n    }\n  });\n\n  const isLong = (day) => containsToken(activityText(day), longTokens);\n\n  const hardCount = days.filter(isHard).length;\n  if (hardCount > 2) {\n    errors.push(`guardrail: too many hard sessions (${hardCount} > 2)`);\n  }\n\n  for (let i = 1; i < days.length; i += 1) {\n    if (isHard(days[i]) && isHard(days[i - 1])) {\n      errors.push(`guardrail: back-to-back hard sessions (days ${i} and ${i + 1})`);\n    }\n  }\n\n  const hasRecovery = days.some((day) => isRest(day) || isEasy(day));\n  if (!hasRecovery) {\n    errors.push('guardrail: must include at least one rest or recovery day');\n  }\n\n  const longCount = days.filter(isLong).length;\n  if (longCount > 1) {\n    errors.push('guardrail: only one long run per week');\n  }\n\n  days.forEach((day, idx) => {\n    if (isLong(day) && isHard(day)) {\n      errors.push(`guardrail: long run cannot be hard intensity (day ${idx + 1})`);\n    }\n  });\n\n  const gymDays = ['martes', 'jueves', 'sabado'];\n  gymDays.forEach((name) => {\n    const day = days.find((d) => normalizeDay(d.day) === name);\n    if (day && !containsToken(activityText(day), gymTokens)) {\n      errors.push(`guardrail: ${name} should include gym/strength`);\n    }\n  });\n}\nconst valid = errors.length == 0;\n\nconst output = isObject(plan) ? JSON.parse(JSON.stringify(plan)) : {};\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\n\noutput.__valid = valid;\noutput.__errors = errors;\noutput.__attempt = attempt;\noutput.__raw = typeof raw === 'string' ? raw : JSON.stringify(raw);\nif (runContext.runId) output.__runId = runContext.runId;\nif (runContext.promptVersion) output.__promptVersion = runContext.promptVersion;\nif (runContext.modelId) output.__modelId = runContext.modelId;\n\nreturn [{ json: output }];\n"
      }
    },
    {
      "id": "fa78a02f-56e7-4eb7-9abe-13ee6d7391b0",
      "name": "Is WeeklyPlan valid? (attempt 1)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1960,
        620
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.__valid }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "82fbdd65-c54a-431a-b4af-7a0dec970aba",
      "name": "Build Repair Prompt (attempt 2)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1960,
        800
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 2;\nconst raw = items[0].json.__raw || JSON.stringify(items[0].json || {});\nconst errors = items[0].json.__errors || [];\n\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst runId = runContext.runId || null;\nconst promptVersion = runContext.promptVersion || null;\nconst modelId = runContext.modelId || null;\n\nconst schemaSnippet = `{\n  \"schema_version\": \"1.0\",\n  \"activityPlan\": {\n    \"nextWeek\": { \"phase\": \"...\", \"objective\": \"...\", \"weekStart\": \"YYYY-MM-DD\", \"weekEnd\": \"YYYY-MM-DD\" },\n    \"days\": [\n      { \"day\": \"Lunes\", \"date\": \"YYYY-MM-DD\", \"activity\": \"...\", \"distance_time\": \"...\", \"intensity\": \"Z1-Z5\", \"goal\": \"...\", \"note\": \"...\" }\n    ]\n  },\n  \"justification\": [\"...\"]\n}`;\n\nconst repair_prompt = `You must return ONLY a valid minified JSON object that matches this schema snippet:\\n${schemaSnippet}\\n\\nInvalid output:\\n${raw}\\n\\nValidation errors:\\n${errors.join('\\n')}`;\n\nreturn [{ json: { repair_prompt, __attempt: attempt, __errors: errors, __raw: raw, runId, promptVersion, modelId } }];\n"
      }
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-5",
          "mode": "list",
          "cachedResultName": "GPT-5"
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a JSON repair bot. Return only valid minified JSON."
            },
            {
              "role": "user",
              "content": "={{ $json.repair_prompt }}"
            }
          ]
        },
        "simplify": false,
        "jsonOutput": true,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        2160,
        800
      ],
      "id": "6001c0c9-0433-4398-b371-ef28ba5f7a0d",
      "name": "Repair Plan 2",
      "alwaysOutputData": false,
      "credentials": {
        "openAiApi": {
          "id": "olyatB4PnLtBz9VL",
          "name": "OpenAi account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "id": "fb318502-d4da-4197-8708-51e0946a6a5b",
      "name": "Validate WeeklyPlan (attempt 2)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2360,
        800
      ],
      "parameters": {
        "jsCode": "\nconst attempt = 2;\n\nconst raw = Array.isArray(items[0].json.choices)\n  ? items[0].json.choices[0].message.content\n  : items[0].json;\n\nlet parsed = raw;\nlet parseError = null;\n\nif (typeof raw === 'string') {\n  try {\n    parsed = JSON.parse(raw);\n  } catch (err) {\n    parseError = err && err.message ? err.message : String(err);\n    parsed = null;\n  }\n}\n\nconst errors = [];\n\nif (parseError) {\n  errors.push(`invalid_json: ${parseError}`);\n}\n\nconst isObject = value => value && typeof value === 'object' && !Array.isArray(value);\nconst plan = isObject(parsed) ? parsed : {};\n\nconst dateRe = /^\\d{4}-\\d{2}-\\d{2}$/;\nconst dayRe = /^(Lunes|Martes|Miercoles|Mi\\u00e9rcoles|Jueves|Viernes|Sabado|S\\u00e1bado|Domingo)$/;\nconst intensityRe = /^(?:-|--|\\u2014|.*\\b(Z[1-5]|interval|Interval|VO2|Tempo|tempo|Umbral|umbral|Threshold|threshold|Easy|easy|Recovery|recovery)\\b.*)$/;\n\nconst reqString = (obj, key, path) => {\n  const value = obj ? obj[key] : undefined;\n  if (typeof value !== 'string' || !value.trim()) {\n    errors.push(`${path}.${key} missing`);\n    return false;\n  }\n  return true;\n};\n\nif (plan.schema_version !== '1.0') {\n  errors.push('schema_version must be \"1.0\"');\n}\n\nif (!isObject(plan.activityPlan)) {\n  errors.push('activityPlan must be object');\n}\n\nconst nextWeek = plan.activityPlan && plan.activityPlan.nextWeek;\nif (!isObject(nextWeek)) {\n  errors.push('activityPlan.nextWeek must be object');\n} else {\n  reqString(nextWeek, 'phase', 'activityPlan.nextWeek');\n  reqString(nextWeek, 'objective', 'activityPlan.nextWeek');\n  if (!reqString(nextWeek, 'weekStart', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekStart)) {\n    errors.push('activityPlan.nextWeek.weekStart must be YYYY-MM-DD');\n  }\n  if (!reqString(nextWeek, 'weekEnd', 'activityPlan.nextWeek') || !dateRe.test(nextWeek.weekEnd)) {\n    errors.push('activityPlan.nextWeek.weekEnd must be YYYY-MM-DD');\n  }\n}\n\nconst days = plan.activityPlan && plan.activityPlan.days;\nif (!Array.isArray(days)) {\n  errors.push('activityPlan.days must be array');\n} else if (days.length !== 7) {\n  errors.push('activityPlan.days must have length 7');\n} else {\n  days.forEach((day, idx) => {\n    const path = `activityPlan.days[${idx}]`;\n    if (!isObject(day)) {\n      errors.push(`${path} must be object`);\n      return;\n    }\n    if (!reqString(day, 'day', path) || !dayRe.test(day.day)) {\n      errors.push(`${path}.day must be a valid weekday`);\n    }\n    if (!reqString(day, 'date', path) || !dateRe.test(day.date)) {\n      errors.push(`${path}.date must be YYYY-MM-DD`);\n    }\n    reqString(day, 'activity', path);\n    reqString(day, 'distance_time', path);\n    if (!reqString(day, 'intensity', path) || !intensityRe.test(day.intensity)) {\n      errors.push(`${path}.intensity must include a zone/label or be '-'/'--'/'—'`);\n    }\n    reqString(day, 'goal', path);\n  });\n}\n\n\n// Guardrails (hard rules)\nif (Array.isArray(days) && days.length === 7) {\n  const normalizeDay = (value) => (value || '')\n    .toLowerCase()\n    .replace(/[áàä]/g, 'a')\n    .replace(/[éèë]/g, 'e')\n    .replace(/[íìï]/g, 'i')\n    .replace(/[óòö]/g, 'o')\n    .replace(/[úùü]/g, 'u')\n    .replace(/ñ/g, 'n');\n  const activityText = (day) => `${day.activity || ''} ${day.goal || ''} ${day.note || ''}`.toLowerCase();\n  const intensityText = (day) => (day.intensity || '').toLowerCase();\n  const containsToken = (text, tokens) => tokens.some((token) => text.includes(token));\n\n  const hardTokens = ['z4', 'z5', 'vo2', 'interval', 'umbral', 'tempo', 'threshold'];\n  const easyTokens = ['z1', 'z2', 'easy', 'recovery', 'recuper', 'suave'];\n  const restTokens = ['descanso', 'rest', 'off'];\n  const longTokens = ['tirada', 'larga', 'long'];\n  const gymTokens = ['gimnasio', 'gym', 'fuerza', 'strength'];\n\n  const isHard = (day) => containsToken(intensityText(day), hardTokens) || containsToken(activityText(day), hardTokens);\n  const isEasy = (day) => containsToken(intensityText(day), easyTokens) || containsToken(activityText(day), easyTokens);\n  const isRest = (day) => containsToken(activityText(day), restTokens) || ['-', '--', '—', '–'].includes((day.intensity || '').trim());\n  const normalizedDays = days.map((day) => normalizeDay(day.day));\n  const uniqueDays = new Set(normalizedDays);\n  if (uniqueDays.size !== 7) {\n    errors.push('guardrail: days must cover all weekdays exactly once');\n  }\n  const requiredDays = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo'];\n  requiredDays.forEach((name) => {\n    if (!uniqueDays.has(name)) {\n      errors.push(`guardrail: missing weekday ${name}`);\n    }\n  });\n\n  const isLong = (day) => containsToken(activityText(day), longTokens);\n\n  const hardCount = days.filter(isHard).length;\n  if (hardCount > 2) {\n    errors.push(`guardrail: too many hard sessions (${hardCount} > 2)`);\n  }\n\n  for (let i = 1; i < days.length; i += 1) {\n    if (isHard(days[i]) && isHard(days[i - 1])) {\n      errors.push(`guardrail: back-to-back hard sessions (days ${i} and ${i + 1})`);\n    }\n  }\n\n  const hasRecovery = days.some((day) => isRest(day) || isEasy(day));\n  if (!hasRecovery) {\n    errors.push('guardrail: must include at least one rest or recovery day');\n  }\n\n  const longCount = days.filter(isLong).length;\n  if (longCount > 1) {\n    errors.push('guardrail: only one long run per week');\n  }\n\n  days.forEach((day, idx) => {\n    if (isLong(day) && isHard(day)) {\n      errors.push(`guardrail: long run cannot be hard intensity (day ${idx + 1})`);\n    }\n  });\n\n  const gymDays = ['martes', 'jueves', 'sabado'];\n  gymDays.forEach((name) => {\n    const day = days.find((d) => normalizeDay(d.day) === name);\n    if (day && !containsToken(activityText(day), gymTokens)) {\n      errors.push(`guardrail: ${name} should include gym/strength`);\n    }\n  });\n}\nconst valid = errors.length == 0;\n\nconst output = isObject(plan) ? JSON.parse(JSON.stringify(plan)) : {};\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\n\noutput.__valid = valid;\noutput.__errors = errors;\noutput.__attempt = attempt;\noutput.__raw = typeof raw === 'string' ? raw : JSON.stringify(raw);\nif (runContext.runId) output.__runId = runContext.runId;\nif (runContext.promptVersion) output.__promptVersion = runContext.promptVersion;\nif (runContext.modelId) output.__modelId = runContext.modelId;\n\nreturn [{ json: output }];\n"
      }
    },
    {
      "id": "512261fd-832f-4c54-b584-199df7c8a2e5",
      "name": "Is WeeklyPlan valid? (attempt 2)",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        2560,
        800
      ],
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.__valid }}",
              "operation": "isTrue"
            }
          ]
        }
      }
    },
    {
      "id": "60ab564c-0d54-46ac-857f-17eaa539b4bc",
      "name": "Fallback Trigger",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2760,
        980
      ],
      "parameters": {
        "jsCode": "throw new Error('Fallback required after max repair attempts.');"
      }
    },
    {
      "id": "1a5427aa-0afa-409b-bbda-2c0808182bbf",
      "name": "Build Run Event (success)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1268,
        328
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst plan = content.activityPlan || {};\nconst nextWeek = plan.nextWeek || {};\n\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst runId = runContext.runId || content.runId || `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\n\nconst runEvent = {\n  runId,\n  status: 'success',\n  attempt: content.__attempt ?? null,\n  weekStart: nextWeek.weekStart || null,\n  weekEnd: nextWeek.weekEnd || null,\n  errorCount: errors.length,\n  errors,\n  createdAt: new Date().toISOString()\n};\n\nreturn [{\n  json: Object.assign({}, content, runEvent, { runEvent })\n}];\n"
      }
    },
    {
      "id": "76a0bc8d-962a-4fb4-adbd-f5968b5b83eb",
      "name": "Run Events DB (success)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1588,
        328
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_events",
        "updateKey": "runId",
        "fields": "runId, status, attempt, weekStart, weekEnd, errorCount, errors, telegramTemplateVersion, sectionCompleteness, sectionMissingCount, whyThisPlan, whyPlanMetricKeys, whyPlanHallucinationFailures, previewMode, previewChatId, riskWarningTriggerCount, riskWarningTriggers, riskWarningTriggerCounts, riskFeedback, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "92307575-ea91-4bac-b23a-1860c54c24c9",
      "name": "Build Failure Event",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        980
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst plan = content.activityPlan || {};\nconst nextWeek = plan.nextWeek || {};\n\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst runId = runContext.runId || content.runId || `${new Date().toISOString()}-${Math.random().toString(36).slice(2, 8)}`;\nconst errors = Array.isArray(content.__errors) ? content.__errors : ['validation failed'];\n\nconst runEvent = {\n  runId,\n  status: 'failure',\n  attempt: content.__attempt ?? null,\n  weekStart: nextWeek.weekStart || null,\n  weekEnd: nextWeek.weekEnd || null,\n  errorCount: errors.length,\n  errors,\n  createdAt: new Date().toISOString()\n};\n\nconst alertMessage = [\n  '⚠️ Running Coach workflow failed',\n  `Run: ${runId}`,\n  `Errors (${errors.length}):`,\n  ...errors.map(err => `- ${err}`)\n].join('\n');\n\nreturn [{\n  json: Object.assign({}, content, runEvent, { runEvent, alertMessage })\n}];\n"
      }
    },
    {
      "id": "57d9052d-75a5-468d-a5f8-e61dbd8f7f91",
      "name": "Run Events DB (failure)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        2480,
        980
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_events",
        "updateKey": "runId",
        "fields": "runId, status, attempt, weekStart, weekEnd, errorCount, errors, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "e0eb79f9-5da4-43bb-a51f-230f787624fd",
      "name": "Send Failure Alert",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        2720,
        980
      ],
      "parameters": {
        "chatId": "730354404",
        "text": "={{ $json.alertMessage }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "webhookId": "ae55f720-070b-42e2-b07e-f202cb99ced4",
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "id": "2d8f2e3c-1c6b-4b11-8b6f-6d6a1fcb55a2",
      "name": "Plan Snapshots DB",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1388,
        328
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "plan_snapshots",
        "updateKey": "runId",
        "fields": "runId, attempt, weekStart, weekEnd, schema_version, activityPlan, justification, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "948d6cd7-5470-4427-8cce-914769862399",
      "name": "Run Artifacts DB (inputs)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1088,
        640
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_artifacts",
        "updateKey": "runId",
        "fields": "runId, promptVersion, modelId, prompt, metrics, history, activities, wellness, createdAt",
        "upsert": true,
        "options": {
          "dateFields": "createdAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "3912d34c-0bb2-4073-b920-2a9ce7009bc1",
      "name": "Build Run Artifact (outputs)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        128
      ],
      "parameters": {
        "jsCode": "const content = items[0].json || {};\nconst runContextItems = $items(\"Prompt Builder\");\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\n\nconst errors = Array.isArray(content.__errors) ? content.__errors : [];\nconst outputValidated = content.activityPlan ? {\n  schema_version: content.schema_version,\n  activityPlan: content.activityPlan,\n  justification: content.justification\n} : null;\n\nreturn [{\n  json: {\n    runId: runContext.runId || content.runId,\n    promptVersion: runContext.promptVersion || null,\n    modelId: runContext.modelId || null,\n    status: content.status || (content.__valid ? 'success' : 'failure'),\n    attempt: content.__attempt ?? null,\n    outputValidated,\n    outputRaw: content.__raw ?? null,\n    errors,\n    errorCount: errors.length,\n    updatedAt: new Date().toISOString()\n  }\n}];\n"
      }
    },
    {
      "id": "9e28f9fd-c2ae-4df0-9557-1808cc338b53",
      "name": "Run Artifacts DB (outputs)",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1712,
        128
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "run_artifacts",
        "updateKey": "runId",
        "fields": "runId, promptVersion, modelId, status, attempt, outputValidated, outputRaw, errors, errorCount, updatedAt",
        "upsert": true,
        "options": {
          "dateFields": "updatedAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "3623b766-3f29-4593-b706-255a8becd8c3",
      "name": "Build Feedback Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        448
      ],
      "parameters": {
        "jsCode": "const DEFAULT_CHAT_ID = '730354404';\n\nconst getVar = (key) => {\n  if (typeof $vars !== 'undefined' && $vars[key] != null) {\n    return String($vars[key]);\n  }\n  if (typeof process !== 'undefined' && process.env && process.env[key] != null) {\n    return String(process.env[key]);\n  }\n  return '';\n};\n\nconst isTruthy = (value) => ['1', 'true', 'yes', 'on'].includes(String(value).toLowerCase());\n\nconst previewEnabled = isTruthy(getVar('RC_TELEGRAM_PREVIEW_MODE'));\nconst previewChatRaw = getVar('RC_TELEGRAM_PREVIEW_CHAT_ID').trim();\nif (previewEnabled && !previewChatRaw) {\n  throw new Error('RC_TELEGRAM_PREVIEW_CHAT_ID is required when RC_TELEGRAM_PREVIEW_MODE is enabled.');\n}\nconst targetChatId = previewEnabled ? previewChatRaw : DEFAULT_CHAT_ID;\n\nconst runContextItems = $items('Prompt Builder');\nconst runContext = runContextItems.length ? runContextItems[0].json : {};\nconst plan = $json.activityPlan || {};\nconst nextWeek = plan.nextWeek || {};\nconst runId = (runContext.runId || $json.runId || ($json.runEvent && $json.runEvent.runId) || $json.__runId || null);\nif (!runId) { return []; }\n\nconst weekLabel = (nextWeek.weekStart && nextWeek.weekEnd) ? `${nextWeek.weekStart} → ${nextWeek.weekEnd}` : 'this week';\nconst text = [\n  previewEnabled ? '🧪 <b>Preview mode</b>' : null,\n  `📝 <b>Quick feedback</b> (${weekLabel})`,\n  'How did your latest session feel?',\n  'Tap one option:'\n].filter(Boolean).join('\\n');\n\nconst replyMarkup = {\n  inline_keyboard: [\n    [{ text: '✅ Done', callback_data: `feedback|${runId}|done` }],\n    [{ text: '❌ Skipped', callback_data: `feedback|${runId}|skipped` }],\n    [{ text: '😵 Hard', callback_data: `feedback|${runId}|hard` }],\n    [{ text: '🦵 Pain', callback_data: `feedback|${runId}|pain` }],\n  ]\n};\n\nreturn [{\n  json: {\n    chatId: targetChatId,\n    text,\n    replyMarkup,\n    runId,\n    previewMode: previewEnabled,\n    previewChatId: targetChatId,\n  }\n}];\n"
      }
    },
    {
      "id": "81adaf55-23cc-466c-8876-c4ff27f4073b",
      "name": "Send Feedback Prompt",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        2000,
        448
      ],
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "parse_mode": "HTML",
          "replyMarkup": "={{ JSON.stringify($json.replyMarkup) }}"
        }
      },
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "id": "d2b2cc48-5fe2-4dac-8bd5-5edfc8984a54",
      "name": "Telegram Feedback Trigger",
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1,
      "position": [
        -200,
        -200
      ],
      "parameters": {
        "updates": [
          "callback_query"
        ]
      },
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "id": "4febcf54-ca29-4bdb-b2f4-e28c880f9b95",
      "name": "Parse Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -200
      ],
      "parameters": {
        "jsCode": "const update = items[0].json || {};\nconst callback = update.callback_query || update.body?.callback_query || null;\nif (!callback || !callback.data) { return []; }\n\nconst parts = String(callback.data).split('|');\nif (parts[0] !== 'feedback' || parts.length < 3) { return []; }\n\nconst runId = parts[1];\nconst response = parts[2].toLowerCase();\nconst allowedResponses = new Set(['done', 'skipped', 'hard', 'pain']);\nif (!allowedResponses.has(response)) { return []; }\n\nconst message = callback.message || {};\nconst chatId = message.chat && message.chat.id ? String(message.chat.id) : null;\nconst messageId = message.message_id || null;\nconst messageDate = message.date ? new Date(message.date * 1000) : new Date();\nconst now = new Date();\nconst sessionDate = messageDate.toISOString().slice(0, 10);\nconst sessionDay = messageDate.toLocaleDateString('en-US', { weekday: 'long' });\nconst promptAgeDays = Math.floor(Math.max(now.getTime() - messageDate.getTime(), 0) / 86400000);\nconst isLateResponse = promptAgeDays > 14;\n\nconst user = callback.from || {};\nconst userId = user.id || null;\nconst sessionKey = `${runId}-${messageId || sessionDate}-${userId || 'anon'}`;\n\nreturn [{\n  json: {\n    sessionKey,\n    runId,\n    response,\n    sessionDate,\n    sessionDay,\n    chatId,\n    messageId,\n    userId,\n    username: user.username || null,\n    promptSentAt: messageDate.toISOString(),\n    promptAgeDays,\n    isLateResponse,\n    receivedAt: now.toISOString()\n  }\n}];\n"
      }
    },
    {
      "id": "71c41d55-4ed9-4934-ad94-1d6044774104",
      "name": "Feedback Events DB",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        220,
        -200
      ],
      "alwaysOutputData": true,
      "parameters": {
        "operation": "findOneAndUpdate",
        "collection": "feedback_events",
        "updateKey": "sessionKey",
        "fields": "sessionKey, runId, response, sessionDate, sessionDay, chatId, messageId, userId, username, promptSentAt, promptAgeDays, isLateResponse, receivedAt",
        "upsert": true,
        "options": {
          "dateFields": "receivedAt"
        }
      },
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "id": "3c6afed0-56fe-4a6c-b0f2-59fee294b969",
      "name": "Send Feedback Ack",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        440,
        -200
      ],
      "parameters": {
        "chatId": "={{ $json.chatId }}",
        "text": "={{ $json.isLateResponse ? `⚠️ Feedback ignored: this prompt is ${$json.promptAgeDays} days old. Please answer from your latest weekly message.` : `✅ Feedback saved: ${$json.response}` }}"
      },
      "credentials": {
        "telegramApi": {
          "id": "hdQmaYn1B2efrJvB",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {
        "collection": "feedback_events",
        "options": {
          "sort": "{ \"receivedAt\": -1 }"
        },
        "query": "={\n  \"response\": \"pain\"\n}\n"
      },
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1320,
        620
      ],
      "id": "ac9f5d41-e9e0-4f3c-96af-185f56cb29ce",
      "name": "Read Recent Pain Feedback",
      "alwaysOutputData": true,
      "credentials": {
        "mongoDb": {
          "id": "8KyRHmD3ScRn2PPF",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const RISK_WINDOW_DAYS = 14;\nconst cutoffMs = Date.now() - (RISK_WINDOW_DAYS * 24 * 60 * 60 * 1000);\n\nconst docs = items\n  .map((item) => item.json || {})\n  .filter((doc) => doc && Object.keys(doc).length > 0);\n\nconst toTs = (value) => {\n  const ts = new Date(value || 0).getTime();\n  return Number.isFinite(ts) ? ts : null;\n};\n\nconst painDocs = docs.filter((doc) => {\n  if (String(doc.response || '').toLowerCase() !== 'pain') return false;\n  const ts = toTs(doc.receivedAt || doc.sessionDate);\n  return ts !== null && ts >= cutoffMs;\n});\n\nconst latestPain = [...painDocs].sort((a, b) => {\n  const aTs = toTs(a.receivedAt || a.sessionDate) || 0;\n  const bTs = toTs(b.receivedAt || b.sessionDate) || 0;\n  return bTs - aTs;\n})[0] || null;\n\nconst baseItems = $items('Build Run Event (success)');\nconst basePayload = baseItems.length ? (baseItems[0].json || {}) : {};\n\nconst riskFeedback = {\n  hasRecentPain: painDocs.length > 0,\n  painEventCount: painDocs.length,\n  latestPainDate: latestPain ? (latestPain.sessionDate || String(latestPain.receivedAt || '').slice(0, 10)) : null,\n  windowDays: RISK_WINDOW_DAYS,\n};\n\nreturn [{\n  json: Object.assign({}, basePayload, { riskFeedback }),\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        620
      ],
      "id": "799a0656-9818-4e74-9046-5c70b2898757",
      "name": "Summarize Pain Feedback"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isLateResponse }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        220,
        -320
      ],
      "id": "f0b90789-89af-4b90-a1a5-df6507a43f63",
      "name": "Is Feedback Late?"
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "GET Activities",
            "type": "main",
            "index": 0
          },
          {
            "node": "GET Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Map Activities + Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Activities": {
      "main": [
        [
          {
            "node": "Activities DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Wellness": {
      "main": [
        [
          {
            "node": "Wellness DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET Wellness": {
      "main": [
        [
          {
            "node": "Shape Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET Activities": {
      "main": [
        [
          {
            "node": "Shape Activities",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Shape Weekly Metrics": {
      "main": [
        [
          {
            "node": "Weekly Metrics DB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Previous Weeks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Previous Weeks": {
      "main": [
        [
          {
            "node": "Merge Current & History",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Current & History": {
      "main": [
        [
          {
            "node": "Map Current + History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Current + History": {
      "main": [
        [
          {
            "node": "Merge Request Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Weekly Metrics DB": {
      "main": [
        [
          {
            "node": "Merge Current & History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map Activities + Wellness": {
      "main": [
        [
          {
            "node": "Shape Weekly Metrics",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Request Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Request Data": {
      "main": [
        [
          {
            "node": "Prompt Builder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prompt Builder": {
      "main": [
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          },
          {
            "node": "Run Artifacts DB (inputs)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Message a model": {
      "main": [
        [
          {
            "node": "Validate WeeklyPlan (attempt 0)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Telegram Message": {
      "main": [
        [
          {
            "node": "Run Events DB (success)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wellness DB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Activities DB": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "GET Activities",
            "type": "main",
            "index": 0
          },
          {
            "node": "GET Wellness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate WeeklyPlan (attempt 0)": {
      "main": [
        [
          {
            "node": "Is WeeklyPlan valid? (attempt 0)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is WeeklyPlan valid? (attempt 0)": {
      "main": [
        [
          {
            "node": "Build Run Event (success)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Repair Prompt (attempt 1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Repair Prompt (attempt 1)": {
      "main": [
        [
          {
            "node": "Repair Plan 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repair Plan 1": {
      "main": [
        [
          {
            "node": "Validate WeeklyPlan (attempt 1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate WeeklyPlan (attempt 1)": {
      "main": [
        [
          {
            "node": "Is WeeklyPlan valid? (attempt 1)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is WeeklyPlan valid? (attempt 1)": {
      "main": [
        [
          {
            "node": "Build Run Event (success)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Repair Prompt (attempt 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Repair Prompt (attempt 2)": {
      "main": [
        [
          {
            "node": "Repair Plan 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repair Plan 2": {
      "main": [
        [
          {
            "node": "Validate WeeklyPlan (attempt 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate WeeklyPlan (attempt 2)": {
      "main": [
        [
          {
            "node": "Is WeeklyPlan valid? (attempt 2)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is WeeklyPlan valid? (attempt 2)": {
      "main": [
        [
          {
            "node": "Build Run Event (success)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Failure Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fallback Trigger": {
      "main": []
    },
    "Build Run Event (success)": {
      "main": [
        [
          {
            "node": "Plan Snapshots DB",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Run Artifact (outputs)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Read Recent Pain Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Events DB (success)": {
      "main": [
        [
          {
            "node": "Send a text message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Feedback Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Failure Event": {
      "main": [
        [
          {
            "node": "Run Events DB (failure)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Run Artifact (outputs)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Events DB (failure)": {
      "main": [
        [
          {
            "node": "Send Failure Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Failure Alert": {
      "main": [
        [
          {
            "node": "Fallback Trigger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Plan Snapshots DB": {
      "main": []
    },
    "Build Run Artifact (outputs)": {
      "main": [
        [
          {
            "node": "Run Artifacts DB (outputs)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Artifacts DB (inputs)": {
      "main": []
    },
    "Run Artifacts DB (outputs)": {
      "main": []
    },
    "Build Feedback Prompt": {
      "main": [
        [
          {
            "node": "Send Feedback Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram Feedback Trigger": {
      "main": [
        [
          {
            "node": "Parse Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Feedback": {
      "main": [
        [
          {
            "node": "Is Feedback Late?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Feedback Events DB": {
      "main": [
        [
          {
            "node": "Send Feedback Ack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Recent Pain Feedback": {
      "main": [
        [
          {
            "node": "Summarize Pain Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize Pain Feedback": {
      "main": [
        [
          {
            "node": "Build Telegram Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Feedback Late?": {
      "main": [
        [
          {
            "node": "Feedback Events DB",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send Feedback Ack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "a3f728cc-fe6f-45c9-bd6d-430a6e8a3f9b",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "32e042aaa93a0c2717f17fdbf6d1b765a1d2543e64737ddc9ed84499712f834c"
  },
  "id": "Q9nTNHZ5vUBf58oI",
  "tags": []
}
